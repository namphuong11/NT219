\chapter{Notes for Android platforms}
\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d}{}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d}\index{Notes for Android platforms@{Notes for Android platforms}}
\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md866}{}\doxysection{\texorpdfstring{Requirement details}{Requirement details}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md866}
Beside basic tools like perl and make, you\textquotesingle{}ll need to download the Android NDK. It\textquotesingle{}s available for Linux, mac\+OS and Windows, but only Linux version was actually tested. There is no reason to believe that mac\+OS wouldn\textquotesingle{}t work. And as for Windows, it\textquotesingle{}s unclear which "{}shell"{} would be suitable, MSYS2 might have best chances. NDK version should play lesser role, the goal is to support a range of most recent versions.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md867}{}\doxysection{\texorpdfstring{Configuration}{Configuration}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md867}
Android is a cross-\/compiled target and you can\textquotesingle{}t rely on {\ttfamily ./\+Configure} to find out the configuration target for you. You have to name your target explicitly; there are {\ttfamily android-\/arm}, {\ttfamily android-\/arm64}, {\ttfamily android-\/mips}, {\ttfamily android-\/mip64}, {\ttfamily android-\/x86} and {\ttfamily android-\/x86\+\_\+64} ({\ttfamily \texorpdfstring{$\ast$}{*}\+MIPS} targets are no longer supported with NDK R20+).

Do not pass --cross-\/compile-\/prefix (as you might be tempted), as it will be "{}calculated"{} automatically based on chosen platform. However, you still need to know the prefix to extend your PATH, in order to invoke {\ttfamily \$(CROSS\+\_\+\+COMPILE)clang} \mbox{[}{\ttfamily \texorpdfstring{$\ast$}{*}gcc} on NDK 19 and lower\mbox{]} and company. ({\ttfamily ./\+Configure} will fail and give you a hint if you get it wrong.)

Apart from {\ttfamily PATH} adjustment, you need to set {\ttfamily ANDROID\+\_\+\+NDK\+\_\+\+ROOT} environment to point at the {\ttfamily NDK} directory. If you\textquotesingle{}re using a side-\/by-\/side NDK the path will look something like {\ttfamily /some/where/android-\/sdk/ndk/\texorpdfstring{$<$}{<}ver\texorpdfstring{$>$}{>}}, and for a standalone NDK the path will be something like {\ttfamily /some/where/android-\/ndk-\/\texorpdfstring{$<$}{<}ver\texorpdfstring{$>$}{>}}. Both variables are significant at both configuration and compilation times. The NDK customarily supports multiple Android API levels, e.\+g. {\ttfamily android-\/14}, {\ttfamily android-\/21}, etc. By default, latest API level is chosen. If you need to target an older platform pass the argument {\ttfamily -\/D\+\_\+\+\_\+\+ANDROID\+\_\+\+API\+\_\+\+\_\+=N} to {\ttfamily Configure}, with {\ttfamily N} being the numerical value of the target platform version. For example, to compile for Android 10 arm64 with a side-\/by-\/side NDK r20.\+0.\+5594570

export ANDROID\+\_\+\+NDK\+\_\+\+ROOT=/home/whoever/\+Android/android-\/sdk/ndk/20.0.\+5594570 PATH=\$\+ANDROID\+\_\+\+NDK\+\_\+\+ROOT/toolchains/llvm/prebuilt/linux-\/x86\+\_\+64/bin\+:\$\+ANDROID\+\_\+\+NDK\+\_\+\+ROOT/toolchains/arm-\/linux-\/androideabi-\/4.9/prebuilt/linux-\/x86\+\_\+64/bin\+:\$\+PATH ./\+Configure android-\/arm64 -\/D\+\_\+\+\_\+\+ANDROID\+\_\+\+API\+\_\+\+\_\+=29 make

Older versions of the NDK have GCC under their common prebuilt tools directory, so the bin path will be slightly different. EG\+: to compile for ICS on ARM with NDK 10d\+:

export ANDROID\+\_\+\+NDK\+\_\+\+ROOT=/some/where/android-\/ndk-\/10d PATH=\$\+ANDROID\+\_\+\+NDK\+\_\+\+ROOT/toolchains/arm-\/linux-\/androideabi-\/4.8/prebuilt/linux-\/x86\+\_\+64/bin\+:\$\+PATH ./\+Configure android-\/arm -\/D\+\_\+\+\_\+\+ANDROID\+\_\+\+API\+\_\+\+\_\+=14 make

Caveat lector! Earlier Open\+SSL versions relied on additional {\ttfamily CROSS\+\_\+\+SYSROOT} variable set to {\ttfamily \$ANDROID\+\_\+\+NDK\+\_\+\+ROOT/platforms/android-\/\texorpdfstring{$<$}{<}api\texorpdfstring{$>$}{>}/arch-\/\texorpdfstring{$<$}{<}arch\texorpdfstring{$>$}{>}} to appoint headers-\/n-\/libraries\textquotesingle{} location. It\textquotesingle{}s still recognized in order to facilitate migration from older projects. However, since API level appears in {\ttfamily CROSS\+\_\+\+SYSROOT} value, passing {\ttfamily -\/D\+\_\+\+\_\+\+ANDROID\+\_\+\+API\+\_\+\+\_\+=N} can be in conflict, and mixing the two is therefore not supported. Migration to {\ttfamily CROSS\+\_\+\+SYSROOT}-\/less setup is recommended.

One can engage clang by adjusting PATH to cover the same NDK\textquotesingle{}s clang. Just keep in mind that if you miss it, Configure will try to use gcc... Also, PATH would need even further adjustment to cover unprefixed, yet target-\/specific, ar and ranlib. It\textquotesingle{}s possible that you don\textquotesingle{}t need to bother, if binutils-\/multiarch is installed on your Linux system.

Another option is to create so called "{}standalone toolchain"{} tailored for single specific platform including Android API level, and assign its location to {\ttfamily ANDROID\+\_\+\+NDK\+\_\+\+ROOT}. In such case, you have to pass matching target name to Configure and shouldn\textquotesingle{}t use {\ttfamily -\/D\+\_\+\+\_\+\+ANDROID\+\_\+\+API\+\_\+\+\_\+=N}. {\ttfamily PATH} adjustment becomes simpler, {\ttfamily \$ANDROID\+\_\+\+NDK\+\_\+\+ROOT/bin\+:\$PATH} suffices.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md868}{}\doxysection{\texorpdfstring{Running tests (on Linux)}{Running tests (on Linux)}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2_n_o_t_e_s-_a_n_d_r_o_i_d_autotoc_md868}
This is not actually supported. Notes are meant rather as inspiration.

Even though build output targets alien system, it\textquotesingle{}s possible to execute test suite on Linux system by employing qemu-\/user. The trick is static linking. Pass -\/static to Configure, then edit generated Makefile and remove occurrences of -\/ldl and -\/pie flags. You would also need to pick API version that comes with usable static libraries, 42/2=21 used to work. Once built, you should be able to

env EXE\+\_\+\+SHELL=qemu-\/$<$arch$>$ make test

If you need to pass additional flag to qemu, quotes are your friend, e.\+g.

env EXE\+\_\+\+SHELL="{}qemu-\/mips64el -\/cpu MIPS64\+R6-\/generic"{} make test 