\chapter{QUIC-\/\+TLS Handshake Integration}
\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls}{}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls}\index{QUIC-\/TLS Handshake Integration@{QUIC-\/TLS Handshake Integration}}
QUIC reuses the TLS handshake for the establishment of keys. It does not use the standard TLS record layer and instead assumes responsibility for the confidentiality and integrity of QUIC packets itself. Only the TLS handshake is used. Application data is entirely protected by QUIC.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md447}{}\doxysection{\texorpdfstring{QUIC\+\_\+\+TLS Object}{QUIC\+\_\+\+TLS Object}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md447}
A QUIC-\/\+TLS handshake is managed by a QUIC\+\_\+\+TLS object. This object provides 3 core functions to the rest of the QUIC implementation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{structquic__tls__st}{QUIC\_TLS}}\ *ossl\_quic\_tls\_new(\textcolor{keyword}{const}\ \mbox{\hyperlink{structquic__tls__args__st}{QUIC\_TLS\_ARGS}}\ *args);}

\end{DoxyCode}


The {\ttfamily ossl\+\_\+quic\+\_\+tls\+\_\+new} function instantiates a new {\ttfamily QUIC\+\_\+\+TLS} object associated with the QUIC Connection and initialises it with a set of callbacks and other arguments provided in the {\ttfamily args} parameter. These callbacks are called at various key points during the handshake lifecycle such as when new keys are established, crypto frame data is ready to be sent or consumed, or when the handshake is complete.

A key field of the {\ttfamily args} structure is the {\ttfamily SSL} object ({\ttfamily s}). This "{}inner"{} {\ttfamily SSL} object is initialised with an {\ttfamily SSL\+\_\+\+CONNECTION} to represent the TLS handshake state. This is a different {\ttfamily SSL} object to the "{}user"{} visible {\ttfamily SSL} object which contains a {\ttfamily QUIC\+\_\+\+CONNECTION}, i.\+e. the user visible {\ttfamily SSL} object contains a {\ttfamily QUIC\+\_\+\+CONNECTION} which contains the inner {\ttfamily SSL} object which contains an {\ttfamily SSL\+\_\+\+CONNECTION}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ ossl\_quic\_tls\_free(\mbox{\hyperlink{structquic__tls__st}{QUIC\_TLS}}\ *qtls);}

\end{DoxyCode}


When the QUIC Connection no longer needs the handshake object it can be freed via the {\ttfamily ossl\+\_\+quic\+\_\+tls\+\_\+free} function.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ ossl\_quic\_tls\_tick(\mbox{\hyperlink{structquic__tls__st}{QUIC\_TLS}}\ *qtls);}

\end{DoxyCode}


Finally the {\ttfamily ossl\+\_\+quic\+\_\+tls\+\_\+tick} function is responsible for advancing the state of the QUIC-\/\+TLS handshake. On each call to {\ttfamily ossl\+\_\+quic\+\_\+tls\+\_\+tick} newly received crypto frame data may be consumed, or new crypto frame data may be queued for sending, or one or more of the various callbacks may be invoked.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md448}{}\doxysection{\texorpdfstring{QUIC\+\_\+\+TLS\+\_\+\+ARGS}{QUIC\+\_\+\+TLS\+\_\+\+ARGS}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md448}
A {\ttfamily QUIC\+\_\+\+TLS\+\_\+\+ARGS} object is passed to the {\ttfamily ossl\+\_\+quic\+\_\+tls\+\_\+new} function by the Open\+SSL QUIC implementation to supply a set of callbacks and other essential parameters. The {\ttfamily QUIC\+\_\+\+TLS\+\_\+\+ARGS} structure is as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structquic__tls__args__st}{quic\_tls\_args\_st}}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ The\ "{}inner"{}\ SSL\ object\ for\ the\ QUIC\ Connection.\ Contains\ an}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ SSL\_CONNECTION}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ SSL\ *s;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Called\ to\ send\ data\ on\ the\ crypto\ stream.\ We\ use\ a\ callback\ rather\ than}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ passing\ the\ crypto\ stream\ QUIC\_SSTREAM\ directly\ because\ this\ lets\ the\ CSM}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ dynamically\ select\ the\ correct\ outgoing\ crypto\ stream\ based\ on\ the}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ current\ EL.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ int\ (*crypto\_send\_cb)(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *buf,\ \textcolor{keywordtype}{size\_t}\ buf\_len,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ *consumed,\ \textcolor{keywordtype}{void}\ *arg);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *crypto\_send\_cb\_arg;}
\DoxyCodeLine{\ \ \ \ int\ (*crypto\_recv\_cb)(\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *buf,\ \textcolor{keywordtype}{size\_t}\ buf\_len,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ *bytes\_read,\ \textcolor{keywordtype}{void}\ *arg);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *crypto\_recv\_cb\_arg;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*\ Called\ when\ a\ traffic\ secret\ is\ available\ for\ a\ given\ encryption\ level.\ */}}
\DoxyCodeLine{\ \ \ \ int\ (*yield\_secret\_cb)(uint32\_t\ enc\_level,\ \textcolor{keywordtype}{int}\ direction\ \textcolor{comment}{/*\ 0=RX,\ 1=TX\ */},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint32\_t\ suite\_id,\ EVP\_MD\ *md,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *secret,\ \textcolor{keywordtype}{size\_t}\ secret\_len,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ *arg);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *yield\_secret\_cb\_arg;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Called\ when\ we\ receive\ transport\ parameters\ from\ the\ peer.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Note:\ These\ parameters\ are\ not\ authenticated\ until\ the\ handshake\ is}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ marked\ as\ completed.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ int\ (*got\_transport\_params\_cb)(\textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *params,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ params\_len,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ *arg);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *got\_transport\_params\_cb\_arg;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Called\ when\ the\ handshake\ has\ been\ completed\ as\ far\ as\ the\ handshake}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ protocol\ is\ concerned,\ meaning\ that\ the\ connection\ has\ been}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ authenticated.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ int\ (*handshake\_complete\_cb)(\textcolor{keywordtype}{void}\ *arg);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *handshake\_complete\_cb\_arg;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Called\ when\ something\ has\ gone\ wrong\ with\ the\ connection\ as\ far\ as\ the}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ handshake\ layer\ is\ concerned,\ meaning\ that\ it\ should\ be\ immediately\ torn}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ down.\ Note\ that\ this\ may\ happen\ at\ any\ time,\ including\ after\ a\ connection}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ has\ been\ fully\ established.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ int\ (*alert\_cb)(\textcolor{keywordtype}{void}\ *arg,\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ alert\_code);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ *alert\_cb\_arg;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ Transport\ parameters\ which\ client\ should\ send.\ Buffer\ lifetime\ must}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ *\ exceed\ the\ lifetime\ of\ the\ QUIC\_TLS\ object.}}
\DoxyCodeLine{\textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ *transport\_params;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{size\_t}\ transport\_params\_len;}
\DoxyCodeLine{\}\ \mbox{\hyperlink{structquic__tls__args__st}{QUIC\_TLS\_ARGS}};}

\end{DoxyCode}


The {\ttfamily crypto\+\_\+send\+\_\+cb} and {\ttfamily crypto\+\_\+recv\+\_\+cb} callbacks will be called by the QUIC-\/\+TLS handshake when there is new CRYPTO frame data to be sent, or when it wants to consume queued CRYPTO frame data from the peer.

When the TLS handshake generates secrets they will be communicated to the Open\+SSL QUIC implementation via the {\ttfamily yield\+\_\+secret\+\_\+cb}, and when the handshake has successfully completed this will be communicated via {\ttfamily handshake\+\_\+complete\+\_\+cb}.

In the event that an error occurs a normal TLS handshake would send a TLS alert record. QUIC handles this differently and so the QUIC\+\_\+\+TLS object will intercept attempts to send an alert and will communicate this via the {\ttfamily alert\+\_\+cb} callback.

QUIC requires the use of a TLS extension in order to send and receive "{}transport parameters"{}. These transport parameters are opaque to the {\ttfamily QUIC\+\_\+\+TLS} object. It does not need to use them directly but instead simply includes them in an extension to be sent in the Client\+Hello and receives them back from the peer in the Encrypted\+Extensions message. The data to be sent is provided in the {\ttfamily transport\+\_\+params} argument. When the peer\textquotesingle{}s parameters are received the {\ttfamily got\+\_\+transport\+\_\+params\+\_\+cb} callback is invoked.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md449}{}\doxysection{\texorpdfstring{QUIC\+\_\+\+TLS Implementation}{QUIC\+\_\+\+TLS Implementation}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md449}
The {\ttfamily QUIC\+\_\+\+TLS} object utilises two main mechanisms for fulfilling its functions\+:


\begin{DoxyItemize}
\item It registers itself as a custom TLS record layer
\item It supplies callbacks to register a custom TLS extension
\end{DoxyItemize}\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md450}{}\doxysubsection{\texorpdfstring{Custom TLS Record Layer}{Custom TLS Record Layer}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md450}
A TLS record layer is defined via an {\ttfamily OSSL\+\_\+\+RECORD\+\_\+\+METHOD} object. This object consists of a set of function pointers which need to be implemented by any record layer. Existing record layers include one for TLS, one for DTLS and one for KTLS.

{\ttfamily QUIC\+\_\+\+TLS} registers itself as a custom TLS record layer. A new internal function is used to provide the custom record method data and associate it with an {\ttfamily SSL\+\_\+\+CONNECTION}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ ossl\_ssl\_set\_custom\_record\_layer(\mbox{\hyperlink{structssl__connection__st}{SSL\_CONNECTION}}\ *s,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{structossl__record__method__st}{OSSL\_RECORD\_METHOD}}\ *meth,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}\ *rlarg);}

\end{DoxyCode}


The internal function {\ttfamily ssl\+\_\+select\+\_\+next\+\_\+record\+\_\+layer} which is used in the TLS implementation to work out which record method should be used next is modified to first check whether a custom record method has been specified and always use that one if so.

The TLS record layer code is further modified to provide the following capabilities which are needed in order to support QUIC.

The custom record layer will need a record layer specific argument ({\ttfamily rlarg} above). This is passed as part of a modified {\ttfamily new\+\_\+record\+\_\+layer} call.

Existing TLS record layers use TLS keys and IVs that are calculated using a KDF from a higher level secret. Instead of this QUIC needs direct access to the higher level secret as well as the digest to be used in the KDF -\/ so these values are now also passed through as part of the {\ttfamily new\+\_\+record\+\_\+layer} call.

The most important function pointers in the {\ttfamily OSSL\+\_\+\+RECORD\+\_\+\+METHOD} for the {\ttfamily QUIC\+\_\+\+TLS} object are\+:


\begin{DoxyItemize}
\item {\ttfamily new\+\_\+record\+\_\+layer}
\end{DoxyItemize}

Invoked every time a new record layer object is created by the TLS implementation. This occurs every time new keys are provisioned (once for the "{}read"{} side and once for the "{}write"{} side). This function is responsible for invoking the {\ttfamily yield\+\_\+secret\+\_\+cb} callback.


\begin{DoxyItemize}
\item {\ttfamily write\+\_\+records}
\end{DoxyItemize}

Invoked every time the TLS implementation wants to send TLS handshake data. This is responsible for calling the {\ttfamily crypto\+\_\+send\+\_\+cb} callback. It also includes special processing in the event that the TLS implementation wants to send an alert. This manifests itself as a call to {\ttfamily write\+\_\+records} indicating a type of {\ttfamily SSL3\+\_\+\+RT\+\_\+\+ALERT}. The {\ttfamily QUIC\+\_\+\+TLS} implementation of {\ttfamily write\+\_\+records} must parse the alert data supplied by the TLS implementation (always a 2 byte record payload) and pull out the alert description (a one byte integer) and invoke the {\ttfamily alert\+\_\+cb} callback. Note that while the TLS RFC strictly allows the 2 byte alert record to be fragmented across two 1 byte records this is never done in practice by Open\+SSL\textquotesingle{}s TLS stack and the {\ttfamily write\+\_\+records} implementation can make the optimising assumption that both bytes of an alert are always sent together.


\begin{DoxyItemize}
\item {\ttfamily quic\+\_\+read\+\_\+record}
\end{DoxyItemize}

Invoked when the TLS implementation wants to read more handshake data. This results in a call to {\ttfamily crypto\+\_\+recv\+\_\+cb}.

This design does introduce an extra "{}copy"{} in the process when {\ttfamily crypto\+\_\+recv\+\_\+cb} is invoked. CRYPTO frame data will be queued within internal QUIC "{}\+Stream \+Receive Buffers"{} when it is received by the peer. However the TLS implementation expects to request data from the record layer, get a handle on that data, and then inform the record layer when it has finished using that data. The current design of the Stream Receive Buffers does not allow for this model. Therefore when {\ttfamily crypto\+\_\+recv\+\_\+cb} is invoked the data is copied into a QUIC\+\_\+\+TLS object managed buffer. This is inefficient, so it is expected that a later phase of development will resolve this problem.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md451}{}\doxysubsection{\texorpdfstring{Custom TLS extension}{Custom TLS extension}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md451}
Libssl already has the ability for an application to supply a custom extension via the {\ttfamily SSL\+\_\+\+CTX\+\_\+add\+\_\+custom\+\_\+ext()} API. There is no equivalent {\ttfamily SSL\+\_\+add\+\_\+custom\+\_\+ext()} and therefore an internal API is used to do this. This mechanism is used for supporting QUIC transport parameters. An extension type {\ttfamily TLSEXT\+\_\+\+TYPE\+\_\+quic\+\_\+transport\+\_\+parameters} with value 57 is used for this purpose.

The custom extension API enables the caller to supply {\ttfamily add}, {\ttfamily free} and {\ttfamily parse} callbacks. The {\ttfamily add} callback simply adds the {\ttfamily transport\+\_\+params} data from {\ttfamily QUIC\+\_\+\+TLS\+\_\+\+ARGS}. The {\ttfamily parse} callback invokes the {\ttfamily got\+\_\+transport\+\_\+params\+\_\+cb} callback when the transport parameters have been received from the peer.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md452}{}\doxysubsection{\texorpdfstring{ALPN}{ALPN}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md452}
QUIC requires the use of ALPN (Application-\/\+Layer Protocol Negotiation). This is normally optional in Open\+SSL but is mandatory for QUIC connections. Therefore a QUIC client must call one of {\ttfamily SSL\+\_\+\+CTX\+\_\+set\+\_\+alpn\+\_\+protos} or {\ttfamily SSL\+\_\+set\+\_\+alpn\+\_\+protos} prior to initiating the handshake. If the ALPN data has not been set then the {\ttfamily QUIC\+\_\+\+TLS} object immediately fails.\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md453}{}\doxysubsection{\texorpdfstring{Other Implementation Details}{Other Implementation Details}}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-tls_autotoc_md453}
The {\ttfamily SSL\+\_\+\+CONNECTION} used for the TLS handshake is held alongside the QUIC related data in the {\ttfamily SSL} object. Public API functions that are only relevant to TLS will modify this internal {\ttfamily SSL\+\_\+\+CONNECTION} as appropriate. This enables the end application to configure the TLS connection parameters as it sees fit (e.\+g. setting ciphersuites, providing client certificates, etc). However there are certain settings that may be optional in a normal TLS connection but are mandatory for QUIC. Where possible these settings will be automatically configured just before the handshake starts.

One of these settings is the minimum TLS protocol version. QUIC requires that TLSv1.\+3 is used as a minimum. Therefore the {\ttfamily QUIC\+\_\+\+TLS} object automatically calls {\ttfamily SSL\+\_\+set\+\_\+min\+\_\+proto\+\_\+version()} and specifies {\ttfamily TLS1\+\_\+3\+\_\+\+VERSION} as the minimum version.

Secondly, QUIC enforces that the TLS "{}middlebox"{} mode must not be used. For normal TLS this is "{}on"{} by default. Therefore the {\ttfamily QUIC\+\_\+\+TLS} object will automatically clear the {\ttfamily SSL\+\_\+\+OP\+\_\+\+ENABLE\+\_\+\+MIDDLEBOX\+\_\+\+COMPAT} option if it is set. 