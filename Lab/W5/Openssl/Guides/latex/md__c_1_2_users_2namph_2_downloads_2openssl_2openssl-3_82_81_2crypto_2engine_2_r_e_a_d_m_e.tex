\chapter{Notes on engines of 2001-\/09-\/24}
\hypertarget{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2crypto_2engine_2_r_e_a_d_m_e}{}\label{md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2crypto_2engine_2_r_e_a_d_m_e}\index{Notes on engines of 2001-\/09-\/24@{Notes on engines of 2001-\/09-\/24}}
This "{}description"{} (if one chooses to call it that) needed some major updating so here goes. This update addresses a change being made at the same time to Open\+SSL, and it pretty much completely restructures the underlying mechanics of the "{}\+ENGINE"{} code. So it serves a double purpose of being a "{}\+ENGINE internals for masochists"{} document {\itshape and} a rather extensive commit log message. (I\textquotesingle{}d get lynched for sticking all this in CHANGES.\+md or the commit mails \+:-\/).

ENGINE\+\_\+\+TABLE underlies this restructuring, as described in the internal header "{}eng\+\_\+local.\+h"{}, implemented in eng\+\_\+table.\+c, and used in each of the "{}class"{} files; tb\+\_\+rsa.\+c, tb\+\_\+dsa.\+c, etc.

However, "{}\+EVP\+\_\+\+CIPHER"{} underlies the motivation and design of ENGINE\+\_\+\+TABLE so I\textquotesingle{}ll mention a bit about that first. EVP\+\_\+\+CIPHER (and most of this applies equally to EVP\+\_\+\+MD for digests) is both a "{}method"{} and a algorithm/mode identifier that, in the current API, "{}lingers"{}. These cipher description + implementation structures can be defined or obtained directly by applications, or can be loaded "{}en masse"{} into EVP storage so that they can be catalogued and searched in various ways, ie. two ways of encrypting with the "{}des\+\_\+cbc"{} algorithm/mode pair are; \begin{DoxyVerb}(i) directly;
     const EVP_CIPHER *cipher = EVP_des_cbc();
     EVP_EncryptInit(&ctx, cipher, key, iv);
     [ ... use EVP_EncryptUpdate() and EVP_EncryptFinal() ...]

(ii) indirectly;
     OpenSSL_add_all_ciphers();
     cipher = EVP_get_cipherbyname("des_cbc");
     EVP_EncryptInit(&ctx, cipher, key, iv);
     [ ... etc ... ]
\end{DoxyVerb}
 The latter is more generally used because it also allows ciphers/digests to be looked up based on other identifiers which can be useful for automatic cipher selection, eg. in SSL/\+TLS, or by user-\/controllable configuration.

The important point about this is that EVP\+\_\+\+CIPHER definitions and structures are passed around with impunity and there is no safe way, without requiring massive rewrites of many applications, to assume that EVP\+\_\+\+CIPHERs can be reference counted. One an EVP\+\_\+\+CIPHER is exposed to the caller, neither it nor anything it comes from can "{}safely"{} be destroyed. Unless of course the way of getting to such ciphers is via entirely distinct API calls that didn\textquotesingle{}t exist before. However existing API usage cannot be made to understand when an EVP\+\_\+\+CIPHER pointer, that has been passed to the caller, is no longer being used.

The other problem with the existing API w.\+r.\+t. to hooking EVP\+\_\+\+CIPHER support into ENGINE is storage -\/ the OBJ\+\_\+\+NAME-\/based storage used by EVP to register ciphers simultaneously registers cipher {\itshape types} and cipher {\itshape implementations} -\/ they are effectively the same thing, an "{}\+EVP\+\_\+\+CIPHER"{} pointer. The problem with hooking in ENGINEs is that multiple ENGINEs may implement the same ciphers. The solution is necessarily that ENGINE-\/provided ciphers simply are not registered, stored, or exposed to the caller in the same manner as existing ciphers. This is especially necessary considering the fact ENGINE uses reference counts to allow for cleanup, modularity, and DSO support -\/ yet EVP\+\_\+\+CIPHERs, as exposed to callers in the current API, support no such controls.

Another sticking point for integrating cipher support into ENGINE is linkage. Already there is a problem with the way ENGINE supports RSA, DSA, etc whereby they are available {\itshape because} they\textquotesingle{}re part of a giant ENGINE called "{}openssl"{}. Ie. all implementations {\itshape have} to come from an ENGINE, but we get round that by having a giant ENGINE with all the software support encapsulated. This creates linker hassles if nothing else -\/ linking a 1-\/line application that calls 2 basic RSA functions (eg. "{}\+RSA\+\_\+free(\+RSA\+\_\+new());"{}) will result in large quantities of ENGINE code being linked in {\itshape and} because of that DSA, DH, and RAND also. If we continue with this approach for EVP\+\_\+\+CIPHER support (even if it {\itshape was} possible) we would lose our ability to link selectively by selectively loading certain implementations of certain functionality. Touching any part of any kind of crypto would result in massive static linkage of everything else. So the solution is to change the way ENGINE feeds existing "{}classes"{}, ie. how the hooking to ENGINE works from RSA, DSA, DH, RAND, as well as adding new hooking for EVP\+\_\+\+CIPHER, and EVP\+\_\+\+MD.

The way this is now being done is by mostly reverting back to how things used to work prior to ENGINE \+:-\/). Ie. RSA now has a "{}\+RSA\+\_\+\+METHOD"{} pointer again -\/ this was previously replaced by an "{}\+ENGINE"{} pointer and all RSA code that required the RSA\+\_\+\+METHOD would call ENGINE\+\_\+get\+\_\+\+RSA() each time on its ENGINE handle to temporarily get and use the ENGINE\textquotesingle{}s RSA implementation. Apart from being more efficient, switching back to each RSA having an RSA\+\_\+\+METHOD pointer also allows us to conceivably operate with {\itshape no} ENGINE. As we\textquotesingle{}ll see, this removes any need for a fallback ENGINE that encapsulates default implementations -\/ we can simply have our RSA structure pointing its RSA\+\_\+\+METHOD pointer to the software implementation and have its ENGINE pointer set to NULL.

A look at the EVP\+\_\+\+CIPHER hooking is most explanatory, the RSA, DSA (etc) cases turn out to be degenerate forms of the same thing. The EVP storage of ciphers, and the existing EVP API functions that return "{}software"{} implementations and descriptions remain untouched. However, the storage takes more meaning in terms of "{}cipher description"{} and less meaning in terms of "{}implementation"{}. When an EVP\+\_\+\+CIPHER\+\_\+\+CTX is actually initialised with an EVP\+\_\+\+CIPHER method and is about to begin en/decryption, the hooking to ENGINE comes into play. What happens is that cipher-\/specific ENGINE code is asked for an ENGINE pointer (a functional reference) for any ENGINE that is registered to perform the algo/mode that the provided EVP\+\_\+\+CIPHER structure represents. Under normal circumstances, that ENGINE code will return NULL because no ENGINEs will have had any cipher implementations {\itshape registered}. As such, a NULL ENGINE pointer is stored in the EVP\+\_\+\+CIPHER\+\_\+\+CTX context, and the EVP\+\_\+\+CIPHER structure is left hooked into the context and so is used as the implementation. Pretty much how things work now except we\textquotesingle{}d have a redundant ENGINE pointer set to NULL and doing nothing.

Conversely, if an ENGINE {\itshape has} been registered to perform the algorithm/mode combination represented by the provided EVP\+\_\+\+CIPHER, then a functional reference to that ENGINE will be returned to the EVP\+\_\+\+CIPHER\+\_\+\+CTX during initialisation. That functional reference will be stored in the context (and released on cleanup) -\/ and having that reference provides a {\itshape safe} way to use an EVP\+\_\+\+CIPHER definition that is private to the ENGINE. Ie. the EVP\+\_\+\+CIPHER provided by the application will actually be replaced by an EVP\+\_\+\+CIPHER from the registered ENGINE -\/ it will support the same algorithm/mode as the original but will be a completely different implementation. Because this EVP\+\_\+\+CIPHER isn\textquotesingle{}t stored in the EVP storage, nor is it returned to applications from traditional API functions, there is no associated problem with it not having reference counts. And of course, when one of these "{}private"{} cipher implementations is hooked into EVP\+\_\+\+CIPHER\+\_\+\+CTX, it is done whilst the EVP\+\_\+\+CIPHER\+\_\+\+CTX holds a functional reference to the ENGINE that owns it, thus the use of the ENGINE\textquotesingle{}s EVP\+\_\+\+CIPHER is safe.

The "{}cipher-\/specific ENGINE code"{} I mentioned is implemented in tb\+\_\+cipher.\+c but in essence it is simply an instantiation of "{}\+ENGINE\+\_\+\+TABLE"{} code for use by EVP\+\_\+\+CIPHER code. tb\+\_\+digest.\+c is virtually identical but, of course, it is for use by EVP\+\_\+\+MD code. Ditto for tb\+\_\+rsa.\+c, tb\+\_\+dsa.\+c, etc. These instantiations of ENGINE\+\_\+\+TABLE essentially provide linker-\/separation of the classes so that even if ENGINEs implement {\itshape all} possible algorithms, an application using only EVP\+\_\+\+CIPHER code will link at most code relating to EVP\+\_\+\+CIPHER, tb\+\_\+cipher.\+c, core ENGINE code that is independent of class, and of course the ENGINE implementation that the application loaded. It will {\itshape not} however link any class-\/specific ENGINE code for digests, RSA, etc nor will it bleed over into other APIs, such as the RSA/\+DSA/etc library code.

ENGINE\+\_\+\+TABLE is a little more complicated than may seem necessary but this is mostly to avoid a lot of "{}init()"{}-\/thrashing on ENGINEs (that may have to load DSOs, and other expensive setup that shouldn\textquotesingle{}t be thrashed unnecessarily) {\itshape and} to duplicate "{}default"{} behaviour. Basically an ENGINE\+\_\+\+TABLE instantiation, for example tb\+\_\+cipher.\+c, implements a hash-\/table keyed by integer "{}nid"{} values. These nids provide the uniquenness of an algorithm/mode -\/ and each nid will hash to a potentially NULL "{}\+ENGINE\+\_\+\+PILE"{}. An ENGINE\+\_\+\+PILE is essentially a list of pointers to ENGINEs that implement that particular \textquotesingle{}nid\textquotesingle{}. Each "{}pile"{} uses some caching tricks such that requests on that \textquotesingle{}nid\textquotesingle{} will be cached and all future requests will return immediately (well, at least with minimal operation) unless a change is made to the pile, eg. perhaps an ENGINE was unloaded. The reason is that an application could have support for 10 ENGINEs statically linked in, and the machine in question may not have any of the hardware those 10 ENGINEs support. If each of those ENGINEs has a "{}des\+\_\+cbc"{} implementation, we want to avoid every EVP\+\_\+\+CIPHER\+\_\+\+CTX setup from trying (and failing) to initialise each of those 10 ENGINEs. Instead, the first such request will try to do that and will either return (and cache) a NULL ENGINE pointer or will return a functional reference to the first that successfully initialised. In the latter case it will also cache an extra functional reference to the ENGINE as a "{}default"{} for that \textquotesingle{}nid\textquotesingle{}. The caching is acknowledged by a \textquotesingle{}uptodate\textquotesingle{} variable that is unset only if un/registration takes place on that pile. Ie. if implementations of "{}des\+\_\+cbc"{} are added or removed. This behaviour can be tweaked; the ENGINE\+\_\+\+TABLE\+\_\+\+FLAG\+\_\+\+NOINIT value can be passed to ENGINE\+\_\+set\+\_\+table\+\_\+flags(), in which case the only ENGINEs that tb\+\_\+cipher.\+c will try to initialise from the "{}pile"{} will be those that are already initialised (ie. it\textquotesingle{}s simply an increment of the functional reference count, and no real "{}initialisation"{} will take place).

RSA, DSA, DH, and RAND all have their own ENGINE\+\_\+\+TABLE code as well, and the difference is that they all use an implicit \textquotesingle{}nid\textquotesingle{} of 1. Whereas EVP\+\_\+\+CIPHERs are actually qualitatively different depending on \textquotesingle{}nid\textquotesingle{} (the "{}des\+\_\+cbc"{} EVP\+\_\+\+CIPHER is not an interoperable implementation of "{}aes\+\_\+256\+\_\+cbc"{}), RSA\+\_\+\+METHODs are necessarily interoperable and don\textquotesingle{}t have different flavours, only different implementations. In other words, the ENGINE\+\_\+\+TABLE for RSA will either be empty, or will have a single ENGINE\+\_\+\+PILE hashed to by the \textquotesingle{}nid\textquotesingle{} 1 and that pile represents ENGINEs that implement the single "{}type"{} of RSA there is.

Cleanup -\/ the registration and unregistration may pose questions about how cleanup works with the ENGINE\+\_\+\+PILE doing all this caching nonsense (ie. when the application or EVP\+\_\+\+CIPHER code releases its last reference to an ENGINE, the ENGINE\+\_\+\+PILE code may still have references and thus those ENGINEs will stay hooked in forever). The way this is handled is via "{}unregistration"{}. With these new ENGINE changes, an abstract ENGINE can be loaded and initialised, but that is an algorithm-\/agnostic process. Even if initialised, it will not have registered any of its implementations (to do so would link all class "{}table"{} code despite the fact the application may use only ciphers, for example). This is deliberately a distinct step. Moreover, registration and unregistration has nothing to do with whether an ENGINE is {\itshape functional} or not (ie. you can even register an ENGINE and its implementations without it being operational, you may not even have the drivers to make it operate). What actually happens with respect to cleanup is managed inside eng\+\_\+lib.\+c with the {\ttfamily engine\+\_\+cleanup\+\_\+\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}} functions. These functions are internal-\/only and each part of ENGINE code that could require cleanup will, upon performing its first allocation, register a callback with the "{}engine\+\_\+cleanup"{} code. The other part of this that makes it tick is that the ENGINE\+\_\+\+TABLE instantiations (tb\+\_\+\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}.c) use NULL as their initialised state. So if RSA code asks for an ENGINE and no ENGINE has registered an implementation, the code will simply return NULL and the tb\+\_\+rsa.\+c state will be unchanged. Thus, no cleanup is required unless registration takes place. ENGINE\+\_\+cleanup() will simply iterate across a list of registered cleanup callbacks calling each in turn, and will then internally delete its own storage (a STACK). When a cleanup callback is next registered (eg. if the cleanup() is part of a graceful restart and the application wants to cleanup all state then start again), the internal STACK storage will be freshly allocated. This is much the same as the situation in the ENGINE\+\_\+\+TABLE instantiations ... NULL is the initialised state, so only modification operations (not queries) will cause that code to have to register a cleanup.

What else? The bignum callbacks and associated ENGINE functions have been removed for two obvious reasons; (i) there was no way to generalise them to the mechanism now used by RSA/\+DSA/..., because there\textquotesingle{}s no such thing as a BIGNUM method, and (ii) because of (i), there was no meaningful way for library or application code to automatically hook and use ENGINE supplied bignum functions anyway. Also, ENGINE\+\_\+cpy() has been removed (although an internal-\/only version exists) -\/ the idea of providing an ENGINE\+\_\+cpy() function probably wasn\textquotesingle{}t a good one and now certainly doesn\textquotesingle{}t make sense in any generalised way. Some of the RSA, DSA, DH, and RAND functions that were fiddled during the original ENGINE changes have now, as a consequence, been reverted back. This is because the hooking of ENGINE is now automatic (and passive, it can internally use a NULL ENGINE pointer to simply ignore ENGINE from then on).

Hell, that should be enough for now ... comments welcome. 