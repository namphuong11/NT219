<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: TX Packetiser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TX Packetiser</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This module creates frames from the application data obtained from the application. It also receives CRYPTO frames from the TLS Handshake Record Layer and ACK frames from the ACK Handling And Loss Detector subsystem.</p>
<p>The packetiser also deals with the flow and congestion controllers.</p>
<h1><a class="anchor" id="autotoc_md481"></a>
Creation &amp; Destruction</h1>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>quic_tx_packetiser_args_st {</div>
<div class="line">    <span class="comment">/* Configuration Settings */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__conn__id__st.html">QUIC_CONN_ID</a>    cur_scid;   <span class="comment">/* Current Source Connection ID we use. */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__conn__id__st.html">QUIC_CONN_ID</a>    cur_dcid;   <span class="comment">/* Current Destination Connection ID we use. */</span></div>
<div class="line">    BIO_ADDR        peer;       <span class="comment">/* Current destination L4 address we use. */</span></div>
<div class="line">    <span class="comment">/* ACK delay exponent used when encoding. */</span></div>
<div class="line">    uint32_t        ack_delay_exponent;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Injected Dependencies */</span></div>
<div class="line">    <a class="code hl_struct" href="structossl__qtx__st.html">OSSL_QTX</a>        *qtx;       <span class="comment">/* QUIC Record Layer TX we are using */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a>      *txpim;     <span class="comment">/* QUIC TX&#39;d Packet Information Manager */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a>        *cfq;       <span class="comment">/* QUIC Control Frame Queue */</span></div>
<div class="line">    <a class="code hl_struct" href="structossl__ackm__st.html">OSSL_ACKM</a>       *ackm;      <span class="comment">/* QUIC Acknowledgement Manager */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__stream__map__st.html">QUIC_STREAM_MAP</a> *qsm;       <span class="comment">/* QUIC Streams Map */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__txfc__st.html">QUIC_TXFC</a>       *conn_txfc; <span class="comment">/* QUIC Connection-Level TX Flow Controller */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__rxfc__st.html">QUIC_RXFC</a>       *conn_rxfc; <span class="comment">/* QUIC Connection-Level RX Flow Controller */</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structossl__cc__method__st.html">OSSL_CC_METHOD</a> *cc_method; <span class="comment">/* QUIC Congestion Controller */</span></div>
<div class="line">    OSSL_CC_DATA    *cc_data;   <span class="comment">/* QUIC Congestion Controller Instance */</span></div>
<div class="line">    <a class="code hl_struct" href="struct_o_s_s_l___t_i_m_e.html">OSSL_TIME</a>       (*now)(<span class="keywordtype">void</span> *arg);  <span class="comment">/* Callback to get current time. */</span></div>
<div class="line">    <span class="keywordtype">void</span>            *now_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Injected dependencies - crypto streams.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Note: There is no crypto stream for the 0-RTT EL.</span></div>
<div class="line"><span class="comment">     *       crypto[QUIC_PN_SPACE_APP] is the 1-RTT crypto stream.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__sstream__st.html">QUIC_SSTREAM</a>    *crypto[QUIC_PN_SPACE_NUM];</div>
<div class="line">} QUIC_TX_PACKETISER_ARGS;</div>
<div class="line"> </div>
<div class="line">_owur <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structossl__quic__tx__packetiser__st.html">ossl_quic_tx_packetiser_st</a> <a class="code hl_struct" href="structossl__quic__tx__packetiser__st.html">OSSL_QUIC_TX_PACKETISER</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structossl__quic__tx__packetiser__st.html">OSSL_QUIC_TX_PACKETISER</a> *ossl_quic_tx_packetiser_new(QUIC_TX_PACKETISER_ARGS *args);</div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_tx_packetiser_free(<a class="code hl_struct" href="structossl__quic__tx__packetiser__st.html">OSSL_QUIC_TX_PACKETISER</a> *tx);</div>
<div class="ttc" id="astruct_o_s_s_l___t_i_m_e_html"><div class="ttname"><a href="struct_o_s_s_l___t_i_m_e.html">OSSL_TIME</a></div><div class="ttdef"><b>Definition</b> time.h:25</div></div>
<div class="ttc" id="astructossl__ackm__st_html"><div class="ttname"><a href="structossl__ackm__st.html">ossl_ackm_st</a></div><div class="ttdef"><b>Definition</b> quic_ackm.c:494</div></div>
<div class="ttc" id="astructossl__cc__method__st_html"><div class="ttname"><a href="structossl__cc__method__st.html">ossl_cc_method_st</a></div><div class="ttdef"><b>Definition</b> quic_cc.h:83</div></div>
<div class="ttc" id="astructossl__qtx__st_html"><div class="ttname"><a href="structossl__qtx__st.html">ossl_qtx_st</a></div><div class="ttdef"><b>Definition</b> quic_record_tx.c:53</div></div>
<div class="ttc" id="astructossl__quic__tx__packetiser__st_html"><div class="ttname"><a href="structossl__quic__tx__packetiser__st.html">ossl_quic_tx_packetiser_st</a></div><div class="ttdef"><b>Definition</b> quic_txp.c:51</div></div>
<div class="ttc" id="astructquic__cfq__st_html"><div class="ttname"><a href="structquic__cfq__st.html">quic_cfq_st</a></div><div class="ttdef"><b>Definition</b> quic_cfq.c:73</div></div>
<div class="ttc" id="astructquic__conn__id__st_html"><div class="ttname"><a href="structquic__conn__id__st.html">quic_conn_id_st</a></div><div class="ttdef"><b>Definition</b> quic_types.h:77</div></div>
<div class="ttc" id="astructquic__rxfc__st_html"><div class="ttname"><a href="structquic__rxfc__st.html">quic_rxfc_st</a></div><div class="ttdef"><b>Definition</b> quic_fc.h:128</div></div>
<div class="ttc" id="astructquic__sstream__st_html"><div class="ttname"><a href="structquic__sstream__st.html">quic_sstream_st</a></div><div class="ttdef"><b>Definition</b> quic_sstream.c:19</div></div>
<div class="ttc" id="astructquic__stream__map__st_html"><div class="ttname"><a href="structquic__stream__map__st.html">quic_stream_map_st</a></div><div class="ttdef"><b>Definition</b> quic_stream_map.h:517</div></div>
<div class="ttc" id="astructquic__txfc__st_html"><div class="ttname"><a href="structquic__txfc__st.html">quic_txfc_st</a></div><div class="ttdef"><b>Definition</b> quic_fc.h:26</div></div>
<div class="ttc" id="astructquic__txpim__st_html"><div class="ttname"><a href="structquic__txpim__st.html">quic_txpim_st</a></div><div class="ttdef"><b>Definition</b> quic_txpim.c:27</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md482"></a>
Structures</h1>
<h2><a class="anchor" id="autotoc_md483"></a>
Connection</h2>
<p>Represented by an QUIC_CONNECTION object.</p>
<h2><a class="anchor" id="autotoc_md484"></a>
Stream</h2>
<p>Represented by an QUIC_STREAM object.</p>
<p>As per <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-2.3">RFC 9000 2.3 Stream Prioritization</a>, streams should contain a priority provided by the calling application. For MVP, this is not required to be implemented because only one stream is supported. However, packets being retransmitted should be preferentially sent as noted in <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-13.3">RFC 9000 13.3 Retransmission of Information</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SSL_set_priority(SSL *stream, uint32_t priority);</div>
<div class="line">uint32_t SSL_get_priority(SSL *stream);</div>
</div><!-- fragment --><p>For protocols where priority is not meaningful, the set function is a noop and the get function returns a constant value.</p>
<h1><a class="anchor" id="autotoc_md485"></a>
Interactions</h1>
<p>The packetiser interacts with the following components, the APIs for which can be found in their respective design documents and header files:</p>
<ul>
<li>SSTREAM: manages application stream data for transmission.</li>
<li>QUIC_STREAM_MAP: Maps stream IDs to QUIC_STREAM objects and tracks which streams are active (i.e., need servicing by the TX packetiser).</li>
<li>Crypto streams for each EL other than 0-RTT (each is one SSTREAM).</li>
<li>CFQ: queried for generic control frames</li>
<li>QTX: record layer which completed packets are written to.</li>
<li>TXPIM: logs information about transmitted packets, provides information to FIFD.</li>
<li>FIFD: notified of transmitted packets.</li>
<li>ACKM: loss detector.</li>
<li>Connection and stream-level TXFC and RXFC instances.</li>
<li>Congestion controller (not needed for MVP).</li>
</ul>
<h2><a class="anchor" id="autotoc_md486"></a>
SSTREAM</h2>
<p>Each application or crypto stream has a SSTREAM object for the sending part. This manages the buffering of data written to the stream, frees that data when the packet it was sent in was acknowledged, and can return the data for retransmission on loss. It receives loss and acknowledgement notifications from the FIFD without direct TX packetiser involvement.</p>
<h2><a class="anchor" id="autotoc_md487"></a>
QUIC Stream Map</h2>
<p>The TX packetiser queries the QUIC stream map for a list of active streams (QUIC_STREAM), which are iterated on a rotating round robin basis. Each QUIC_STREAM provides access to the various components, such as a QUIC_SSTREAM instance (for streams with a send part). Streams are marked inactive when they no longer have any need to generate frames at the present time.</p>
<h2><a class="anchor" id="autotoc_md488"></a>
Crypto Streams</h2>
<p>The crypto streams for each EL (other than 0-RTT, which does not have a crypto stream) are represented by SSTREAM instances. The TX packetiser queries SSTREAM instances provided to it as needed when generating packets.</p>
<h2><a class="anchor" id="autotoc_md489"></a>
CFQ</h2>
<p>Many control frames do not require special handling and are handled by the generic CFQ mechanism. The TX packetiser queries the CFQ for any frames to be sent and schedules them into a packet.</p>
<h2><a class="anchor" id="autotoc_md490"></a>
QUIC Write Record Layer</h2>
<p>Coalesced frames are passed to the QUIC record layer for encryption and sending. To send accumulated frames as packets to the QUIC Write Record Layer:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ossl_qtx_write_pkt(<a class="code hl_struct" href="structossl__qtx__st.html">OSSL_QTX</a> *qtx, <span class="keyword">const</span> <a class="code hl_struct" href="structossl__qtx__pkt__st.html">OSSL_QTX_PKT</a> *pkt);</div>
<div class="ttc" id="astructossl__qtx__pkt__st_html"><div class="ttname"><a href="structossl__qtx__pkt__st.html">ossl_qtx_pkt_st</a></div><div class="ttdef"><b>Definition</b> quic_record_tx.h:151</div></div>
</div><!-- fragment --><p>The packetiser will attempt to maximise the number of bytes in a packet. It will also attempt to create multiple packets to send simultaneously.</p>
<p>The packetiser should also implement a wait time to allow more data to accumulate before exhausting it's supply of data. The length of the wait will depend on how much data is queued already and how much space remains in the packet being filled. Once the wait is finished, the packets will be sent by calling:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ossl_qtx_flush_net(<a class="code hl_struct" href="structossl__qtx__st.html">OSSL_QTX</a> *qtx);</div>
</div><!-- fragment --><p>The write record layer is responsible for coalescing multiple QUIC packets into datagrams.</p>
<h2><a class="anchor" id="autotoc_md491"></a>
TXPIM, FIFD, ACK Handling and Loss Detector</h2>
<p>ACK handling and loss detection is provided by the ACKM and FIFD. The FIFD uses the per-packet information recorded by the TXPIM to track which frames are contained within a packet which was lost or acknowledged, and generates callbacks to the TX packetiser, SSTREAM instances and CFQ to allow it to regenerate those frames as needed.</p>
<ol type="1">
<li>When a packet is sent, the packetiser informs the FIFD, which also informs the ACK Manager.</li>
<li>When a packet is ACKed, the FIFD notifies applicable SSTREAMs and the CFQ as appropriate.</li>
<li>When a packet is lost, the FIFD notifies the TX packetiser of any frames which were in the lost packet for which the Regenerate strategy is applicable.</li>
<li>Currently, no notifications to the TX packetiser are needed when packets are discarded (e.g. due to an EL being discarded).</li>
</ol>
<h2><a class="anchor" id="autotoc_md492"></a>
Flow Control</h2>
<p>The packetiser interacts with connection and stream-level TXFC and RXFC instances. It interacts with RXFC instances to know when to generate flow control frames, and with TXFC instances to know how much stream data it is allowed to send in a packet.</p>
<h2><a class="anchor" id="autotoc_md493"></a>
Congestion Control</h2>
<p>The packetiser is likely to interact with the congestion controller in the future. Currently, congestion control is a no-op.</p>
<h1><a class="anchor" id="autotoc_md494"></a>
Packets</h1>
<p>Packet formats are defined in <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-17">RFC 9000 17.1 Packet Formats</a>.</p>
<h2><a class="anchor" id="autotoc_md495"></a>
Packet types</h2>
<p>QUIC supports a number of different packets. The combination of packets of different encryption levels as per <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-12.2">RFC 9000 12.2 Coalescing Packets</a>, is done by the record layer. Non-encrypted packets are not handled by the TX Packetiser and callers may send them by direct calls to the record layer.</p>
<h3><a class="anchor" id="autotoc_md496"></a>
Initial Packet</h3>
<p>Refer to <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-17.2.2">RFC 9000 17.2.2 Initial Packet</a>.</p>
<h3><a class="anchor" id="autotoc_md497"></a>
Handshake Packet</h3>
<p>Refer to <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-17.2.4">RFC 9000 17.2.4 Handshake Packet</a>.</p>
<h3><a class="anchor" id="autotoc_md498"></a>
App Data 0-RTT Packet</h3>
<p>Refer to <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-17.2.3">RFC 9000 17.2.3 0-RTT</a>.</p>
<h3><a class="anchor" id="autotoc_md499"></a>
App Data 1-RTT Packet</h3>
<p>Refer to <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-17.3.1">RFC 9000 17.3.1 1-RTT</a>.</p>
<h1><a class="anchor" id="autotoc_md500"></a>
Packetisation and Processing</h1>
<h2><a class="anchor" id="autotoc_md501"></a>
Definitions</h2>
<ul>
<li>Maximum Datagram Payload Length (MDPL): The maximum number of UDP payload bytes we can put in a UDP packet. This is derived from the applicable PMTU. This is also the maximum size of a single QUIC packet if we place only one packet in a datagram. The MDPL may vary based on both local source IP and destination IP due to different path MTUs.</li>
<li>Maximum Packet Length (MPL): The maximum size of a fully encrypted and serialized QUIC packet in bytes in some given context. Typically equal to the MDPL and never greater than it.</li>
<li>Maximum Plaintext Payload Length (MPPL): The maximum number of plaintext bytes we can put in the payload of a QUIC packet. This is related to the MDPL by the size of the encoded header and the size of any AEAD authentication tag which will be attached to the ciphertext.</li>
<li>Coalescing MPL (CMPL): The maximum number of bytes left to serialize another QUIC packet into the same datagram as one or more previous packets. This is just the MDPL minus the total size of all previous packets already serialized into to the same datagram.</li>
<li>Coalescing MPPL (CMPPL): The maximum number of payload bytes we can put in the payload of another QUIC packet which is to be coalesced with one or more previous QUIC packets and placed into the same datagram. Essentially, this is the room we have left for another packet payload.</li>
<li>Remaining CMPPL (RCMPPL): The number of bytes left in a packet whose payload we are currently forming. This is the CMPPL minus any bytes we have already put into the payload.</li>
<li>Minimum Datagram Length (MinDPL): In some cases we must ensure a datagram has a minimum size of a certain number of bytes. This does not need to be accomplished with a single packet, but we may need to add PADDING frames to the final packet added to a datagram in this case.</li>
<li>Minimum Packet Length (MinPL): The minimum serialized packet length we are using while serializing a given packet. May often be 0. Used to meet MinDPL requirements, and thus equal to MinDPL minus the length of any packets we have already encoded into the datagram.</li>
<li>Minimum Plaintext Payload Length (MinPPL): The minimum number of bytes which must be placed into a packet payload in order to meet the MinPL minimum size when the packet is encoded.</li>
<li>Active Stream: A stream which has data or flow control frames ready for transmission.</li>
</ul>
<h2><a class="anchor" id="autotoc_md502"></a>
Frames</h2>
<p>Frames are taken from <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-12.4">RFC 9000 12.4 Frames and Frame Types</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">I   </th><th class="markdownTableHeadNone">H   </th><th class="markdownTableHeadNone">0   </th><th class="markdownTableHeadNone">1   </th><th class="markdownTableHeadNone">N   </th><th class="markdownTableHeadNone">C   </th><th class="markdownTableHeadNone">P   </th><th class="markdownTableHeadNone">F    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x00   </td><td class="markdownTableBodyNone">padding   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x01   </td><td class="markdownTableBodyNone">ping   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone">ack 0x02   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x03   </td><td class="markdownTableBodyNone">ack 0x03   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x04   </td><td class="markdownTableBodyNone">reset_stream   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x05   </td><td class="markdownTableBodyNone">stop_sending   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x06   </td><td class="markdownTableBodyNone">crypto   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x07   </td><td class="markdownTableBodyNone">new_token   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x08   </td><td class="markdownTableBodyNone">stream 0x08   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x09   </td><td class="markdownTableBodyNone">stream 0x09   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0A   </td><td class="markdownTableBodyNone">stream 0x0A   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0B   </td><td class="markdownTableBodyNone">stream 0x0B   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0C   </td><td class="markdownTableBodyNone">stream 0x0C   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0D   </td><td class="markdownTableBodyNone">stream 0x0D   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0E   </td><td class="markdownTableBodyNone">stream 0x0E   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x0F   </td><td class="markdownTableBodyNone">stream 0x0F   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x10   </td><td class="markdownTableBodyNone">max_data   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x11   </td><td class="markdownTableBodyNone">max_stream_data   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x12   </td><td class="markdownTableBodyNone">max_streams 0x12   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x13   </td><td class="markdownTableBodyNone">max_streams 0x13   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x14   </td><td class="markdownTableBodyNone">data_blocked   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x15   </td><td class="markdownTableBodyNone">stream_data_blocked   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x16   </td><td class="markdownTableBodyNone">streams_blocked 0x16   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x17   </td><td class="markdownTableBodyNone">streams_blocked 0x17   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x18   </td><td class="markdownTableBodyNone">new_connection_id   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x19   </td><td class="markdownTableBodyNone">retire_connection_id   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x1A   </td><td class="markdownTableBodyNone">path_challenge   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x1B   </td><td class="markdownTableBodyNone">path_response   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x1C   </td><td class="markdownTableBodyNone">connection_close 0x1C   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x1D   </td><td class="markdownTableBodyNone">connection_close 0x1D   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x1E   </td><td class="markdownTableBodyNone">handshake_done   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&amp;check;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>The various fields are as defined in RFC 9000.</p>
<h3><a class="anchor" id="autotoc_md503"></a>
Pkts</h3>
<p><em>Pkts</em> are defined as:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Pkts   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">I   </td><td class="markdownTableBodyNone">Valid in Initial packets    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">H   </td><td class="markdownTableBodyNone">Valid in Handshake packets    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyNone">Valid in 0-RTT packets    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyNone">Valid in 1-RTT packets   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md504"></a>
Spec</h3>
<p><em>Spec</em> is defined as:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Spec   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">N   </td><td class="markdownTableBodyNone">Not ack-eliciting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">C   </td><td class="markdownTableBodyNone">does not count toward bytes in flight for congestion control purposes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">P   </td><td class="markdownTableBodyNone">Can be used to probe new network paths during connection migration.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">F   </td><td class="markdownTableBodyNone">The contents of frames with this marking are flow controlled.   </td></tr>
</table>
<p>For <code>C</code>, <code>N</code> and <code>P</code>, the entire packet must consist of only frames with the marking for the packet to qualify for it. For example, a packet with an ACK frame and a <em>stream</em> frame would qualify for neither the <code>C</code> or <code>N</code> markings.</p>
<h3><a class="anchor" id="autotoc_md505"></a>
Notes</h3>
<ul>
<li>Do we need the distinction between 0-rtt and 1-rtt when both are in the Application Data number space?</li>
<li>0-RTT packets can morph into 1-RTT packets and this needs to be handled by the packetiser.</li>
</ul>
<h2><a class="anchor" id="autotoc_md506"></a>
Frame Type Prioritisation</h2>
<p>The frame types listed above are reordered below in the order of priority with which we want to serialize them. We discuss the motivations for this priority ordering below. Items without a line between them have the same priority.</p>
<div class="fragment"><div class="line">HANDSHAKE_DONE          GCR / REGEN</div>
<div class="line">----------------------------</div>
<div class="line">MAX_DATA                      REGEN</div>
<div class="line">DATA_BLOCKED                  REGEN</div>
<div class="line">MAX_STREAMS                   REGEN</div>
<div class="line">STREAMS_BLOCKED               REGEN</div>
<div class="line">----------------------------</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">NEW_CONNECTION_ID             GCR</div>
<div class="line">RETIRE_CONNECTION_ID          GCR</div>
<div class="line">----------------------------</div>
<div class="line">PATH_CHALLENGE                  -</div>
<div class="line">PATH_RESPONSE                   -</div>
<div class="line">----------------------------</div>
<div class="line">ACK                             -     (non-ACK-eliciting)</div>
<div class="line">----------------------------</div>
<div class="line">CONNECTION_CLOSE              ***     (non-ACK-eliciting)</div>
<div class="line">----------------------------</div>
<div class="line">NEW_TOKEN                     GCR</div>
<div class="line"> </div>
<div class="line">----------------------------</div>
<div class="line">CRYPTO                        GCR/*q</div>
<div class="line"> </div>
<div class="line">============================          ]  priority group, repeats per stream</div>
<div class="line">RESET_STREAM                  GCR*    ]</div>
<div class="line">STOP_SENDING                  GCR*    ]</div>
<div class="line">----------------------------          ]</div>
<div class="line">MAX_STREAM_DATA               REGEN   ]</div>
<div class="line">STREAM_DATA_BLOCKED           REGEN   ]</div>
<div class="line">----------------------------          ]</div>
<div class="line">STREAM                        *q      ]</div>
<div class="line">============================          ]</div>
<div class="line"> </div>
<div class="line">----------------------------</div>
<div class="line">PING                           -</div>
<div class="line">----------------------------</div>
<div class="line">PADDING                        -      (non-ACK-eliciting)</div>
</div><!-- fragment --><p>(See <a class="el" href="md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-fifm.html">Frame in Flight Manager</a> for information on the meaning of the second column, which specifies the retransmission strategy for each frame type.)</p>
<ul>
<li><code>PADDING</code>: For obvious reasons, this frame type is the lowest priority. We only add <code>PADDING</code> frames at the very end after serializing all other frames if we have been asked to ensure a non-zero MinPL but have not yet met that minimum.</li>
<li><p class="startli"><code>PING</code>: The <code>PING</code> frame is encoded as a single byte. It is used to make a packet ACK-eliciting if it would not otherwise be ACK-eliciting. Therefore we only need to send it if</p>
<p class="startli">a. we have been asked to ensure the packet is ACK-eliciting, and b. we do not have any other ACK-eliciting frames in the packet.</p>
<p class="startli">Thus we wait until the end before adding the PING frame as we may end up adding other ACK-eliciting frames and not need to add it. There is never a need to add more than one PING frame. If we have been asked to ensure the packet is ACK-eliciting and we do not know for sure up front if we will add any other ACK-eliciting packet, we must reserve one byte of our CMPPL to ensure we have room for this. We can cancel this reservation if we add an ACK-eliciting frame earlier. For example:</p><ul>
<li>We have been asked to ensure a packet is ACK-eliciting and the CMPPL is 1000 (we are coalescing with another packet).</li>
<li>We allocate 999 bytes for non-PING frames.</li>
<li>While adding non-PING frames, we add a STREAM frame, which is ACK-eliciting, therefore the PING frame reservation is cancelled and we increase our allocation for non-PING frames to 1000 bytes.</li>
</ul>
</li>
<li><code>HANDSHAKE_DONE</code>: This is a single byte frame with no data which is used to indicate handshake completion. It is only ever sent once. As such, it can be implemented as a single flag, and there is no risk of it outcompeting other frames. It is therefore trivially given the highest priority.</li>
<li><code>MAX_DATA</code>, <code>DATA_BLOCKED</code>: These manage connection-level flow control. They consist of a single integer argument, and, as such, take up little space, but are also critical to ensuring the timely expansion of the connection-level flow control window. Thus there is a performance reason to include them in packets with high priority and due to their small size and the fact that there will only ever be at most one per packet, there is no risk of them outcompeting other frames.</li>
<li><code>MAX_STREAMS</code>, <code>STREAMS_BLOCKED</code>: Similar to the frames above for connection-level flow control, but controls rate at which new streams are opened. The same arguments apply here, so they are prioritised equally.</li>
<li><p class="startli"><code>STREAM</code>: This is the bread and butter of a QUIC packet, and contains application-level stream data. As such these frames can usually be expected to consume most of our packet's payload budget. We must generally assume that</p><ul>
<li>there are many streams, and</li>
<li>several of those streams have much more data waiting to be sent than can be sent in a single packet.</li>
</ul>
<p class="startli">Therefore we must ensure some level of balance between multiple competing streams. We refer to this as stream scheduling. There are many strategies that can be used for this, and in the future we might even support application-signalled prioritisation of specific streams. We discuss stream scheduling further below.</p>
<p class="startli">Because these frames are expected to make up the bulk of most packets, we consider them low priority, higher only than <code>PING</code> and <code>PADDING</code> frames. Moreover, we give priority to control frames as unlike <code>STREAM</code> frames, they are vital to the maintenance of the health of the connection itself. Once we have serialized all other frame types, we can reserve the rest of the packet for any <code>STREAM</code> frames. Since all <code>STREAM</code> frames are ACK-eliciting, if we have any <code>STREAM</code> frame to send at all, it cancels any need for any <code>PING</code> frame, and may be able to partially or wholly obviate our need for any <code>PADDING</code> frames which we might otherwise have needed. Thus once we start serializing STREAM frames, we are limited only by the remaining CMPPL.</p>
</li>
<li><code>MAX_STREAM_DATA</code>, <code>STREAM_DATA_BLOCKED</code>: Stream-level flow control. These contain only a stream ID and integer value used for flow control, so they are not large. Since they are critical to the management and health of a specific stream, and because they are small and have no risk of stealing too many bytes from the <code>STREAM</code> frames they follow, we always serialize these before any corresponding <code>STREAM</code> frames for a given stream ID.</li>
<li><code>RESET_STREAM</code>, <code>STOP_SENDING</code>: These terminate a given stream ID and thus are also associated with a stream. They are also small. As such, we consider these higher priority than both <code>STREAM</code> frames and the stream-level flow control frames.</li>
<li><code>NEW_CONNECTION_ID</code>, <code>RETIRE_CONNECTION_ID</code>: These are critical for connection management and are not particularly large, therefore they are given a high priority.</li>
<li><code>PATH_CHALLENGE</code>, <code>PATH_RESPONSE</code>: Used during connection migration, these are small and are given a high priority.</li>
<li><code>CRYPTO</code>: These frames generate the logical crypto stream, which is a logical bidirectional bytestream used to transport TLS records for connection handshake and management purposes. As such, the crypto stream is viewed as similar to application streams but of a higher priority. We are willing to let <code>CRYPTO</code> frames outcompete all application stream-related frames if need be, as <code>CRYPTO</code> frames are more important to the maintenance of the connection and the handshake layer should not generate an excessive amount of data.</li>
<li><code>CONNECTION_CLOSE</code>, <code>NEW_TOKEN</code>: The <code>CONNECTION_CLOSE</code> frame can contain a user-specified reason string. The <code>NEW_TOKEN</code> frame contains an opaque token blob. Both can be arbitrarily large but for the fact that they must fit in a single packet and are thus ultimately limited by the MPPL. However, these frames are important to connection maintenance and thus are given a priority just above that of <code>CRYPTO</code> frames. The <code>CONNECTION_CLOSE</code> frame has higher priority than <code>NEW_TOKEN</code>.</li>
<li><code>ACK</code>: <code>ACK</code> frames are critical to avoid needless retransmissions by our peer. They can also potentially become large if a large number of ACK ranges needs to be transmitted. Thus <code>ACK</code> frames are given a fairly high priority; specifically, their priority is higher than all frames which have the potential to be large but below all frames which contain only limited data, such as connection-level flow control. However, we reserve the right to adapt the size of the ACK frames we transmit by chopping off some of the PN ranges to limit the size of the ACK frame if its size would be otherwise excessive. This ensures that the high priority of the ACK frame does not starve the packet of room for stream data.</li>
</ul>
<h2><a class="anchor" id="autotoc_md507"></a>
Stream Scheduling</h2>
<p><b>Stream budgeting.</b> When it is time to add STREAM frames to a packet under construction, we take our Remaining CMPPL and call this value the Streams Budget. There are many ways we could make use of this Streams Budget.</p>
<p>For the purposes of stream budgeting, we consider all bytes of STREAM frames, stream-level flow control frames, RESET_STREAM and STOP_SENDING frames to “belong” to their respective streams, and the encoded sizes of these frames are accounted to those streams for budgeting purposes. If the total number of bytes of frames necessary to serialize all pending data from all active streams is less than our Streams Budget, there is no need for any prioritisation. Otherwise, there are a number of strategies we could employ. We can categorise the possible strategies into two groups to begin with:</p>
<ul>
<li><b>Intrapacket muxing (IRPM)</b>. When the data available to send across all streams exceeds the Streams Budget for the packet, allocate an equal portion of the packet to each stream.</li>
<li><b>Interpacket muxing (IXPM).</b> When the data available to send across all streams exceeds the Streams Budget for the packet, try to fill the packet using as few streams as possible, and multiplex by using different streams in different packets.</li>
</ul>
<p>Though obvious, IRPM does not appear to be a widely used strategy [1] [2], probably due to a clear downside: if a packet is lost and it contains data for multiple streams, all of those streams will be held up. This undermines a key advantage of QUIC, namely the ability of streams to function independently of one another for the purposes of head-of-line blocking. By contrast, with IXPM, if a packet is lost, typically only a single stream is held up.</p>
<p>Suppose we choose IXPM. We must now choose a strategy for deciding when to schedule streams on packets. [1] establishes that there are two basic strategies found in use:</p>
<ul>
<li>A round robin (RR) strategy in which the frame scheduler switches to the next active stream every n packets (where n ≥ 1).</li>
<li>A sequential (SEQ) strategy in which a stream keeps being transmitted until it is no longer active.</li>
</ul>
<p>The SEQ strategy does not appear to be suitable for general-purpose applications as it presumably starves other streams of bandwidth. It appears that this strategy may be chosen in some implementations because it can offer greater efficiency with HTTP/3, where there are performance benefits to completing transmission of one stream before beginning the next. However, it does not seem like a suitable choice for an application-agnostic QUIC implementation. Thus the RR strategy is the better choice and the popular choice in a survey of implementations.</p>
<p>The choice of <code>n</code> for the RR strategy is most trivially 1 but there are suggestions [1] that a higher value of <code>n</code> may lead to greater performance due to packet loss in typical networks occurring in small durations affecting small numbers of consecutive packets. Thus, if <code>n</code> is greater than 1, fewer streams will be affected by packet loss and held up on average. However, implementing different values of <code>n</code> poses no non-trivial implementation concerns, so it is not a major concern for discussion here. Such a parameter can easily be made configurable.</p>
<p>Thus, we choose what active stream to select to fill in a packet on a revolving round robin basis, moving to the next stream in the round robin every <code>n</code> packets. If the available data in the active stream is not enough to fill a packet, we do also move to the next stream, so IRPM can still occur in this case.</p>
<p>When we fill a packet with a stream, we start with any applicable <code>RESET_STREAM</code> or <code>STOP_SENDING</code> frames, followed by stream-level flow control frames if needed, followed by <code>STREAM</code> frames.</p>
<p>(This means that <code>RESET_STREAM</code>, <code>STOP_SENDING</code>, <code>MAX_STREAM_DATA</code>, <code>STREAM_DATA_BLOCKED</code> and <code>STREAM</code> frames are interleaved rather than occurring in a fixed priority order; i.e., first there could be a <code>STOP_SENDING</code> frame for one stream, then a <code>STREAM</code> frame for another, then another <code>STOP_SENDING</code> frame for another stream, etc.)</p>
<p>[1] <a href="https://qlog.edm.uhasselt.be/epiq/files/QUICImplementationDiversity_Marx_final_11jun2020.pdf">Same Standards; Different Decisions: A Study of QUIC and HTTP/3 Implementation Diversity (Marx et al. 2020)</a> [2] <a href="https://h3.edm.uhasselt.be/files/ResourceMultiplexing_H2andH3_Marx2020.pdf">Resource Multiplexing and Prioritization in HTTP/2 over TCP versus HTTP/3 over QUIC (Marx et al. 2020)</a></p>
<h2><a class="anchor" id="autotoc_md508"></a>
Packets with Special Requirements</h2>
<p>Some packets have special requirements which the TX packetiser must meet:</p>
<ul>
<li><b>Padded Initial Datagrams.</b> A datagram must always be padded to at least 1200 bytes if it contains an Initial packet. (If there are multiple packets in the datagram, the padding does not necessarily need to be part of the Initial packet itself.) This serves to confirm that the QUIC minimum MTU is met.</li>
<li><b>Token in Initial Packets.</b> Initial packets may need to contain a token. If used, token is contained in all further Initial packets sent by the client, not just the first Initial packet.</li>
<li><p class="startli"><b>Anti-amplification Limit.</b> Sometimes a lower MDPL may be imposed due to anti-amplification limits. (Only a concern for servers, so not relevant to MVP.)</p>
<p class="startli">Note: It has been observed that a lot of implementations are not fastidious about enforcing the amplification limit in terms of precise packet sizes. Rather, they just use it to determine if they can send another packet, but not to determine what size that packet must be. Implementations with 'precise' anti-amplification implementations appear to be rare.</p>
</li>
<li><b>MTU Probes.</b> These packets have a precisely crafted size for the purposes of probing a path MTU. Unlike ordinary packets, they are routinely expected to be lost and this loss should not be taken as a signal for congestion control purposes. (Not relevant for MVP.)</li>
<li><b>Path/Migration Probes.</b> These packets are sent to verify a new path for the purposes of connection migration.</li>
<li><b>ACK Manager Probes.</b> Packets produced because the ACK manager has requested a probe be sent. These MUST be made ACK-eliciting (using a PING frame if necessary). However, these packets need not be reserved exclusively for ACK Manager purposes; they SHOULD contain new data if available, and MAY contain old data.</li>
</ul>
<p>We handle the need for different kinds of packet via a notion of “archetypes”. The TX packetiser is requested to generate a datagram via the following call:</p>
<div class="fragment"><div class="line"><span class="comment">/* Generate normal packets containing most frame types. */</span></div>
<div class="line"><span class="preprocessor">#define TX_PACKETISER_ARCHETYPE_NORMAL      0</span></div>
<div class="line"><span class="comment">/* Generate ACKs only. */</span></div>
<div class="line"><span class="preprocessor">#define TX_PACKETISER_ARCHETYPE_ACK_ONLY    1</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_tx_packetiser_generate(<a class="code hl_struct" href="structossl__quic__tx__packetiser__st.html">OSSL_QUIC_TX_PACKETISER</a> *txp,</div>
<div class="line">                                     uint32_t archetype);</div>
</div><!-- fragment --><p>More archetypes can be added in the future as required. The archetype limits what frames can be placed into the packets of a datagram.</p>
<h2><a class="anchor" id="autotoc_md509"></a>
Encryption Levels</h2>
<p>A QUIC connection progresses through Initial, Handshake, 0-RTT and 1-RTT encryption levels (ELs). The TX packetiser decides what EL to use to send a packet; or rather, it would be more accurate to say that the TX packetiser decides what ELs need a packet generating. Many resources are instantiated per EL, and can only be managed using a packet of that EL, therefore a datagram will frequently need to contain multiple packets to manage the resources of different ELs. We can thus view datagram construction as a process of determining if an EL needs to produce a packet for each EL, and concatenating the resulting packets.</p>
<p>The following EL-specific resources exist:</p>
<ul>
<li>The crypto stream, a bidirectional byte stream abstraction provided to the handshake layer. There is one crypto stream for each of the Initial, Handshake and 1-RTT ELs. (<code>CRYPTO</code> frames are prohibited in 0-RTT packets, which is to say the 0-RTT EL has no crypto stream of its own.)</li>
<li>Packet number spaces and acknowledgements. The 0-RTT and 1-RTT ELs share a PN space, but Initial and Handshake ELs both have their own PN spaces. Thus, Initial packets can only be acknowledged using an <code>ACK</code> frame sent in an Initial packet, etc.</li>
</ul>
<p>Thus, a fully generalised datagram construction methodology looks like this:</p>
<ul>
<li>Let E be the set of ELs which are not discarded and for which <code>pending(el)</code> is true, where <code>pending()</code> is a predicate function determining if the EL has data to send.</li>
<li>Determine if we are limited by anti-amplification restrictions. (Not relevant for MVP since this is only needed on the server side.)</li>
<li><p class="startli">For each EL in E, construct a packet bearing in mind the Remaining CMPPL and append it to the datagram.</p>
<p class="startli">For the Initial EL, we attach a token if we have been given one.</p>
<p class="startli">If Initial is in E, the total length of the resulting datagram must be at least 1200, but it is up to us to which packets of which ELs in E we add padding to.</p>
</li>
<li>Send the datagram.</li>
</ul>
<h2><a class="anchor" id="autotoc_md510"></a>
TX Key Update</h2>
<p>The TX packetiser decides when to tell the QRL to initiate a TX-side key update. It decides this using information provided by the QRL.</p>
<h2><a class="anchor" id="autotoc_md511"></a>
Restricting packet sizes</h2>
<p>Two factors impact the size of packets that can be sent:</p>
<ul>
<li>The maximum datagram payload length (MDPL)</li>
<li>Congestion control</li>
</ul>
<p>The MDPL limits the size of an entire datagram, whereas congestion control limits how much data can be in flight at any given time, which may cause a lower limit to be imposed on a given packet.</p>
<h2><a class="anchor" id="autotoc_md512"></a>
Stateless Reset</h2>
<p>Refer to <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-10.3">RFC 9000 10.3 Stateless Reset</a>. It's entirely reasonable for the state machine to send this directly and immediately if required. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
