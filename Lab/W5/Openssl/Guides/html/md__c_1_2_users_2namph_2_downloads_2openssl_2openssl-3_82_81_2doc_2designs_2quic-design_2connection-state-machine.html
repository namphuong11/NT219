<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC Connection State Machine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC Connection State Machine</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md252"></a>
FSM Model</h1>
<p>QUIC client-side connection state can be broken down into five coarse phases of a QUIC connection:</p>
<ul>
<li>The Idle substate (which is simply the state before we have started trying to establish a connection);</li>
<li>The Active state, which comprises two substates:<ul>
<li>The Establishing state, which comprises many different substates;</li>
<li>The Open state;</li>
</ul>
</li>
<li>The Terminating state, which comprises several substates;</li>
<li>The Terminated state, which is the terminal state.</li>
</ul>
<p>There is monotonic progression through these phases.</p>
<p>These names have been deliberately chosen to use different terminology to common QUIC terms such as 'handshake' to avoid confusion, as they are not the same concepts. For example, the Establishing state uses Initial, Handshake and 1-RTT packets.</p>
<p>This discussion is (currently) given from the client side perspective only. State machine considerations only relevant to servers are not mentioned. 0-RTT is also not currently modelled in this analysis.</p>
<p>The synthesis of this FSM is not suggested by the QUIC RFCs but has been discerned from the requirements imposed. This does not mean that the implementation of this FSM as literally presented below is an optimal or advisable implementation strategy, and a cursory examination of existing QUIC implementations suggests that such an approach is not common. Moreover, excess attention should not be given to the Open state, as 1-RTT application communication can occur even still in the Establishing state (for example, when the handshake has been completed but not yet confirmed).</p>
<p>However, the state machine described herein is helpful as an aid to understanding and broadly captures the logic which our implementation will embody. The design of the actual implementation is discussed further below.</p>
<p>The above states and their substates are defined as follows:</p>
<ul>
<li><p class="startli">The Establishing state involves the use of Initial and Handshake packets. It is terminated when the handshake is confirmed.</p>
<p class="startli">Handshake confirmation is not the same as handshake completion. Handshake confirmation occurs on the client when it receives a <code>HANDSHAKE_DONE</code> frame (which occurs in a 1-RTT packet, thus 1-RTT packets are also invoked in the Establishing state). On the server, handshake confirmation occurs as soon as the handshake is considered completed (see RFC 9001 s. 4.1).</p>
<p class="startli">The Establishing state is subdivided into the following substates:</p><ul>
<li><p class="startli">Proactive Version Negotiation (optional): The client sends a Version Negotiation packet with a reserved version number to forcibly elicit a list of the server's supported versions. This is not expected to be commonly used, as it adds a round trip.</p>
<p class="startli">If it is used, the time spent in this state is based on waiting for the server to respond, and potentially retransmitting after a timeout.</p>
</li>
<li>Pre-Initial: The client has completed proactive version negotiation (if it performed it), but has not yet sent any encrypted packet. This substate is included for exposition; no time will generally be spent in it and there is immediate transmission of the first encrypted packet and transition to Initial Exchange A.</li>
<li><p class="startli">Initial Exchange A: The client has sent at least one Initial packet to the server attempting to initiate a connection.</p>
<p class="startli">The client is waiting for a server response, which might be:</p><ul>
<li>a Version Negotiation packet (leading to the Reactive Version Negotiation state);</li>
<li>a Retry packet (leading to Initial Exchange B); or</li>
<li>an Initial packet (leading to the Initial Exchange Confirmed state).</li>
</ul>
</li>
<li>Reactive Version Negotiation: The server has rejected the client's proposed version. If proactive version negotiation was used, this can be considered an error. Otherwise, we return to the Pre-Initial state and proceed as though proactive version negotiation was performed using the information in the version negotiation packet.</li>
<li><p class="startli">Initial Exchange B: The client has been asked to perform a Retry. It sends at least one Initial packet to the server attempting to initiate a connection. Every Initial packet contains the quoted Retry Token. Any data sent in <code>CRYPTO</code> frames in Initial Exchange A must be retransmitted, but PNs MUST NOT be reset. Note that this is still considered part of the same connection, and QUIC Transport Parameters are later used to cryptographically bind the established connection state to the original DCIDs used as part of the Retry process. A server is not allowed to respond to a Retry-triggered Initial exchange with another Retry, and if it does we ignore it, which is the major distinction of this state from Initial Exchange A.</p>
<p class="startli">The client is waiting for a server response, which might be:</p><ul>
<li>a Version Negotiation packet (invalid, ignored);</li>
<li>a Retry packet (invalid, ignored);</li>
<li>an Initial packet (leading to the Initial Exchange Continued state);</li>
</ul>
</li>
<li><p class="startli">Initial Exchange Continued: The client has sent at least one Initial packet to the server and received at least one valid Initial packet from the server. There is no longer any possibility of a Retry (any such packet is ignored) and communications may continue via Initial packets for an arbitrarily long period until the handshake layer indicates the Handshake EL is ready.</p>
<p class="startli">The client is waiting for server packets, until one of those packets causes the handshake layer (whether it is TLS 1.3 or some other hypothetical handshake layer) to emit keys for the Handshake EL. This will generally occur due to incoming Initial packets containing crypto stream segments (in the form of <code>CRYPTO</code> frames) which deliver handshake layer protocol messages to the handshake layer in use.</p>
</li>
<li><p class="startli">Handshake: The Handshake EL is now available to the client. Either client or server may send the first Handshake packet.</p>
<p class="startli">The client is waiting to receive a Handshake packet from the server.</p>
</li>
<li><p class="startli">Handshake Continued: The client has received and successfully decrypted at least one Handshake packet. The client now discards the Initial EL. Communications via the handshake EL may continue for an arbitrary period of time.</p>
<p class="startli">The client is waiting to receive more Handshake packets from the server to advance the handshake layer and cause it to transition to the Handshake Completed state.</p>
</li>
<li><p class="startli">Handshake Completed: The handshake layer has indicated that it considers the handshake completed. For TLS 1.3, this means both parties have sent and received (and verified) TLS 1.3 Finished messages. The handshake layer must emit keys for the 1-RTT EL at this time.</p>
<p class="startli">Though the handshake is not yet confirmed, the client can begin sending 1-RTT packets.</p>
<p class="startli">The QUIC Transport Parameters sent by the peer are now authenticated. (Though the peer's QUIC Transport Parameters may have been received earlier in the handshake process, they are only considered authenticated at this point.)</p>
<p class="startli">The client transitions to Handshake Confirmed once either</p><ul>
<li>it receives a <code>HANDSHAKE_DONE</code> frame in a 1-RTT packet, or</li>
<li>it receives acknowledgement of any 1-RTT packet it sent.</li>
</ul>
<p class="startli">Though this discussion only covers the client state machine, it is worth noting that on the server, the handshake is considered confirmed as soon as it is considered completed.</p>
</li>
<li><p class="startli">Handshake Confirmed: The client has received confirmation from the server that the handshake is confirmed.</p>
<p class="startli">The principal effect of moving to this state is that the Handshake EL is discarded. Key Update is also now permitted for the first time.</p>
<p class="startli">The Establishing state is now done and there is immediate transition to the Open state.</p>
</li>
</ul>
</li>
<li><p class="startli">The Open state is the steady state of the connection. It is a single state.</p>
<p class="startli">Application stream data is exchanged freely. Only 1-RTT packets are used. The Initial, Handshake (and 0-RTT) ELs have been discarded, transport parameters have been exchanged, and the handshake has been confirmed.</p>
<p class="startli">The client transitions to</p><ul>
<li>the Terminating — Closing state if the local application initiates an immediate close (a <code>CONNECTION_CLOSE</code> frame is sent);</li>
<li>the Terminating — Draining state if the remote peer initiates an immediate close (i.e., a <code>CONNECTION_CLOSE</code> frame is received);</li>
<li>the Terminated state if the idle timeout expires; a <code>CONNECTION_CLOSE</code> frame is NOT sent;</li>
<li>the Terminated state if the peer triggers a stateless reset; a <code>CONNECTION_CLOSE</code> frame is NOT sent.</li>
</ul>
</li>
<li><p class="startli">The Terminating state is used when closing the connection. This may occur due to an application request or a transport-level protocol error.</p>
<p class="startli">Key updates may not be initiated in the Terminating state.</p>
<p class="startli">This state is divided into two substates:</p><ul>
<li><p class="startli">The Closing state, used for a locally initiated immediate close. In this state, a packet containing a <code>CONNECTION_CLOSE</code> frame is transmitted again in response to any packets received. This ensures that a <code>CONNECTION_CLOSE</code> frame is received by the peer even if the initially transmitted <code>CONNECTION_CLOSE</code> frame was lost. Note that these <code>CONNECTION_CLOSE</code> frames are not governed by QUIC's normal loss detection mechanisms; this is a bespoke mechanism unique to this state, which exists solely to ensure delivery of the <code>CONNECTION_CLOSE</code> frame.</p>
<p class="startli">The endpoint progresses to the Terminated state after a timeout interval, which should not be less than three times the PTO interval.</p>
<p class="startli">It is also possible for the endpoint to transition to the Draining state instead, if it receives a <code>CONNECTION_CLOSE</code> frame prior to the timeout expiring. This indicates that the peer is also closing.</p>
</li>
<li><p class="startli">The Draining state, used for a peer initiated immediate close.</p>
<p class="startli">The local endpoint may not send any packets of any kind in this state. It may optionally send one <code>CONNECTION_CLOSE</code> frame immediately prior to entering this state.</p>
<p class="startli">The endpoint progresses to the Terminated state after a timeout interval, which should not be less than three times the PTO interval.</p>
</li>
</ul>
</li>
<li>The Terminated state is the terminal state of a connection. Regardless of how a connection ends (local or peer-initiated immediate close, idle timeout, stateless reset), a connection always ultimately ends up in this state. There is no longer any requirement to send or receive any packet. No timer events related to the connection will ever need fire again. This is a totally quiescent state. The state associated with the connection may now be safely freed.</li>
</ul>
<p>We express this state machine in more concrete form in the form of a table, which makes the available transitions clear:</p>
<p>† Except where superseded by a more specific transition</p>
<p>ε means “where no other transition is applicable”.</p>
<p>Where an action is specified in the Transition/Action column but no new state, no state change occurs.</p>
<table class="doxtable">
<tr>
<th>State</th><th>Action On Entry/Exit</th><th>Event</th><th>Transition/Action </th></tr>
<tr>
<td rowspan="2"><code>IDLE</code> </td><td rowspan="2"></td><td>—<code>APP:CONNECT</code>→ </td><td><code>ACTIVE.ESTABLISHING.PROACTIVE_VER_NEG</code> (if used), else <code>ACTIVE.ESTABLISHING.PRE_INITIAL</code>  </td></tr>
<tr>
<td>—<code>APP:CLOSE</code>→ </td><td><code>TERMINATED</code>  </td></tr>
<tr>
<td rowspan="5"><code>ACTIVE</code> </td><td rowspan="5"></td><td>—<code>IDLE_TIMEOUT</code>→ </td><td><code>TERMINATED</code>  </td></tr>
<tr>
<td>—<code>PROBE_TIMEOUT</code>→ † </td><td><code>SendProbeIfAnySentPktsUnacked()</code>  </td></tr>
<tr>
<td>—<code>APP:CLOSE</code>→ † </td><td><code>TERMINATING.CLOSING</code>  </td></tr>
<tr>
<td>—<code>RX:ANY[CONNECTION_CLOSE]</code>→ </td><td><code>TERMINATING.DRAINING</code>  </td></tr>
<tr>
<td>—<code>RX:STATELESS_RESET</code>→ </td><td><p class="starttd"><code>TERMINATED</code> </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="3"><code>ACTIVE.ESTABLISHING.PROACTIVE_VER_NEG</code> </td><td rowspan="3"><code>enter:SendReqVerNeg</code> </td><td>—<code>RX:VER_NEG</code>→ </td><td><code>ACTIVE.ESTABLISHING.PRE_INITIAL</code>  </td></tr>
<tr>
<td>—<code>PROBE_TIMEOUT</code>→ </td><td><code>ACTIVE.ESTABLISHING.PROACTIVE_VER_NEG</code> (retransmit)  </td></tr>
<tr>
<td>—<code>APP:CLOSE</code>→ </td><td><code>TERMINATED</code>  </td></tr>
<tr>
<td rowspan="1"><code>ACTIVE.ESTABLISHING.PRE_INITIAL</code> </td><td rowspan="1"></td><td>—ε→ </td><td><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_A</code>  </td></tr>
<tr>
<td rowspan="4"><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_A</code> </td><td rowspan="4"><code>enter:SendPackets()</code> (First Initial) </td><td>—<code>RX:RETRY</code>→ </td><td><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_B</code>  </td></tr>
<tr>
<td>—<code>RX:INITIAL</code>→ </td><td><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_CONTINUED</code>  </td></tr>
<tr>
<td>—<code>RX:VER_NEG</code>→ </td><td><code>ACTIVE.ESTABLISHING.REACTIVE_VER_NEG</code>  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="1"><code>ACTIVE.ESTABLISHING.REACTIVE_VER_NEG</code> </td><td rowspan="1"></td><td>—ε→ </td><td><code>ACTIVE.ESTABLISHING.PRE_INITIAL</code>  </td></tr>
<tr>
<td rowspan="3"><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_B</code> </td><td rowspan="3"><code>enter:SendPackets()</code><br  />
 (First Initial, with token)<br  />
 (*All further Initial packets contain the token)<br  />
(*PN is not reset) </td><td>—<code>RX:INITIAL</code>→ </td><td><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_CONTINUED</code>  </td></tr>
<tr>
<td>—<code>PROBE_TIMEOUT</code>→ </td><td>TODO: Tail loss probe for initial packets?  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="2"><code>ACTIVE.ESTABLISHING.INITIAL_EXCHANGE_CONTINUED</code> </td><td rowspan="2"><code>enter:SendPackets()</code> </td><td>—<code>RX:INITIAL</code>→ </td><td>(packet processed, no change)  </td></tr>
<tr>
<td>—<code>TLS:HAVE_EL(HANDSHAKE)</code>→ </td><td><code>ACTIVE.ESTABLISHING.HANDSHAKE</code>  </td></tr>
<tr>
<td rowspan="3"><code>ACTIVE.ESTABLISHING.HANDSHAKE</code> </td><td rowspan="3"><code>enter:ProvisionEL(Handshake)</code><br  />
 <code>enter:SendPackets()</code> (First Handshake packet, if pending) </td><td>—<code>RX:HANDSHAKE</code>→ </td><td><code>ACTIVE.ESTABLISHING.HANDSHAKE_CONTINUED</code>  </td></tr>
<tr>
<td>—<code>RX:INITIAL</code>→ </td><td>(packet processed if EL is not dropped)  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="3"><code>ACTIVE.ESTABLISHING.HANDSHAKE_CONTINUED</code> </td><td rowspan="3"><code>enter:DropEL(Initial)</code><br  />
<code>enter:SendPackets()</code> </td><td>—<code>RX:HANDSHAKE</code>→ </td><td>(packet processed, no change)  </td></tr>
<tr>
<td>—<code>TLS:HANDSHAKE_COMPLETE</code>→ </td><td><code>ACTIVE.ESTABLISHING.HANDSHAKE_COMPLETE</code>  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="3"><code>ACTIVE.ESTABLISHING.HANDSHAKE_COMPLETED</code> </td><td rowspan="3"><code>enter:ProvisionEL(1RTT)</code><br  />
<code>enter:HandshakeComplete()</code><br  />
<code>enter[server]:Send(HANDSHAKE_DONE)</code><br  />
<code>enter:SendPackets()</code> </td><td>—<code>RX:1RTT[HANDSHAKE_DONE]</code>→ </td><td><code>ACTIVE.ESTABLISHING.HANDSHAKE_CONFIRMED</code>  </td></tr>
<tr>
<td>—<code>RX:1RTT</code>→ </td><td>(packet processed, no change)  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="1"><code>ACTIVE.ESTABLISHING.HANDSHAKE_CONFIRMED</code> </td><td rowspan="1"><code>enter:DiscardEL(Handshake)</code><br  />
<code>enter:Permit1RTTKeyUpdate()</code> </td><td>—ε→ </td><td><code>ACTIVE.OPEN</code>  </td></tr>
<tr>
<td rowspan="2"><code>ACTIVE.OPEN</code> </td><td rowspan="2"></td><td>—<code>RX:1RTT</code>→ </td><td>(packet processed, no change)  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="2"><code>TERMINATING</code> </td><td rowspan="2"></td><td>—<code>TERMINATING_TIMEOUT</code>→ </td><td><code>TERMINATED</code>  </td></tr>
<tr>
<td>—<code>RX:STATELESS_RESET</code>→ </td><td><code>TERMINATED</code>  </td></tr>
<tr>
<td rowspan="3"><code>TERMINATING.CLOSING</code> </td><td rowspan="3"><code>enter:QueueConnectionCloseFrame()</code><br  />
<code>enter:SendPackets()</code> </td><td>—<code>RX:ANY[CONNECTION_CLOSE]</code>→ </td><td><code>TERMINATING.DRAINING</code>  </td></tr>
<tr>
<td>—<code>RX:ANY</code>→ </td><td><code>QueueConnectionCloseFrame()</code><br  />
<code>SendPackets()</code>  </td></tr>
<tr>
<td>—<code>CAN_SEND</code>→ </td><td><code>SendPackets()</code>  </td></tr>
<tr>
<td rowspan="1"><code>TERMINATING.DRAINING</code> </td><td rowspan="1"></td><td></td><td></td></tr>
<tr>
<td rowspan="1"><code>TERMINATED</code> </td><td rowspan="1"></td><td>[terminal state] </td><td></td></tr>
</table>
<p>Notes on various events:</p>
<ul>
<li><p class="startli"><code>CAN_SEND</code> is raised when transmission of packets has been unblocked after previously having been blocked. There are broadly two reasons why transmission of packets may not have been possible:</p><ul>
<li>Due to OS buffers or network-side write BIOs being full;</li>
<li>Due to limits imposed by the chosen congestion controller.</li>
</ul>
<p class="startli"><code>CAN_SEND</code> is expected to be raised due to a timeout prescribed by the congestion controller or in response to poll(2) or similar notifications, as abstracted by the BIO system and how the application has chosen to notify libssl of network I/O readiness.</p>
<p class="startli">It is generally implied that processing of a packet as mentioned above may cause new packets to be queued and sent, so this is not listed explicitly in the Transition column except for the <code>CAN_SEND</code> event.</p>
</li>
<li><code>PROBE_TIMEOUT</code> is raised after the PTO interval and stimulates generation of a tail loss probe.</li>
<li><code>IDLE_TIMEOUT</code> is raised after the connection idle timeout expires. Note that the loss detector only makes a determination of loss due to an incoming ACK frame; if a peer becomes totally unresponsive, this is the only mechanism available to terminate the connection (other than the local application choosing to close it).</li>
<li><code>RX:STATELESS_RESET</code> indicates receipt of a stateless reset, but note that it is not guaranteed that we are able to recognise a stateless reset that we receive, thus this event may not always be raised.</li>
<li><code>RX:ANY[CONNECTION_CLOSE]</code> denotes a <code>CONNECTION_CLOSE</code> frame received in any non-discarded EL.</li>
<li>Any circumstance where <code>RX:RETRY</code> or <code>RX:VER_NEG</code> are not explicitly listed means that these packets are not allowed and will be ignored.</li>
<li>Protocol errors, etc. can be handled identically to <code>APP:CLOSE</code> events as indicated in the above table if locally initiated. Protocol errors signalled by the peer are handled as <code>RX:ANY[CONNECTION_CLOSE]</code> events.</li>
</ul>
<p>Notes on various actions:</p>
<ul>
<li><code>SendPackets()</code> sends packets if we have anything pending for transmission, and only to the extent we are able to with regards to congestion control and available BIO buffer space, etc.</li>
</ul>
<h1><a class="anchor" id="autotoc_md253"></a>
Non-FSM Model</h1>
<p>Common QUIC implementations appear to prefer modelling connection state as a set of flags rather than as a FSM. It can be observed above that there is a fair degree of commonality between many states. This has been modelled above using hierarchical states with default handlers for common events. [The state machine can be viewed as a diagram here (large image).](./images/connection-state-machine.png)</p>
<p>We transpose the above table to sort by events rather than states, to discern the following list of events:</p>
<ul>
<li><code>APP:CONNECT</code>: Supported in <code>IDLE</code> state only.</li>
<li><code>RX:VER_NEG</code>: Handled in <code>ESTABLISHING.PROACTIVE_VER_NEG</code> and <code>ESTABLISHING.INITIAL_EXCHANGE_A</code> only, otherwise ignored.</li>
<li><code>RX:RETRY</code>: Handled in <code>ESTABLISHING.INITIAL_EXCHANGE_A</code> only.</li>
<li><code>PROBE_TIMEOUT</code>: Applicable to <code>OPEN</code> and all (non-ε) <code>ESTABLISHING</code> substates. Handled via <code>SendProbeIfAnySentPktsUnacked()</code> except in the <code>ESTABLISHING.PROACTIVE_VER_NEG</code> state, which reenters that state to trigger retransmission of a Version Negotiation packet.</li>
<li><code>IDLE_TIMEOUT</code>: Applicable to <code>OPEN</code> and all (non-ε) <code>ESTABLISHING</code> substates. Action: immediate transition to <code>TERMINATED</code> (no <code>CONNECTION_CLOSE</code> frame is sent).</li>
<li><code>TERMINATING_TIMEOUT</code>: Timeout used by the <code>TERMINATING</code> state only.</li>
<li><code>CAN_SEND</code>: Applicable to <code>OPEN</code> and all (non-ε) <code>ESTABLISHING</code> substates, as well as <code>TERMINATING.CLOSING</code>. Action: <code>SendPackets()</code>.</li>
<li><code>RX:STATELESS_RESET</code>: Applicable to all <code>ESTABLISHING</code> and <code>OPEN</code> states and the <code>TERMINATING.CLOSING</code> substate. Always causes a direct transition to <code>TERMINATED</code>.</li>
<li><code>APP:CLOSE</code>: Supported in <code>IDLE</code>, <code>ESTABLISHING</code> and <code>OPEN</code> states. (Reasonably a no-op in <code>TERMINATING</code> or <code>TERMINATED.</code>)</li>
<li><code>RX:ANY[CONNECTION_CLOSE]</code>: Supported in all <code>ESTABLISHING</code> and <code>OPEN</code> states, as well as in <code>TERMINATING.CLOSING</code>. Transition to <code>TERMINATING.DRAINING</code>.</li>
<li><p class="startli"><code>RX:INITIAL</code>, <code>RX:HANDSHAKE</code>, <code>RX:1RTT</code>: Our willingness to process these is modelled on whether we have an EL provisioned or discarded, etc.; thus this does not require modelling as additional state.</p>
<p class="startli">Once we successfully decrypt a Handshake packet, we stop processing Initial packets and discard the Initial EL, as required by RFC.</p>
</li>
<li><code>TLS:HAVE_EL(HANDSHAKE)</code>: Emitted by the handshake layer when Handshake EL keys are available.</li>
<li><code>TLS:HANDSHAKE_COMPLETE</code>: Emitted by the handshake layer when the handshake is complete. Implies connection has been authenticated. Also implies 1-RTT EL keys are available. Whether the handshake is complete, and also whether it is confirmed, is reasonably implemented as a flag.</li>
</ul>
<p>From here we can discern state dependence of different events:</p>
<ul>
<li><p class="startli"><code>APP:CONNECT</code>: Need to know if application has invoked this event yet, as if so it is invalid.</p>
<p class="startli">State: Boolean: Connection initiated?</p>
</li>
<li><code>RX:VER_NEG</code>: Only valid if we have not yet received any successfully processed encrypted packet from the server.</li>
<li><p class="startli"><code>RX:RETRY</code>: Only valid if we have sent an Initial packet to the server, have not yet received any successfully processed encrypted packet from the server, and have not previously been asked to do a Retry as part of this connection (and the Retry Integrity Token validates).</p>
<p class="startli">Action: Note that we are now acting on a retry and start again. Do not reset packet numbers. The original CIDs used for the first connection attempt must be noted for later authentication in the QUIC Transport Parameters.</p>
<p class="startli">State: Boolean: Retry requested?</p>
<p class="startli">State: CID: Original SCID, DCID.</p>
</li>
<li><p class="startli"><code>PROBE_TIMEOUT</code>: If we have sent at least one encrypted packet yet, we can handle this via a standard probe-sending mechanism. Otherwise, we are still in Proactive Version Negotiation and should retransmit the Version Negotiation packet we sent.</p>
<p class="startli">State: Boolean: Doing proactive version negotiation?</p>
</li>
<li><p class="startli"><code>IDLE_TIMEOUT</code>: Only applicable in <code>ACTIVE</code> states.</p>
<p class="startli">We are <code>ACTIVE</code> if a connection has been initiated (see <code>APP:CONNECT</code>) and we are not in <code>TERMINATING</code> or <code>TERMINATED</code>.</p>
</li>
<li><code>TERMINATING_TIMEOUT</code>: Timer used in <code>TERMINATING</code> state only.</li>
<li><code>CAN_SEND</code>: Stimulates transmission of packets.</li>
<li><code>RX:STATELESS_RESET</code>: Always handled unless we are in <code>TERMINATED</code>.</li>
<li><code>APP:CLOSE</code>: Usually causes a transition to <code>TERMINATING.CLOSING</code>.</li>
<li><code>RX:INITIAL</code>, <code>RX:HANDSHAKE</code>, <code>RX:1RTT</code>: Willingness to process these is implicit in whether we currently have the applicable EL provisioned.</li>
<li><code>TLS:HAVE_EL(HANDSHAKE)</code>: Handled by the handshake layer and forwarded to the record layer to provision keys.</li>
<li><code>TLS:HANDSHAKE_COMPLETE</code>: Should be noted as a flag and notification provided to various components.</li>
</ul>
<p>We choose to model the CSM's state as follows:</p>
<ul>
<li>The <code>IDLE</code>, <code>ACTIVE</code>, <code>TERMINATING.CLOSED</code>, <code>TERMINATING.DRAINED</code> and <code>TERMINATED</code> states are modelled explicitly as a state variable. However, the substates of <code>ACTIVE</code> are not explicitly modelled.</li>
<li>The following flags are modelled:<ul>
<li>Retry Requested? (+ Original SCID, DCID if so)</li>
<li>Have Sent Any Packet?</li>
<li>Are we currently doing proactive version negotiation?</li>
<li>Have Successfully Received Any Encrypted Packet?</li>
<li>Handshake Completed?</li>
<li>Handshake Confirmed?</li>
</ul>
</li>
<li>The following timers are modelled:<ul>
<li>PTO Timeout</li>
<li>Terminating Timeout</li>
<li>Idle Timeout</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md254"></a>
Implementation Plan</h1>
<ul>
<li><p class="startli">Phase 1: “Steady state only” model which jumps to the <code>ACTIVE.OPEN</code> state with a hardcoded key.</p>
<p class="startli">Test plan: Currently uncertain, to be determined.</p>
</li>
<li><p class="startli">Phase 2: “Dummy handshake” model which uses a one-byte protocol as the handshake layer as a standin for TLS 1.3. e.g. a 0x01 byte “represents” a ClientHello, a 0x02 byte “represents” a ServerHello. Keys are fixed.</p>
<p class="startli">Test plan: If feasible, an existing QUIC implementation will be modified to use this protocol and E2E testing will be performed against it. (This can probably be done quickly but an alternate plan may be required if the effort needed turns out be excessive.)</p>
</li>
<li><p class="startli">Phase 3: Final model with TLS 1.3 handshake layer fully plumbed in.</p>
<p class="startli">Test plan: Testing against real world implementations. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
