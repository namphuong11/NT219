<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC API Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC API Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document sets out the objectives of the QUIC API design process, describes the new and changed APIs, and the design constraints motivating those API designs and the relevant design decisions.</p>
<ul>
<li>QUIC API Overview<ul>
<li>Overview and Implementation Status</li>
<li>Objectives</li>
<li>SSL Objects<ul>
<li>Structure of Documentation</li>
<li>Existing APIs<ul>
<li>`SSL_set_connect_state`</li>
<li>`SSL_set_accept_state`</li>
<li>`SSL_is_server`</li>
<li>`SSL_connect`</li>
<li>`SSL_accept`</li>
<li>`SSL_do_handshake`</li>
<li>`SSL_read`, `SSL_read_ex`, `SSL_peek`, `SSL_peek_ex`</li>
<li>`SSL_write`, `SSL_write_ex`</li>
<li>`SSL_pending`</li>
<li>`SSL_has_pending`</li>
<li>`SSL_shutdown`</li>
<li>`SSL_clear`</li>
<li>`SSL_free`</li>
<li>`SSL_set0_rbio`, `SSL_set0_wbio`, `SSL_set_bio`</li>
<li>`SSL_set_[rw]fd`</li>
<li>`SSL_get_[rw]fd`</li>
<li>`SSL_CTRL_MODE`, `SSL_CTRL_CLEAR_MODE`</li>
<li>SSL Modes</li>
</ul>
</li>
<li>New APIs for Single-Stream Operation<ul>
<li>`SSL_handle_events`</li>
<li>`SSL_get_event_timeout`</li>
<li>`SSL_set_blocking_mode`, `SSL_get_blocking_mode`</li>
<li>`SSL_get_rpoll_descriptor`, `SSL_get_wpoll_descriptor`</li>
<li>`SSL_net_read_desired`, `SSL_net_write_desired`</li>
<li>`SSL_want`, `SSL_want_read`, `SSL_want_write`</li>
<li>`SSL_set1_initial_peer_addr`</li>
<li>`SSL_shutdown_ex`</li>
<li>`SSL_stream_conclude`</li>
<li>`SSL_stream_reset`</li>
<li>`SSL_get_stream_state`</li>
<li>`SSL_get_stream_read_error_code`, `SSL_get_stream_write_error_code`</li>
<li>`SSL_get_conn_close_info`</li>
</ul>
</li>
<li>New APIs for Multi-Stream Operation<ul>
<li>Notes on Multi-Threaded Operation</li>
<li>Notes on Blocking</li>
<li>Notes on Application-Level Polling</li>
<li>`SSL_get0_connection`</li>
<li>`SSL_is_connection`</li>
<li>`SSL_get_stream_type`</li>
<li>`SSL_get_stream_id`</li>
<li>`SSL_is_stream_local`</li>
<li>`SSL_new_stream`</li>
<li>`SSL_accept_stream`</li>
<li>`SSL_get_accept_stream_queue_len`</li>
<li>`SSL_set_incoming_stream_policy`</li>
<li>`SSL_set_default_stream_mode`</li>
</ul>
</li>
<li>Future APIs</li>
</ul>
</li>
<li>BIO Objects<ul>
<li>Existing APIs<ul>
<li>`BIO_s_connect`, `BIO_new_ssl_connect`, `BIO_set_conn_hostname`</li>
<li>`BIO_new_bio_pair`</li>
<li>Interactions with `BIO_f_buffer`</li>
<li>MTU Signalling</li>
</ul>
</li>
<li>New APIs<ul>
<li>`BIO_sendmmsg` and `BIO_recvmmsg`</li>
<li>Truncation Mode</li>
<li>Capability Negotiation</li>
<li>Local Address Support</li>
<li>`BIO_s_dgram_pair`</li>
<li>`BIO_POLL_DESCRIPTOR`</li>
<li>`BIO_s_dgram_mem`</li>
<li>`BIO_err_is_non_fatal`</li>
</ul>
</li>
</ul>
</li>
<li>Q &amp; A</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md310"></a>
Overview and Implementation Status</h1>
<p>A listing of all SSL object APIs and their implications for QUIC, including current implementation status, can be found in <a class="el" href="md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-api-ssl-funcs.html">quic-api-ssl-funcs.md</a>.</p>
<p>Non-SSL object APIs which are new or changed, or otherwise discussed in this document are listed below, along with their implementation status. SSL object APIs are not listed here; see <a class="el" href="md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-api-ssl-funcs.html">quic-api-ssl-funcs.md</a> for details on SSL object APIs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone">API   </th><th class="markdownTableHeadNone">Status    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Changed   </td><td class="markdownTableBodyNone"><code>BIO_s_connect</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone"><code>BIO_set_conn_hostname</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone"><code>BIO_new_bio_pair</code>   </td><td class="markdownTableBodyNone">N/A (see <code>BIO_new_bio_dgram_pair</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_s_dgram_pair</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_mtu</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone"><code>BIO_dgram_set_mtu</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_sendmmsg</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_recvmmsg</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_set_no_trunc</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_no_trunc</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_set_caps</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_caps</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_effective_caps</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_local_addr_cap</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_set_local_addr_enable</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_dgram_get_local_addr_enable</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_get_rpoll_descriptor</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_get_wpoll_descriptor</code>   </td><td class="markdownTableBodyNone">Done    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone"><code>BIO_err_is_non_fatal</code>   </td><td class="markdownTableBodyNone">Done   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md311"></a>
Objectives</h1>
<p>The objectives of the QUIC API design are:</p>
<ul>
<li>to provide an API suitable for use with QUIC, now and in the future;</li>
<li>to reuse the existing libssl APIs to the extent feasible;</li>
<li>to enable existing applications to adapt to using QUIC with only minimal API changes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md312"></a>
SSL Objects</h1>
<h2><a class="anchor" id="autotoc_md313"></a>
Structure of Documentation</h2>
<p>Each API listed below has an information table with the following fields:</p>
<ul>
<li><b>Semantics</b>: This can be one of:<ul>
<li><b>Unchanged</b>: The semantics of this existing libssl API call are unchanged.</li>
<li><b>Changed</b>: The semantics are changed for QUIC.</li>
<li><b>New</b>: The API is new for QUIC.</li>
</ul>
</li>
<li><code>SSL_get_error</code>: Can this API, when used with QUIC, change the state returned by <code>SSL_get_error</code>? This can be any combination of:<ul>
<li><b>Never</b>: Does not interact with <code>SSL_get_error</code>.</li>
<li><b>Error</b>: Non-<code>WANT_READ</code>/<code>WANT_WRITE</code> errors can be raised.</li>
<li><b>Want</b>: <code>WANT_READ</code>/<code>WANT_WRITE</code> can be raised.</li>
</ul>
</li>
<li><b>Can Tick?</b>: Whether this function is allowed to perform event processing for the QUIC state machine and potentially perform network I/O.</li>
<li><b>CSHL:</b> Connection/Stream/Handshake Layer classification. This can be one of:<ul>
<li><b>HL:</b> This is a handshake layer related call. It should be supported on a QUIC connection SSL object, forwarding to the handshake layer SSL object. QUIC stream SSL objects do not allow these calls to be forwarded.</li>
<li><b>HL-Forbidden:</b> This is a handshake layer related call, but it is inapplicable to QUIC, so it is not supported.</li>
<li><b>C:</b> Not handshake-layer related. QUIC connection SSL object usage only. Fails on a QUIC stream SSL object.</li>
<li><b>CS:</b> Not handshake-layer related. Can be used on any QUIC SSL object.</li>
<li><b>S</b>: Requires a QUIC stream SSL object or a QUIC connection SSL object with a default stream attached.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md314"></a>
Existing APIs</h2>
<h3><a class="anchor" id="autotoc_md315"></a>
<code>SSL_set_connect_state</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md316"></a>
<code>SSL_set_accept_state</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<p><b>Note:</b> Attempting to proceed in this state will not function for now because we do not implement server support at this time. However, the semantics of this function as such are unchanged.</p>
<h3><a class="anchor" id="autotoc_md317"></a>
<code>SSL_is_server</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md318"></a>
<code>SSL_connect</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error/Want   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<p>Simple composition of <code>SSL_set_connect_state</code> and <code>SSL_do_handshake</code>.</p>
<h3><a class="anchor" id="autotoc_md319"></a>
<code>SSL_accept</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error/Want   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<p>Simple composition of <code>SSL_set_accept_state</code> and <code>SSL_do_handshake</code>.</p>
<h3><a class="anchor" id="autotoc_md320"></a>
<code>SSL_do_handshake</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error/Want   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">HL   </td></tr>
</table>
<p><b>Note:</b> Idempotent if handshake already completed.</p>
<p><b>Blocking Considerations:</b> Blocks until handshake completed if in blocking mode.</p>
<h3><a class="anchor" id="autotoc_md321"></a>
<code>SSL_read</code>, <code>SSL_read_ex</code>, <code>SSL_peek</code>, <code>SSL_peek_ex</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error/Want   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p><b>Blocking Considerations:</b> Blocks until at least one byte is available or an error occurs if in blocking mode (including the peek functions).</p>
<p>If the read part of the stream has been finished by the peer, calls to <code>SSL_read</code> will fail with <code>SSL_ERROR_ZERO_RETURN</code>.</p>
<p>If a stream has terminated in a non-normal fashion (for example because the stream has been reset, or the connection has terminated), calls to <code>SSL_read</code> will fail with <code>SSL_ERROR_SSL</code>.</p>
<p><code>SSL_get_stream_read_state</code> can be used to clarify the stream state when an error occurs.</p>
<h3><a class="anchor" id="autotoc_md322"></a>
<code>SSL_write</code>, <code>SSL_write_ex</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error/Want   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>We have to implement all of the following modes:</p>
<ul>
<li><code>SSL_MODE_ENABLE_PARTIAL_WRITE</code> on or off</li>
<li><code>SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER</code> on or off</li>
<li>Blocking mode on or off</li>
</ul>
<p><b>Blocking Considerations:</b> Blocks until libssl has accepted responsibility for (i.e., copied) all data provided, or an error occurs, if in blocking mode. In other words, it blocks until it can buffer the data. This does not necessarily mean that the data has actually been sent.</p>
<p><code>SSL_get_stream_write_state</code> can be used to clarify the stream state when an error occurs.</p>
<h3><a class="anchor" id="autotoc_md323"></a>
<code>SSL_pending</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md324"></a>
<code>SSL_has_pending</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p><b>TBD.</b> Options:</p>
<ul>
<li>Semantics unchanged or approximated (essentially, <code>SSL_pending() || any RXE queued || any URXE queued</code>).</li>
<li>Change semantics to only determine the return value based on if there is data in the stream receive buffer.</li>
</ul>
<h3><a class="anchor" id="autotoc_md325"></a>
<code>SSL_shutdown</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Error   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>See <code>SSL_shutdown_ex</code> below for discussion of how this will work for QUIC.</p>
<p>Calling <code>SSL_shutdown</code> is always exactly identical in function to calling <code>SSL_shutdown_ex</code> with <code>flags</code> set to 0 and <code>args</code> set to <code>NULL</code>.</p>
<h3><a class="anchor" id="autotoc_md326"></a>
<code>SSL_clear</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TBD   </td><td class="markdownTableBodyNone">TBD   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<p>There are potential implementation hazards:</p>
<p>&gt;SSL_clear() resets the SSL object to allow for another connection. The reset &gt;operation however keeps several settings of the last sessions (some of these &gt;settings were made automatically during the last handshake). It only makes sense &gt;for a new connection with the exact same peer that shares these settings, and &gt;may fail if that peer changes its settings between connections.</p>
<p><b>TBD:</b> How should <code>SSL_clear</code> be implemented? Either:</p>
<ul>
<li>Modernised implementation which resets everything, handshake layer re-instantiated (safer);</li>
<li>Preserve <code>SSL_clear</code> semantics at the handshake layer, reset all QUIC state (<code>QUIC_CHANNEL</code> torn down, CSM reset).</li>
</ul>
<p><b>TBD:</b> Semantics of this on stream objects.</p>
<h3><a class="anchor" id="autotoc_md327"></a>
<code>SSL_free</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Changed   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p><b>QUIC stream SSL objects.</b> When used on a QUIC stream SSL object, parts of the stream state may continue to exist internally, managed inside the QUIC connection SSL object, until they can be correctly torn down, or until the QUIC connection SSL object is freed.</p>
<p>If a QUIC stream SSL object is freed for a stream which has not reached a terminal state for all of its parts (both send and receive, as applicable), the stream is automatically reset (non-normal termination) with an application error code of 0. To explicitly reset a stream with a different application error code, call <code>SSL_stream_reset</code> before calling this function.</p>
<p>If the peer continues to send data on the stream before it processes the notification of the stream's termination, that incoming data will be discarded. However, the peer will be reliably notified of the non-normal termination of the stream assuming that the connection remains healthy.</p>
<p>When freeing a QUIC stream SSL object which was terminated in a non-normal fashion, or which was terminated automatically due to a call to this function, any data which was appended to the stream via <code>SSL_write</code> may or may not have already been transmitted, and even if already transmitted, may or may not be retransmitted in the event of loss.</p>
<p>When freeing a QUIC stream SSL object which was terminated normally (for example via <code>SSL_stream_conclude</code>), data appended to the stream via <code>SSL_write</code> will still be transmitted or retransmitted as necessary, assuming that the QUIC connection SSL object is not freed and that the connection remains healthy.</p>
<p><b>QUIC connection SSL objects.</b> <code>SSL_free</code> is largely unchanged for QUIC connection SSL objects on the client side. When freeing a QUIC connection SSL object being used in client mode, there is immediate termination of any QUIC network I/O processing as the resources needed to handle the connection are immediately freed. This means that, if a QUIC connection SSL object which has not been shutdown properly is freed using this function:</p>
<ul>
<li>Any data which was pending transmission or retransmission will not be transmitted, including in streams which were terminated normally;</li>
<li><p class="startli">The connection closure process will not function correctly or in an RFC-compliant manner. Connection closure will not be signalled to the peer and the connection will simply disappear from the perspective of the peer. The connection will appear to remain active until the connection's idle timeout (if negotiated) takes effect.</p>
<p class="startli">For further discussion of this issue, see <code>SSL_shutdown_ex</code> and the Q&amp;A.</p>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md328"></a>
<code>SSL_set0_rbio</code>, <code>SSL_set0_wbio</code>, <code>SSL_set_bio</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Changed   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<p>Sets network-side BIO.</p>
<p>The changes to the semantics of these calls are as follows:</p>
<ul>
<li>The BIO MUST be a BIO with datagram semantics (this is a change relative to TLS, though not to DTLS).</li>
<li>If the BIO is non-pollable (see below), application-level blocking mode will be forced off.</li>
</ul>
<h3><a class="anchor" id="autotoc_md329"></a>
<code>SSL_set_[rw]fd</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Changed   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<p>Sets network-side socket FD.</p>
<p>Existing behaviour: Instantiates a <code>BIO_s_socket</code>, sets an FD on it, and sets it as the BIO.</p>
<p>New proposed behaviour:</p>
<ul>
<li>Instantiate a <code>BIO_s_dgram</code> instead for a QUIC connection SSL object.</li>
<li>Fails (no-op) for a QUIC stream SSL object.</li>
</ul>
<h3><a class="anchor" id="autotoc_md330"></a>
<code>SSL_get_[rw]fd</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<p>Should not require any changes.</p>
<h3><a class="anchor" id="autotoc_md331"></a>
<code>SSL_CTRL_MODE</code>, <code>SSL_CTRL_CLEAR_MODE</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Unchanged   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md332"></a>
SSL Modes</h3>
<ul>
<li><code>SSL_MODE_ENABLE_PARTIAL_WRITE</code>: Implemented. If this mode is set during a non-partial-write <code>SSL_write</code> operation spanning multiple <code>SSL_write</code> calls, this mode does not take effect until the non-partial write operation is completed.</li>
<li><code>SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER</code>: Implemented.</li>
<li><code>SSL_MODE_AUTO_RETRY</code>: TBD.</li>
<li><code>SSL_MODE_RELEASE_BUFFERS</code>: Ignored. This is an optimization and if it has any sensible semantic correspondence to QUIC, this can be considered later.</li>
<li><p class="startli"><code>SSL_MODE_SEND_FALLBACK_SCSV</code>: TBD: Either ignore or fail if the client attempts to set this prior to handshake. The latter is probably safer.</p>
<p class="startli">Ignored if set after handshake (existing behaviour).</p>
</li>
<li><code>SSL_MODE_ASYNC</code>: TBD.</li>
</ul>
<h2><a class="anchor" id="autotoc_md333"></a>
New APIs for Single-Stream Operation</h2>
<h3><a class="anchor" id="autotoc_md334"></a>
<code>SSL_handle_events</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>Advances the QUIC state machine to the extent feasible, potentially performing network I/O. Also compatible with DTLSv1 and supersedes <code>DTLSv1_handle_timeout</code> for all use cases.</p>
<h3><a class="anchor" id="autotoc_md335"></a>
<code>SSL_get_event_timeout</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>Gets the time until the QUIC state machine next wants to receive a timeout event, if any.</p>
<p>This is similar to the existing <code>DTLSv1_get_timeout</code> function, but it is not specific to DTLSv1. It is also usable for DTLSv1 and can become a protocol-agnostic API for this purpose, superseding <code>DTLSv1_get_timeout</code> for all use cases.</p>
<p>The design is similar to that of <code>DTLSv1_get_timeout</code> and uses a <code>struct timeval</code>. However, this function can also output an infinite timeout using the <code>is_infinite</code> argument, whereas whereas <code>DTLSv1_get_timeout</code> represents an infinite timeout using a 0 return value, which does not allow a failure condition to be distinguished.</p>
<h3><a class="anchor" id="autotoc_md336"></a>
<code>SSL_set_blocking_mode</code>, <code>SSL_get_blocking_mode</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>Turns blocking mode on or off. This is necessary because up until now libssl has operated in blocking or non-blocking mode automatically as an emergent consequence of whether the underlying network socket is blocking. For QUIC, this is no longer viable, thus blocking semantics at the application level must be explicitly configured.</p>
<p>Use on stream objects: It may be feasible to implement this such that different QUIC stream SSL objects can have different settings for this option.</p>
<p>Not supported for non-QUIC SSL objects.</p>
<h3><a class="anchor" id="autotoc_md337"></a>
<code>SSL_get_rpoll_descriptor</code>, <code>SSL_get_wpoll_descriptor</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>These functions output poll descriptors which can be used to determine when the QUIC state machine next needs to have events handled. <code>SSL_get_rpoll_descriptor</code> is relevant if <code>SSL_net_read_desired</code> returns 1, and <code>SSL_get_wpoll_descriptor</code> is relevant if <code>SSL_net_write_desired</code> returns 1.</p>
<p>The implementation of these functions is a simple forward to <code>BIO_get_rpoll_descriptor</code> and <code>BIO_get_wpoll_descriptor</code> on the underlying network BIOs.</p>
<p>TODO: Support these for non-QUIC SSL objects</p>
<h3><a class="anchor" id="autotoc_md338"></a>
<code>SSL_net_read_desired</code>, <code>SSL_net_write_desired</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p>These calls return 1 if the QUIC state machine is interested in receiving further data from the network, or writing to the network, respectively. The return values of these calls should be used to determine which wakeup events should cause an application to call <code>SSL_handle_events</code>. These functions do not mutate any state, and their return values may change after a call to any SSL function other than <code>SSL_net_read_desired</code>, <code>SSL_net_write_desired</code>, <code>SSL_get_rpoll_descriptor</code>, <code>SSL_get_wpoll_descriptor</code> and <code>SSL_get_event_timeout</code>.</p>
<p>TODO: Support these for non-QUIC SSL objects, turning this into a unified replacement for <code>SSL_want</code></p>
<h3><a class="anchor" id="autotoc_md339"></a>
<code>SSL_want</code>, <code>SSL_want_read</code>, <code>SSL_want_write</code></h3>
<p>The existing API <code>SSL_want</code>, and the macros defined in terms of it, are traditionally used to determine if the SSL state machine has exited in non-blocking mode due to a desire to read from or write to the underlying network BIO. However, this API is unsuitable for use with QUIC because the return value of <code>SSL_want</code> can only express one I/O direction at a time (read or write), not both. This call will not be implemented for QUIC (e.g. always returns <code>SSL_NOTHING</code>) and <code>SSL_net_read_desired</code> and <code>SSL_net_write_desired</code> will be used instead.</p>
<h3><a class="anchor" id="autotoc_md340"></a>
<code>SSL_set1_initial_peer_addr</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<p><code>SSL_set1_initial_peer_addr</code> sets the initial L4 UDP peer address for an outgoing QUIC connection.</p>
<p>The initial peer address may be autodetected if no peer address has already been set explicitly and the QUIC connection SSL object is provided with a <code>BIO_s_dgram</code> with a peer set.</p>
<p><code>SSL_set1_initial_peer_addr</code> cannot be called after a connection is established.</p>
<h3><a class="anchor" id="autotoc_md341"></a>
<code>SSL_shutdown_ex</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Error   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct  </span>ssl_shutdown_ex_args_st {</div>
<div class="line">    <span class="comment">/* These arguments pertain only to QUIC connections. */</span></div>
<div class="line">    uint64_t    quic_error_code; <span class="comment">/* [0, 2**62-1] */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *quic_reason;</div>
<div class="line">} SSL_SHUTDOWN_EX_ARGS;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SSL_SHUTDOWN_FLAG_RAPID         (1U &lt;&lt; 0)</span></div>
<div class="line"><span class="preprocessor">#define SSL_SHUTDOWN_FLAG_IMMEDIATE     (1U &lt;&lt; 1)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_shutdown_ex(SSL *ssl,</div>
<div class="line">                    uint64_t flags,</div>
<div class="line">                    <span class="keyword">const</span> SSL_SHUTDOWN_EX_ARGS *args,</div>
<div class="line">                    <span class="keywordtype">size_t</span> args_len);</div>
</div><!-- fragment --><p><code>SSL_shutdown_ex</code> is an extended version of <code>SSL_shutdown</code>.</p>
<p><code>args</code> specifies arguments which control how the SSL object is shut down. <code>args</code> are read only on the first call to <code>SSL_shutdown_ex</code> for a given SSL object and subsequent calls to <code>SSL_shutdown_ex</code> ignore the <code>args</code> argument. <code>args_len</code> should be set to <code>sizeof(*args)</code>. This function is idempotent; once the shutdown process for a SSL object is complete, further calls are a no-op and return 1.</p>
<p>Calling <code>SSL_shutdown_ex</code> on a QUIC connection SSL object causes the immediate close of the QUIC connection. “Immediate close” is as defined by RFC 9000.</p>
<p>If no QUIC connection attempt was ever initiated using the given SSL object, the QUIC connection transitions immediately to the Terminated state. Otherwise, the connection closure process is initiated if it has not already begun.</p>
<p>Any application stream data on a non-terminated or normally terminated stream which has yet to be transmitted is flushed to the network before the termination process begins. This ensures that where an application which calls <code>SSL_write</code> and performs a connection closure in a way which is considered normal to the application protocol being used, all of the data written is delivered to the peer. This behaviour may be skipped by setting the <code>SSL_SHUTDOWN_FLAG_IMMEDIATE</code> flag, in which case any data appended to streams via <code>SSL_write</code> (or any end-of-stream conditions) may not be transmitted to the peer. This flag may be useful where a non-normal application condition has occurred and the delivery of data written to streams via <code>SSL_write</code> is no longer relevant. Application stream data on streams which were terminated non-normally (for example via <code>SSL_stream_reset</code>) is not transmitted by this function.</p>
<p>A QUIC connection can be shut down using this function in two different ways:</p>
<ul>
<li><p class="startli"><b>RFC compliant mode.</b> In this mode, which provides the most robust operation, the shutdown process may take a period of time up to three times the current estimated RTT to the peer. It is possible for the closure process to complete much faster in some circumstances but this cannot be relied upon.</p>
<p class="startli">In blocking mode, the function will return once the closure process is complete. In non-blocking mode, <code>SSL_shutdown_ex</code> should be called until it returns 1, indicating the closure process is complete and the connection is now terminated.</p>
</li>
<li><p class="startli"><b>Rapid mode.</b> In this mode, a <code>CONNECTION_CLOSE</code> frame is sent in a best-effort manner and the connection is terminated immediately. If the <code>CONNECTION_CLOSE</code> frame sent is lost, the peer will not know that the connection has terminated until the negotiated idle timeout (if any) expires.</p>
<p class="startli">This will generally return 0 on success, indicating that the connection has not yet reached the Terminating state (unless it has already done so, in which case it will return 1).</p>
<p class="startli">In blocking mode, this blocks until at least one <code>CONNECTION_CLOSE</code> frame is sent but does not otherwise block. In non-blocking mode, this should be called until it returns a non-negative value. A negative value indicates failure or an I/O would-block condition.</p>
</li>
</ul>
<p>It is permissible for an application to implement a hybrid approach, for example by initiating a rapid or non-blocking shutdown and continuing to call <code>SSL_handle_events</code> for a duration it chooses.</p>
<p>If <code>SSL_SHUTDOWN_FLAG_RAPID</code> is specified in <code>flags</code>, a rapid shutdown is performed, otherwise an RFC-compliant shutdown is performed. The principal effect of this flag is to partially disable blocking behaviour in blocking mode, and the QUIC implementation will still attempt to implement the Terminating state semantics if the application happens to call <code>SSL_handle_events</code>, until it reaches the Terminated state or is freed. An application can change its mind about performing a rapid shutdown by making a subsequent call to <code>SSL_shutdown_ex</code> without the flag set.</p>
<p>Calling <code>SSL_shutdown_ex</code> on a QUIC stream SSL object is not valid; such a call will fail and has no effect. The rationale for this is that an application may well want to pass around SSL objects for individual QUIC streams to existing parts of its own code which expect something which behaves like a typical SSL object (i.e., a single bytestream); those components may well already call <code>SSL_shutdown</code> and it is not desired for such calls to affect the whole connection.</p>
<p>The <code>args-&gt;quic_error_code</code> and <code>args-&gt;reason</code> fields allow the application error code and reason string for the closure of a QUIC connection to be specified. If <code>args</code> or <code>args-&gt;reason</code> is <code>NULL</code>, a zero-length string is used for the reason. If <code>args</code> is <code>NULL</code>, an error code of 0 is used. <code>args-&gt;quic_error_code</code> must be in the range <code>[0, 2**62-1]</code>, else this function fails. These fields are ignored for SSL objects which do not represent QUIC connections.</p>
<h3><a class="anchor" id="autotoc_md342"></a>
<code>SSL_stream_conclude</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Error   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SSL_stream_conclude(SSL *ssl, uint64_t flags);</div>
</div><!-- fragment --><p><code>SSL_stream_conclude</code> signals the normal end-of-stream condition to the send part of a QUIC stream. If called on a QUIC connection SSL object with a default stream, it signals the end of that stream to the peer. If called on a QUIC stream SSL object, it signals the end of that stream to the peer.</p>
<p>This function may only be called for bidirectional streams and for outgoing unidirectional streams. It is a no-op if it has already been called for a given stream, or if either the stream or connection have entered an error state.</p>
<p>Any data already queued for transmission via a call to <code>SSL_write()</code> will still be written in a reliable manner before the end-of-stream is signalled, assuming the connection remains healthy. This function can be thought of as appending a logical end-of-stream marker after any data which has previously been written to the stream via calls to <code>SSL_write</code>. Further attempts to call <code>SSL_write</code> after calling this function will fail.</p>
<p>When calling this on a bidirectional stream, the receive part of the stream remains unaffected, and the peer may continue to send data via it until the peer also signals the end of the stream. Thus, <code>SSL_read()</code> can still be used.</p>
<p>This function is used to conclude the send part of a stream in a normal manner. To perform non-normal termination of both the sending and receiving parts of a stream, see <code>SSL_stream_reset</code>.</p>
<p><code>flags</code> is reserved and should be set to 0.</p>
<h3><a class="anchor" id="autotoc_md343"></a>
<code>SSL_stream_reset</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Error   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>ssl_stream_reset_args_st {</div>
<div class="line">    uint64_t quic_error_code; <span class="comment">/* [0, 2**62-1] */</span></div>
<div class="line">} SSL_STREAM_RESET_ARGS;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_stream_reset(SSL *ssl,</div>
<div class="line">                     <span class="keyword">const</span> SSL_STREAM_RESET_ARGS *args,</div>
<div class="line">                     <span class="keywordtype">size_t</span> args_len);</div>
</div><!-- fragment --><p>Conducts a non-normal termination of a bidirectional or outgoing unidirectional stream. For QUIC, this corresponds to a stream reset using a <code>RESET_STREAM</code> frame.</p>
<p>It may be called on either a QUIC stream SSL object or a QUIC connection SSL object with a default stream; the given stream is reset. The QUIC connection is not affected.</p>
<p>For bidirectional streams, this terminates both sending and receiving parts of the stream. It may not be called on an incoming unidirectional stream.</p>
<p>If <code>args</code> is <code>NULL</code>, an application error code of 0 is used. Otherwise, the application error code to use is specified in <code>args-&gt;quic_error_code</code>, which must be in the range <code>[0, 2**62-1]</code>. <code>args_len</code> must be set to <code>sizeof(*args)</code> if <code>args</code> is non-NULL.</p>
<p>Only the first call to this function has any effect; subsequent calls are no-ops. This is considered a success case.</p>
<h3><a class="anchor" id="autotoc_md344"></a>
<code>SSL_get_stream_state</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * e.g. Non-QUIC SSL object, or QUIC connection SSL object without a default</span></div>
<div class="line"><span class="comment"> * stream.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_NONE                   0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The read or write part of the stream is still available and has not been</span></div>
<div class="line"><span class="comment"> * terminated in a normal or non-normal manner.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_OK                     1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The stream is a unidirectional stream and this direction cannot be used; for</span></div>
<div class="line"><span class="comment"> * example, a remotely initiated unidirectional stream where</span></div>
<div class="line"><span class="comment"> * SSL_get_stream_write_state is called, or a locally initiated unidirectional</span></div>
<div class="line"><span class="comment"> * stream where SSL_get_stream_read_state is</span></div>
<div class="line"><span class="comment"> called.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_WRONG_DIR              2</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The read or write part of the stream has been finished in a normal manner.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_read_state, this means that there is no more data to read,</span></div>
<div class="line"><span class="comment"> * and that any future SSL_read calls will return any residual data waiting to</span></div>
<div class="line"><span class="comment"> * be read followed by a SSL_ERROR_ZERO_RETURN condition.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_write_state, this means that the local application has</span></div>
<div class="line"><span class="comment"> * already indicated the end of the stream by calling SSL_stream_conclude,</span></div>
<div class="line"><span class="comment"> * and that future calls to SSL_write will fail.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_FINISHED               3</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The stream was reset by the local party.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_read_state, this means that the stream was aborted using a</span></div>
<div class="line"><span class="comment"> * locally transmitted STOP_SENDING frame. Attempts to read from the stream via</span></div>
<div class="line"><span class="comment"> * SSL_read will fail, though SSL_read may allow any  residual data waiting to</span></div>
<div class="line"><span class="comment"> * be  read to be  read first.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_write_state, this means that the stream was aborted</span></div>
<div class="line"><span class="comment"> * using a locally transmitted RESET_STREAM frame. Attempts to write to</span></div>
<div class="line"><span class="comment"> * the stream will fail.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_RESET_LOCAL            4</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The stream was reset by the remote party.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_read_state, this means the peer sent a STREAM_RESET</span></div>
<div class="line"><span class="comment"> * frame for the stream.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_write_state, this means the peer sent a STOP_SENDING</span></div>
<div class="line"><span class="comment"> * frame for the stream.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_RESET_REMOTE           5</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The underlying connection supporting the stream has closed or otherwise</span></div>
<div class="line"><span class="comment"> * failed.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_read_state, this means that attempts to read from the</span></div>
<div class="line"><span class="comment"> * stream via SSL_read will fail, though SSL_read may allow any residual</span></div>
<div class="line"><span class="comment"> * data waiting to be read to be read first.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For SSL_get_stream_write_state, this means that attempts to write to the</span></div>
<div class="line"><span class="comment"> * stream will fail.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_STATE_CONN_CLOSED            6</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_get_stream_read_state(SSL *ssl);</div>
<div class="line"><span class="keywordtype">int</span> SSL_get_stream_write_state(SSL *ssl);</div>
</div><!-- fragment --><p>This API allows the current state of a stream to be queried. This allows an application to determine whether a stream is still usable and why a stream has reached an error state.</p>
<h3><a class="anchor" id="autotoc_md345"></a>
<code>SSL_get_stream_read_error_code</code>, <code>SSL_get_stream_write_error_code</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SSL_get_stream_read_error_code(SSL *ssl, uint64_t *app_error_code);</div>
<div class="line"><span class="keywordtype">int</span> SSL_get_stream_write_error_code(SSL *ssl, uint64_t *app_error_code);</div>
</div><!-- fragment --><p><code>SSL_get_stream_read_error_code</code> gets the error code for the read part of the stream.</p>
<p><code>SSL_get_stream_write_error_code</code> gets the error code for the write part of the stream.</p>
<p>If a stream has been terminated normally, returns 0.</p>
<p>If a stream has been terminated non-normally, returns 1 and writes the applicable application error code to <code>*app_error_code</code>.</p>
<p>If a stream is still healthy, or was healthy at the time the connection was closed, or the respective part of the stream does not exist (e.g. for a unidirectional stream), returns -1.</p>
<h3><a class="anchor" id="autotoc_md346"></a>
<code>SSL_get_conn_close_info</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="preprocessor">#define SSL_CONN_CLOSE_FLAG_LOCAL</span></div>
<div class="line"><span class="preprocessor">#define SSL_CONN_CLOSE_FLAG_TRANSPORT</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>ssl_conn_close_info_st {</div>
<div class="line">    uint64_t error_code;</div>
<div class="line">    <span class="keywordtype">char</span>     *reason;</div>
<div class="line">    <span class="keywordtype">size_t</span>   reason_len;</div>
<div class="line">    uint32_t flags;</div>
<div class="line">} SSL_CONN_CLOSE_INFO;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_get_conn_close_info(SSL *ssl,</div>
<div class="line">                            SSL_CONN_CLOSE_INFO *info,</div>
<div class="line">                            <span class="keywordtype">size_t</span> info_len);</div>
</div><!-- fragment --><p>If a connection is still healthy, returns 0. Otherwise, fills <code>*info</code> with information about the error causing connection termination and returns 1. <code>info_len</code> must be set to <code>sizeof(*info)</code>. Returns -1 if called on a non-QUIC SSL object or if the connection status cannot be determined.</p>
<p><code>info-&gt;reason</code> is set to point to a buffer containing a reason string. The buffer is valid for the lifetime of the SSL object. The reason string will always be zero terminated, but since it is received from a potentially untrusted peer, may also contain zero bytes. <code>info-&gt;reason_len</code> is the true length of the reason string in bytes.</p>
<p><code>info-&gt;flags</code> has <code>SSL_CONN_CLOSE_FLAG_LOCAL</code> set if the connection closure was locally initiated.</p>
<p><code>info-&gt;flags</code> has <code>SSL_CONN_CLOSE_FLAG_TRANSPORT</code> if the connection closure was initiated by QUIC, and 0 if it was initiated by the application. The namespace of <code>info-&gt;error_code</code> is determined by this parameter.</p>
<h2><a class="anchor" id="autotoc_md347"></a>
New APIs for Multi-Stream Operation</h2>
<p>The above new APIs are built on constructively to facilitate multi-stream operation.</p>
<p>The concept of a QUIC stream SSL object is introduced. A QUIC SSL object is either a QUIC connection SSL object or a QUIC stream SSL object. A QUIC stream SSL object belongs to a QUIC connection SSL object. A QUIC connection SSL object may or may not have an associated default stream. There may only be at most one default stream for a QUIC connection SSL object. Reading or writing application data to a QUIC connection SSL object with a default stream is equivalent to reading or writing to that stream. It is an error to attempt to read or write application data, or perform other stream-specific operations, on a QUIC connection SSL object without a default stream associated.</p>
<h3><a class="anchor" id="autotoc_md348"></a>
Notes on Multi-Threaded Operation</h3>
<p>Initially these APIs will not be thread safe over the same connection, but in the longer term we intend to support multiple threads using different QUIC stream SSL objects on different threads over the same connection without the application having to do any locking. This is referred to as multi-stream multi-thread (MSMT) operation. Only APIs explicitly denoted below will eventually be MSMT-safe.</p>
<h3><a class="anchor" id="autotoc_md349"></a>
Notes on Blocking</h3>
<p>The blocking mode can be configured on each SSL object individually. When a QUIC stream SSL object is created it inherits its blocking state from the currently configured blocking state of the QUIC connection SSL object at the time the stream is created. This can be changed independently. For example, a QUIC connection SSL object can be in blocking mode to allow for blocking <code>SSL_accept_stream</code> calls, yet have some or all QUIC stream SSL objects be in non-blocking mode concurrently.</p>
<h3><a class="anchor" id="autotoc_md350"></a>
Notes on Application-Level Polling</h3>
<p>An API may be added in the future to allow applications to poll multiple QUIC connection SSL objects efficiently for new stream and stream readability events. This is not yet urgent but will be more relevant for concurrent server applications.</p>
<h3><a class="anchor" id="autotoc_md351"></a>
<code>SSL_get0_connection</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Get the SSL object representing the connection associated with this object.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * If the SSL object represents a non-QUIC method or a QUIC connection, this</span></div>
<div class="line"><span class="comment"> * returns the same object passed.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * If the SSL object represents a QUIC stream returns the QUIC connection</span></div>
<div class="line"><span class="comment"> * object.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">SSL *SSL_get0_connection(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md352"></a>
<code>SSL_is_connection</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">CS   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Returns 1 if the object represents a connection. This always returns 1 for</span></div>
<div class="line"><span class="comment"> * non-QUIC methods, but returns 0 for SSL objects for QUIC streams which are</span></div>
<div class="line"><span class="comment"> * not also the QUIC connection object.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This is exactly equivalent to (SSL_get0_connection(ssl) == ssl).</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> SSL_is_connection(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md353"></a>
<code>SSL_get_stream_type</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * If the object represents a stream, returns a SSL_STREAM_TYPE value</span></div>
<div class="line"><span class="comment"> * designating whether the stream can be used for transmission, reception,</span></div>
<div class="line"><span class="comment"> * or both.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This always returns SSL_STREAM_TYPE_BIDI for non-QUIC methods.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * It returns SSL_STREAM_TYPE_NONE for a QUIC connection object if it</span></div>
<div class="line"><span class="comment"> * does not have a default stream.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_TYPE_NONE    0</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_TYPE_READ    1</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_TYPE_WRITE   2</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_TYPE_BIDI    (SSL_STREAM_TYPE_READ | SSL_STREAM_TYPE_WRITE)</span></div>
<div class="line">__owur <span class="keywordtype">int</span> SSL_get_stream_type(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md354"></a>
<code>SSL_get_stream_id</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * QUIC: Returns the unique stream ID for the stream, an integer in range [0, 2**62-1],</span></div>
<div class="line"><span class="comment"> * or UINT64_MAX if the stream ID is not available. If called on a QUIC</span></div>
<div class="line"><span class="comment"> * connection, returns the unique stream ID for the default stream if there is</span></div>
<div class="line"><span class="comment"> * one, and otherwise returns UINT64_MAX.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * TLS, DTLS: Returns UINT64_MAX.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">__owur uint64_t SSL_get_stream_id(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md355"></a>
<code>SSL_is_stream_local</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">S   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * QUIC: Returns 1 if the stream was locally initiated, or 0 otherwise.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * TLS, DTLS: Returns -1.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">__owur <span class="keywordtype">int</span> SSL_is_stream_local(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md356"></a>
<code>SSL_new_stream</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Create a new SSL object representing a single additional stream.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * There is no need to call SSL_connect on the resulting object, and</span></div>
<div class="line"><span class="comment"> * any such call is a no-op.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For QUIC:</span></div>
<div class="line"><span class="comment"> *   Creates a new stream. Must be called only on a QUIC connection SSL object.</span></div>
<div class="line"><span class="comment"> *   Can be used on client or server. If the SSL_STREAM_FLAG_UNI flag is set,</span></div>
<div class="line"><span class="comment"> *   the created stream is unidirectional, otherwise it is bidirectional.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   To be MSMT-safe.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For TLS and DTLS SSL objects:</span></div>
<div class="line"><span class="comment"> *   Always fails.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_STREAM_FLAG_UNI    1</span></div>
<div class="line"> </div>
<div class="line">SSL *SSL_new_stream(SSL *ssl, uint64_t flags);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md357"></a>
<code>SSL_accept_stream</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Create a new SSL object representing an additional stream which was created</span></div>
<div class="line"><span class="comment"> * by the peer.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * There is no need to call SSL_accept on the resulting object, and</span></div>
<div class="line"><span class="comment"> * any such call is a no-op.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For QUIC:</span></div>
<div class="line"><span class="comment"> *   Must be called only on a QUIC connection SSL object. Fails if called on a</span></div>
<div class="line"><span class="comment"> *   stream object. Checks if a new stream has been created by the peer. If it</span></div>
<div class="line"><span class="comment"> *   has, creates a new SSL object to represent it and returns it. Otherwise,</span></div>
<div class="line"><span class="comment"> *   returns NULL. If multiple streams are available to be accepted, the oldest</span></div>
<div class="line"><span class="comment"> *   stream (that is, the stream with the lowest stream ID) is accepted.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For all other methods:</span></div>
<div class="line"><span class="comment"> *   Returns NULL.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The flags argument is unused and should be set to zero.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * To be MSMT-safe (i.e., can be called from multiple threads).</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * If the QUIC connection SSL object is configured in blocking mode, this</span></div>
<div class="line"><span class="comment"> * function will block unless the SSL_ACCEPT_STREAM_NO_BLOCK flag is passed.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This function returns NULL if the effective incoming stream reject policy is</span></div>
<div class="line"><span class="comment"> * `REJECT`.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_ACCEPT_STREAM_NO_BLOCK      1</span></div>
<div class="line"> </div>
<div class="line">SSL *SSL_accept_stream(SSL *ssl, uint64_t flags);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md358"></a>
<code>SSL_get_accept_stream_queue_len</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Determine the number of streams waiting to be returned on a subsequent call</span></div>
<div class="line"><span class="comment"> * to SSL_accept_stream. If this returns a non-zero value, the next call to</span></div>
<div class="line"><span class="comment"> * SSL_accept_stream (on any thread) is guaranteed to work. Returns 0 for</span></div>
<div class="line"><span class="comment"> * non-QUIC objects, or for QUIC stream objects.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * To be MSMT-safe.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> SSL_get_accept_stream_queue_len(SSL *ssl);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md359"></a>
<code>SSL_set_incoming_stream_policy</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Sets the policy for incoming streams. If `policy` is `AUTO` (the default):</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   - if the default stream mode is</span></div>
<div class="line"><span class="comment"> *     `SSL_DEFAULT_STREAM_MODE_AUTO_BIDI` or</span></div>
<div class="line"><span class="comment"> *     `SSL_DEFAULT_STREAM_MODE_AUTO_UNI`, this is equivalent to `REJECT`;</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   - otherwise, this is equivalent to `ACCEPT`.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * If configured to `ACCEPT`, incoming streams are placed on the accept queue</span></div>
<div class="line"><span class="comment"> * for application consumption. `aec` is ignored in this case.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * If configured to `REJECT`, incoming streams automatically have both their</span></div>
<div class="line"><span class="comment"> * receiving and sending parts handled via non-normal termination. `aec` is an</span></div>
<div class="line"><span class="comment"> * application error code used for the `STOP_SENDING` and `RESET_STREAM` frames</span></div>
<div class="line"><span class="comment"> * used for the purposes of this termination. The default AEC value used if this</span></div>
<div class="line"><span class="comment"> * function is never called is 0.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_INCOMING_STREAM_POLICY_AUTO      0</span></div>
<div class="line"><span class="preprocessor">#define SSL_INCOMING_STREAM_POLICY_ACCEPT    1</span></div>
<div class="line"><span class="preprocessor">#define SSL_INCOMING_STREAM_POLICY_REJECT    2</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_set_incoming_stream_policy(SSL *ssl, <span class="keywordtype">int</span> policy, uint64_t aec);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md360"></a>
<code>SSL_set_default_stream_mode</code></h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone"><code>SSL_get_error</code>   </th><th class="markdownTableHeadNone">Can Tick?   </th><th class="markdownTableHeadNone">CSHL    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">New   </td><td class="markdownTableBodyNone">Never   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">C   </td></tr>
</table>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Used to control single stream operation. Calling this function determines the</span></div>
<div class="line"><span class="comment"> * nature of the default stream which will automatically be created on the QUIC</span></div>
<div class="line"><span class="comment"> * connection SSL object.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The default mode is `SSL_DEFAULT_STREAM_MODE_AUTO_BIDI`.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The modes are as follows:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   - `SSL_DEFAULT_STREAM_MODE_NONE`: No default stream will ever be created.</span></div>
<div class="line"><span class="comment"> *     The application is assumed to understand multi-stream operation.</span></div>
<div class="line"><span class="comment"> *     Remotely-initiated streams are placed in the accept queue for application</span></div>
<div class="line"><span class="comment"> *     consumption. `SSL_read` and `SSL_write` calls must be made on a QUIC</span></div>
<div class="line"><span class="comment"> *     stream SSL object, not the QUIC connection SSL object, as no default</span></div>
<div class="line"><span class="comment"> *     stream will be associated with it.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   - `SSL_DEFAULT_STREAM_MODE_AUTO_BIDI`: &quot;First stream wins&quot; mode of</span></div>
<div class="line"><span class="comment"> *     operation for single-stream usage. If `SSL_write` is called before the</span></div>
<div class="line"><span class="comment"> *     peer opens a remotely-initiated stream, a locally-initiated bidirectional</span></div>
<div class="line"><span class="comment"> *     stream is created and bound as the default stream. If the peer opens a</span></div>
<div class="line"><span class="comment"> *     remotely-initiated stream before the local application calls `SSL_write`</span></div>
<div class="line"><span class="comment"> *     (with `len &gt; 0`) for the first time, that stream is bound as the default</span></div>
<div class="line"><span class="comment"> *     stream, which may be bidirectional or unidirectional; if it is</span></div>
<div class="line"><span class="comment"> *     unidirectional, calls to `SSL_write` will fail. Attempts to create</span></div>
<div class="line"><span class="comment"> *     additional streams by the peer are automatically rejected unless</span></div>
<div class="line"><span class="comment"> *     the application opts in (API TBD).</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   - `SSL_DEFAULT_STREAM_MODE_AUTO_UNI`: &quot;First stream wins&quot; mode of</span></div>
<div class="line"><span class="comment"> *     operation for single-stream usage, with a unidirectional stream. This</span></div>
<div class="line"><span class="comment"> *     functions identically to `SSL_DEFAULT_STREAM_MODE_AUTO_BIDI`, but if the</span></div>
<div class="line"><span class="comment"> *     local application calls `SSL_write` prior to the peer creating a</span></div>
<div class="line"><span class="comment"> *     remotely-initiated stream, a unidirectional TX-only stream is created and</span></div>
<div class="line"><span class="comment"> *     bound as the default stream. Thereafter, calls to `SSL_read` will fail.</span></div>
<div class="line"><span class="comment"> *     If the peer creates a remotely-initiated stream prior to the first call</span></div>
<div class="line"><span class="comment"> *     to `SSL_write` (with `len &gt; 0`), that stream will be bound as the default</span></div>
<div class="line"><span class="comment"> *     stream; note that a bidirectional stream may be bound in this case.</span></div>
<div class="line"><span class="comment"> *     Attempts to create additional streams by the peer are automatically</span></div>
<div class="line"><span class="comment"> *     rejected unless the application opts in (API TBD).</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This function must be called before a default stream object is created, for</span></div>
<div class="line"><span class="comment"> * example before initiating a connection. If the function is too late to have</span></div>
<div class="line"><span class="comment"> * an effect, this function fails and returns 0.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define SSL_DEFAULT_STREAM_MODE_NONE                0</span></div>
<div class="line"><span class="preprocessor">#define SSL_DEFAULT_STREAM_MODE_AUTO_BIDI           1</span></div>
<div class="line"><span class="preprocessor">#define SSL_DEFAULT_STREAM_MODE_AUTO_UNI            2</span></div>
<div class="line"> </div>
<div class="line">__owur <span class="keywordtype">int</span> SSL_set_default_stream_mode(SSL *ssl, uint32_t mode);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md361"></a>
Future APIs</h2>
<p>A custom poller interface may be provided in the future. For more information, see the QUIC I/O Architecture design document.</p>
<h1><a class="anchor" id="autotoc_md362"></a>
BIO Objects</h1>
<h2><a class="anchor" id="autotoc_md363"></a>
Existing APIs</h2>
<h3><a class="anchor" id="autotoc_md364"></a>
<code>BIO_s_connect</code>, <code>BIO_new_ssl_connect</code>, <code>BIO_set_conn_hostname</code></h3>
<p>We are aiming to support use of the existing <code>BIO_new_ssl_connect</code> API with only minimal changes. This will require internal changes to <code>BIO_s_connect</code>, which should automatically detect when it is being used with a QUIC <code>SSL_CTX</code> and act accordingly.</p>
<h3><a class="anchor" id="autotoc_md365"></a>
<code>BIO_new_bio_pair</code></h3>
<p>Unsuitable for use with QUIC on the network side; instead, applications can make use of the new <code>BIO_s_dgram_pair</code> which provides equivalent functionality with datagram semantics.</p>
<h3><a class="anchor" id="autotoc_md366"></a>
Interactions with <code>BIO_f_buffer</code></h3>
<p>Existing applications sometimes combine a network socket BIO with a <code>BIO_f_buffer</code>. This is problematic because the datagram semantics of writes are not preserved, therefore the BIO provided to libssl is, as provided, unusable for the purposes of implementing QUIC. Moreover, output buffering is not a relevant or desirable performance optimisation for the transmission of UDP datagrams and will actually undermine QUIC performance by causing incorrect calculation of ACK delays and consequently inaccurate RTT calculation.</p>
<p>Options:</p>
<ul>
<li>Require applications to be changed to not use QUIC with a <code>BIO_f_buffer</code>.</li>
<li>Detect when a <code>BIO_f_buffer</code> is part of a BIO stack and bypass it (yucky and surprising).</li>
</ul>
<h3><a class="anchor" id="autotoc_md367"></a>
MTU Signalling</h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_dgram_pair.html">BIO_s_dgram_pair(3)</a></p>
<p><code>BIO_dgram_get_mtu</code> (<code>BIO_CTRL_DGRAM_GET_MTU</code>) and <code>BIO_dgram_set_mtu</code> (<code>BIO_CTRL_DGRAM_SET_MTU</code>) already exist for <code>BIO_s_dgram</code> and are implemented on a <code>BIO_s_dgram_pair</code> to allow the MTU to be determined and configured. One side of a pair can configure the MTU to allow the other side to detect it.</p>
<p><code>BIO_s_dgram</code> also has pre-existing support for getting the correct MTU value from the OS using <code>BIO_CTRL_DGRAM_QUERY_MTU</code>.</p>
<h2><a class="anchor" id="autotoc_md368"></a>
New APIs</h2>
<h3><a class="anchor" id="autotoc_md369"></a>
<code>BIO_sendmmsg</code> and <code>BIO_recvmmsg</code></h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_sendmmsg.html">BIO_sendmmsg(3)</a></p>
<p>The BIO interface features a new high-performance API for the execution of multiple read or write operations in a single system call, on supported OSes. On other OSes, a compatible fallback implementation is used.</p>
<p>Unlike all other BIO APIs, this API is intended for concurrent threaded use and as such operates in a stateless fashion with regards to a BIO. This means, for example, that retry indications are made using explicit API inputs and outputs rather than setting an internal flag on the BIO.</p>
<p>This new BIO API includes:</p>
<ul>
<li>Local address support (getting the destination address of an incoming packet; setting the source address of an outgoing packet), where support for this is available;</li>
<li>Peer address support (setting the destination address of an outgoing packet; getting the source address of an incoming packet), where support for this is available.</li>
</ul>
<p>The following functionality was intentionally left out of this design because not all OSes can provide support:</p>
<ul>
<li>Iovecs (which have also been determined not to be necessary for a performant QUIC implementation);</li>
<li>Features such as <code>MSG_DONTWAIT</code>, etc.</li>
</ul>
<p>This BIO API is intended to be extensible. For more information on this API, see BIO_sendmmsg(3) and BIO_recvmmsg(3).</p>
<p>Custom BIO implementers may set their own implementation of these APIs via corresponding <code>BIO_meth</code> getter/setter functions.</p>
<h3><a class="anchor" id="autotoc_md370"></a>
Truncation Mode</h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_dgram_pair.html">BIO_s_dgram_pair(3)</a></p>
<p>The controls <code>BIO_dgram_set_no_trunc</code> (<code>BIO_CTRL_DGRAM_SET_NO_TRUNC</code>) and <code>BIO_dgram_get_no_trunc</code> (<code>BIO_CTRL_DGRAM_GET_NO_TRUNC</code>) are introduced. This is a boolean value which may be implemented by BIOs with datagram semantics. When enabled, attempting to receive a datagram such that the datagram would ordinarily be truncated (as per the design of the Berkeley sockets API) instead results in a failure. This is intended for implementation by <code>BIO_s_dgram_pair</code>. For compatibility, the default behaviour is off.</p>
<h3><a class="anchor" id="autotoc_md371"></a>
Capability Negotiation</h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_dgram_pair.html">BIO_s_dgram_pair(3)</a></p>
<p>Where a <code>BIO_s_dgram_pair</code> is used, there is the potential for such a memory BIO to be used by existing application code which is being adapted for use with QUIC. A problem arises whereby one end of a <code>BIO_s_dgram_pair</code> (for example, the side being used by OpenSSL's QUIC implementation) may assume that the other end supports certain capabilities (for example, specifying a peer address), when in actual fact the opposite end of the <code>BIO_s_dgram_pair</code> does not.</p>
<p>A capability signalling mechanism is introduced which allows one end of a <code>BIO_s_dgram_pair</code> to indicate to the user of the opposite BIO the following capabilities and related information:</p>
<ul>
<li>Whether source addresses the peer specifies will be processed.</li>
<li>Whether destination addresses the peer specifies will be processed.</li>
<li>Whether source addresses will be provided to the opposite BIO when it receives datagrams.</li>
<li>Whether destination addresses will be provided to the opposite BIO when it receives datagrams.</li>
</ul>
<p>The usage is as follows:</p>
<ul>
<li>One side of a BIO pair calls <code>BIO_dgram_set_caps</code> with zero or more of the following flags to advertise its capabilities:<ul>
<li><code>BIO_DGRAM_CAP_HANDLES_SRC_ADDR</code></li>
<li><code>BIO_DGRAM_CAP_HANDLES_DST_ADDR</code></li>
<li><code>BIO_DGRAM_CAP_PROVIDES_SRC_ADDR</code></li>
<li><code>BIO_DGRAM_CAP_PROVIDES_DST_ADDR</code></li>
</ul>
</li>
<li>The other side of the BIO pair calls <code>BIO_dgram_get_effective_caps</code> to learn the effective capabilities of the BIO. These are the capabilities set by the opposite BIO.</li>
<li>The above process can also be repeated in the opposite direction.</li>
</ul>
<h3><a class="anchor" id="autotoc_md372"></a>
Local Address Support</h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_dgram_pair.html">BIO_s_dgram_pair(3)</a></p>
<p>Support for local addressing (the reception of destination addresses for incoming packets, and the specification of source addresses for outgoing packets) varies by OS. Thus, it may not be available in all circumstances. A feature negotiation mechanism is introduced to facilitate this.</p>
<p><code>BIO_dgram_get_local_addr_cap</code> (<code>BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP</code>) determines if a BIO is potentially capable of supporting local addressing on the current platform. If it determines that support is available, local addressing support must then be explicitly enabled via <code>BIO_dgram_set_local_addr_enable</code> (<code>BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE</code>). If local addressing support has not been enabled, attempts to use local addressing (for example via <code>BIO_sendmmsg</code> or <code>BIO_recvmmsg</code> with a <code>BIO_MSG</code> with a non-NULL <code>local</code> field) fails.</p>
<p>An explicit enablement call is required because setting up local addressing support requires system calls on most operating systems prior to sending or receiving packets and we do not wish to do this automatically inside the <code>BIO_sendmmsg</code>/<code>BIO_recvmmsg</code> fastpaths, particularly since the process of enabling support could fail due to lack of OS support, etc.</p>
<p><code>BIO_dgram_get_local_addr_enable</code> (<code>BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE</code>) is also available.</p>
<p>It is important to note that <code>BIO_dgram_get_local_addr_cap</code> is entirely distinct from the application capability negotiation mechanism discussed above. Whereas the capability negotiation mechanism discussed above allows <em>applications</em> to signal what they are capable of handling in their usage of a given BIO, <code>BIO_dgram_local_addr_cap</code> allows a <em>BIO implementation</em> to indicate to the users of that BIO whether it is able to support local addressing (where enabled).</p>
<h3><a class="anchor" id="autotoc_md373"></a>
<code>BIO_s_dgram_pair</code></h3>
<p><b>See also:</b> <a href="https://www.openssl.org/docs/manmaster/man3/BIO_s_dgram_pair.html">BIO_s_dgram_pair(3)</a></p>
<p>A new BIO implementation, <code>BIO_s_dgram_pair</code>, is provided. This is similar to the existing BIO pair but provides datagram semantics. It provides full support for the new APIs <code>BIO_sendmmsg</code>, <code>BIO_recvmmsg</code>, the capability negotiation mechanism described above, local address support and the MTU signalling mechanism described above.</p>
<p>It can be instantiated using the new API <code>BIO_new_dgram_pair</code>.</p>
<h3><a class="anchor" id="autotoc_md374"></a>
<code>BIO_POLL_DESCRIPTOR</code></h3>
<p>The concept of <em>poll descriptors</em> are introduced. A poll descriptor is a tagged union structure which represents an abstraction over some unspecified kind of OS descriptor which can be used for synchronization and waiting.</p>
<p>The most commonly used kind of poll descriptor is one which describes a network socket (i.e., on POSIX-like platforms, a file descriptor), however other kinds of poll descriptor may be defined.</p>
<p>A BIO may be queried for whether it has a poll descriptor for read or write operations respectively:</p>
<ul>
<li>Where <code>BIO_get_rpoll_descriptor</code> (<code>BIO_CTRL_GET_RPOLL_DESCRIPTOR</code>) is called, the BIO should output a poll descriptor which describes a resource which can be used to determine when the BIO will next become readable via a call to <code>BIO_read</code> or, if supported by the BIO, <code>BIO_recvmmsg</code>.</li>
<li>Where <code>BIO_get_wpoll_descriptor</code> (<code>BIO_CTRL_GET_WPOLL_DESCRIPTOR</code>) is called, the BIO should output a poll descriptor which describes a resource which can be used to determine when the BIO will next become writeable via a call to <code>BIO_write</code> or, if supported by the BIO, <code>BIO_sendmmsg</code>.</li>
</ul>
<p>A BIO may not necessarily be able to provide a poll descriptor. For example, memory-based BIOs such as <code>BIO_s_dgram_pair</code> do not correspond to any OS synchronisation resource, and thus the <code>BIO_get_rpoll_descriptor</code> and <code>BIO_get_wpoll_descriptor</code> calls are not supported for such BIOs.</p>
<p>A BIO which supports these functions is known as pollable, and a BIO which does not is known as non-pollable. <code>BIO_s_dgram</code> supports these functions.</p>
<p>The implementation of these functions for a <code>BIO_f_ssl</code> forwards to <code>SSL_get_rpoll_descriptor</code> and <code>SSL_get_wpoll_descriptor</code> respectively. The</p>
<h3><a class="anchor" id="autotoc_md375"></a>
<code>BIO_s_dgram_mem</code></h3>
<p>This is a basic memory buffer BIO with datagram semantics. Unlike <code>BIO_s_dgram_pair</code>, it is unidirectional and does not support peer addressing or local addressing.</p>
<h3><a class="anchor" id="autotoc_md376"></a>
<code>BIO_err_is_non_fatal</code></h3>
<p>A new predicate function <code>BIO_err_is_non_fatal</code> is defined which determines if an error code represents a non-fatal or transient error. For details, see <a href="https://www.openssl.org/docs/manmaster/man3/BIO_sendmmsg.html">BIO_sendmmsg(3)</a>.</p>
<h1><a class="anchor" id="autotoc_md377"></a>
Q &amp; A</h1>
<p>To assist in understanding, when a “TBD” listed above is removed, or when a relevant question is raised, the resolution to the question will be placed here.</p>
<p><b>Q. Should <code>SSL_do_handshake</code> wait until the handshake is completed, or until it is confirmed?</b></p>
<p><b>Note:</b> [The terms <em>handshake complete</em> and <em>handshake confirmed</em> are defined in RFC 9001 and have specific meanings.](<a href="https://www.rfc-editor.org/rfc/rfc9001.html#name-handshake-complete">https://www.rfc-editor.org/rfc/rfc9001.html#name-handshake-complete</a>)</p>
<p>A. <code>SSL_do_handshake</code> should wait until the handshake is completed, because handshake completion represents the completion of the cryptographic authentication of the connection. When a connection's handshake is completed, TLS 1.3 Finished messages have been exchanged by both parties, even if the handshake has not yet been <em>confirmed</em>. Moreover, RFC 9001 s. 4.1.2 states:</p>
<p>&gt;Additionally, a client MAY consider the handshake to be confirmed when it &gt;receives an acknowledgment for a 1-RTT packet.</p>
<p>This logically implies that it is OK for a client to start transmitting 1-RTT packets prior to handshake confirmation, otherwise there would be no in-flight 1-RTT packets for the client to receive ACKs for.</p>
<p><b>Q. Does <code>ENABLE_PARTIAL_WRITE</code> interact with blocking mode?</b></p>
<p>A. No; this mode is only relevant to non-blocking mode. In blocking mode, <code>SSL_write</code> always waits until all data is written unless an error occurs. The semantics of <code>SSL_write</code> are preserved unchanged.</p>
<p><b>Q. Does <code>SSL_write</code> block until data is written to the network, or simply until it is buffered?</b></p>
<p>A. <code>SSL_write</code> blocks until it has accepted responsibility for the data passed to it, just like <code>write(2)</code> or <code>send(2)</code>. In other words, it blocks until it can buffer the data. This does not necessarily mean that the data has actually been sent.</p>
<p><b>Q. How should connection closure work?</b></p>
<p>A. <b>RFC requirements.</b> After we begin terminating the connection by sending a <code>CONNECTION_CLOSE</code> frame, QUIC requires that we continue to process network I/O for a certain period of time so that any further traffic from the peer results in generation of a further <code>CONNECTION_CLOSE</code> frame. This is necessary to handle the possibility that the <code>CONNECTION_CLOSE</code> frame which was initially sent may be lost.</p>
<p><b>API issues.</b> This creates a complication because it implies that the connection closure process may take a fair amount of time, whereas existing API users will generally expect to be able to call <code>SSL_shutdown</code> and then immediately free the SSL object.</p>
<p>However, if the caller immediately frees the SSL object, this precludes our implementing the applicable logic, at least on the client side. Moreover, existing API users are likely to tear down underlying network BIOs immediately after calling <code>SSL_free</code> anyway. In other words, any implementation based on secretly keeping QUIC state around after a call to <code>SSL_free</code> does not seem particularly workable on the client side.</p>
<p><b>Server side considerations.</b> There is more of a prospect here on the server side, since multiple connections will share the same socket, which will presumably be associated with some kind of enduring listener object. Thus when server support is implemented in the future connection teardown could be handled internally by maintaining the state of connections undergoing termination inside the listener object. However, similar caveats to those discussed here arise when the listener object itself is to be town down. (It is also possible we could optionally allow use of the server-style API to make multiple outgoing client connections with a non-zero-length client-side CID on the same underlying network BIO.)</p>
<p>There are only really two ways to handle this:</p>
<ul>
<li><p class="startli"><b>RFC conformant mode.</b> <code>SSL_shutdown</code> only indicates that shutdown is complete once the the entire connection closure process is complete.</p>
<p class="startli">This process consists of the Closing and Draining states. In some cases the Closing state may last only briefly, namely if the peer chooses to respond to our <code>CONNECTION_CLOSE</code> frame with a <code>CONNECTION_CLOSE</code> frame of its own. This allows immediate progression to the Draining state. However, a peer is <em>not</em> required to respond with such a frame. Thus in the worst case, this state can be as long as <code>3*PTO</code>; for example a peer with a high estimated RTT of 300ms would have us wait for 900ms.</p>
<p class="startli">In the Draining state we simply ignore all incoming traffic and do not generate outgoing traffic. The purpose of this state is to simply tie up the socket and ensure any data still in flight is discarded. However, RFC 9000 states:</p>
<p class="startli">Disposing of connection state prior to exiting the closing or draining state could result in an endpoint generating a Stateless Reset unnecessarily when it receives a late-arriving packet. Endpoints that have some alternative means to ensure that late-arriving packets do not induce a response, such as those that are able to close the UDP socket, MAY end these states earlier to allow for faster resource recovery. Servers that retain an open socket for accepting new connections SHOULD NOT end the closing or draining state early</p>
<p class="startli">Because our client mode implementation uses one socket per connection, it appears to be reasonable based on the above text to omit the implementation of the draining state (the same may not be the case for the server role when implemented in the future).</p>
<p class="startli">Thus, in general, <code>SSL_shutdown</code> can be expected to take about one round trip's time to complete when dealing with a peer whose QUIC implementation happens to respond to a <code>CONNECTION_CLOSE</code> frame with a <code>CONNECTION_CLOSE</code> frame of its own, and about three round trips otherwise.</p>
</li>
<li><b>Rapid shutdown mode.</b> <code>SSL_shutdown</code> sends a <code>CONNECTION_CLOSE</code> frame once and completes immediately. The Closing and Draining states are not used, and if the <code>CONNECTION_CLOSE</code> frame was lost, the peer will have to wait for idle timeout to determine that the connection is gone (there is also the possibility that, if the socket is closed by the application after teardown, a peer will make something of ICMP Port Unreachable messages, but this is unlikely to be reliable and since this message is not authenticated, QUIC implementations probably shouldn't pay much attention to it anyway.)</li>
</ul>
<p>There is little problem with <code>SSL_shutdown</code> taking as long as it needs to for some long-running applications, but for others it poses a real issue. For example, a command-line tool which makes one connection, performs one application-specific transaction, and then tears down the connection. In this case an RFC-conformant connection termination would essentially require the process to hang around for a substantial amount of time after the work of the process is done.</p>
<p>For this reason, it is concluded that both of these shutdown modes need to be offered.</p>
<p>Where connection closure is initiated remotely rather than locally, only the draining state is relevant. Since we conclude above that we do not need to implement the draining state on the client side, this means that connection closure can be completed immediately in the case of a remote closure.</p>
<p><b>Q. Should we just map <code>SSL_handle_events</code> to <code>DTLS_CTRL_HANDLE_TIMEOUT</code> internally?</b></p>
<p>A. No, since the infinite time representation is different between the two calls.</p>
<p><b>Q. How should <code>STOP_SENDING</code> be supported?</b></p>
<p>We trigger <code>STOP_SENDING</code> automatically if an application frees the associated QUIC stream SSL object.</p>
<p><b>Q. Can data be received on a locally initiated bidirectional stream before any data is sent on that stream?</b></p>
<p>This is an interesting question without a clear answer to be found in the QUIC RFCs. A close reading of RFC 9000 suggests that the answer is, in principle, yes; however the RFC also grants explicit permission to make design choices in implementations which would preclude this:</p>
<p>&gt;An implementation might choose to defer allocating a stream ID to a stream until &gt;it sends the first STREAM frame and enters this state, which can allow for &gt;better stream prioritization.</p>
<p>If an ID has not been allocated to a stream, obviously incoming data cannot be addressed to it. However, supposing that an implementation does not do this, RFC 9000 seems basically clear that it is valid for an application to create a stream locally, then receive data on it before sending anything:</p>
<p>&gt;The sending part of a stream that the endpoint initiates (types 0 and 2 for &gt;clients, 1 and 3 for servers) is opened by the application. The "Ready" &gt;state represents a newly created stream that is able to accept data from the &gt;application. </p><blockquote class="doxtable">
<p>&zwj; </p>
</blockquote>
<p>&gt;[...] </p><blockquote class="doxtable">
<p>&zwj; </p>
</blockquote>
<p>&gt;For a bidirectional stream, the receiving part enters the "Recv" state when &gt;the sending part initiated by the endpoint (type 0 for a client, type 1 for &gt;a server) enters the "Ready" state.</p>
<p>A peer is not generally notified of the creation of a stream which has not sent any data yet, since the creation of a stream is signalled only implicitly via the transmission of data in <code>STREAM</code> frames. However, a zero-length STREAM frame could presumably be used to effect such a notification. RFC 9000 contains no specific discussion of this possibility but does not preclude it. As such, in order to receive data on a locally-initiated bidirectional stream before sending any data on that stream, it would be necessary to either</p>
<ul>
<li>Use a QUIC implementation which signals a bidirectional stream which has not yet sent any data via a zero-length stream frame, or</li>
<li>Use an application protocol which can inform the peer of the stream ID of the created stream in some application protocol-specific way. This is somewhat less plausible because it would require an API between the application and its QUIC library to inform the QUIC library that the peer has in fact created a stream with a given ID and to take its word for it. This is unlikely to be commonly available, especially as application errors in usage of such an API would lead to internal inconsistencies in QUIC connection state.</li>
</ul>
<p>Of course this discussion is somewhat esoteric as it is unclear why an application would want to create a locally-initiated stream and then have the peer transmit on it first, rather than simply use a remotely-initiated stream. Thus this discussion of this edge case is more of a curiosity, however for completeness it needs to be thought about in the API design.</p>
<p><b>Q. How should single-stream operation support locally and remotely-initiated streams?</b></p>
<p>Note that the ID of a stream depends on whether it is bidirectional and whether it is initiated by the client or server. Therefore, in single stream operation, it is necessary to know whether single-stream QUIC is being used with client-initiated or server-initiated stream initiation, and whether a bidirectional or unidirectional stream is being used; otherwise, we do not know which stream ID to bind to.</p>
<p>The object of single stream operation is to support simple uses cases for simple applications. There seems no need to support esoteric usage of streams such as receiving first on a locally initiated stream here, thus we avoid supporting this to simplify the API.</p>
<p>As such, an application which calls <code>SSL_write</code> on a QUIC connection SSL object before it calls <code>SSL_read</code> by definition is using a locally-initiated stream, and an application which does the opposite is using a remotely-initiated stream. We can use the ordering of initial calls to <code>SSL_read</code> and <code>SSL_write</code> to infer the desired stream type.</p>
<p>Supporting locally-initiated streams (<code>SSL_write</code> called first) is simple; we automatically create the stream and queue data for transmission.</p>
<p>Supporting remotely-initiated streams (<code>SSL_read</code> called first) is a little stranger. We could create the stream with the correct ID when cued to by the initial call to <code>SSL_read</code> implying use of a remotely-initiated stream. However, this would mean we are creating state tracking a remotely-initiated stream before the peer has signalled it. This would work in the happy case where the client is connected to a compatible server but may result in strange inconsistencies of QUIC internal state if a client is accidentally connected to an incompatible peer. Since the peer ought to be the authority on the streams it creates, this seems like an undesirable approach.</p>
<p>Ergo, creation of a default remotely-initiated stream needs to be deferred until the <em>peer</em> signals such a stream.</p>
<p>This leads naturally to a "first stream wins" model of implementation:</p>
<ul>
<li>When a QUIC connection SSL object is created, default stream mode is enabled, meaning that a default stream will be bound to the QUIC connection SSL object at the earliest available opportunity. However, no default stream is bound yet.</li>
<li>One of the following events happened — whichever happens first wins:<ul>
<li>The local application calls <code>SSL_write()</code> (<code>len &gt; 0</code>). A locally-initiated stream with ordinal 0 is created. The stream is bidirectional by default but this can be changed. This stream is bound as the default stream.</li>
<li>The peer creates a stream. This stream is bound as the default stream.</li>
</ul>
</li>
</ul>
<p>If the local application calls <code>SSL_read()</code> before either of the above occur, <code>SSL_read()</code> fails as though no data is available until one of the above events occurs.</p>
<p>Once one of the above events occurs, any additional stream created by the peer is automatically terminated using both <code>STOP_SENDING</code> and <code>STREAM_RESET</code> frames (to terminate both the receiving and sending parts respectively) and there is no API-visible effect to the local application (unless the application explicitly opts into supporting additional streams). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
