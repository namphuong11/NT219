<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: Error handling in QUIC code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Error handling in QUIC code</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md270"></a>
Current situation with TLS</h1>
<p>The errors are put on the error stack (rather a queue but error stack is used throughout the code base) during the libssl API calls. In most (if not all) cases they should appear there only if the API call returns an error return value. The <code>SSL_get_error()</code> call depends on the stack being clean before the API call to be properly able to determine if the API call caused a library or system (I/O) error.</p>
<p>The error stacks are thread-local. Libssl API calls from separate threads push errors to these separate error stacks. It is unusual to invoke libssl APIs with the same SSL object from different threads, but even if it happens, it is not a problem as applications are supposed to check for errors immediately after the API call on the same thread. There is no such thing as Thread-assisted mode of operation.</p>
<h1><a class="anchor" id="autotoc_md271"></a>
Constraints</h1>
<p>We need to keep using the existing ERR API as doing otherwise would complicate the existing applications and break our API compatibility promise. Even the ERR_STATE structure is public, although deprecated, and thus its structure and semantics cannot be changed.</p>
<p>The error stack access is not under a lock (because it is thread-local). This complicates <em>moving errors between threads</em>.</p>
<p>Error stack entries contain allocated data, copying entries between threads implies duplicating it or losing it.</p>
<h1><a class="anchor" id="autotoc_md272"></a>
Assumptions</h1>
<p>This document assumes the actual error state of the QUIC connection (or stream for stream level errors) is handled separately from the auxiliary error reason entries on the error stack.</p>
<p>We can assume the internal assistance thread is well-behaving in regards to the error stack.</p>
<p>We assume there are two types of errors that can be raised in the QUIC library calls and in the subordinate libcrypto (and provider) calls. First type is an intermittent error that does not really affect the state of the QUIC connection - for example EAGAIN returned on a syscall, or unavailability of some algorithm where there are other algorithms to try. Second type is a permanent error that affects the error state of the QUIC connection. Operations on QUIC streams (SSL_write(), SSL_read()) can also trigger errors, depending on their effect they are either permanent if they cause the QUIC connection to enter an error state, or if they just affect the stream they are left on the error stack of the thread that called SSL_write() or SSL_read() on the stream.</p>
<h1><a class="anchor" id="autotoc_md273"></a>
Design</h1>
<p>Return value of SSL_get_error() on QUIC connections or streams does not depend on the error stack contents.</p>
<p>Intermittent errors are handled within the library and cleared from the error stack before returning to the user.</p>
<p>Permanent errors happening within the assist thread, within SSL_tick() processing, or when calling SSL_read()/SSL_write() on a stream need to be replicated for SSL_read()/SSL_write() calls on other streams.</p>
<h1><a class="anchor" id="autotoc_md274"></a>
Implementation</h1>
<p>There is an error stack in QUIC_CHANNEL which serves as temporary storage for errors happening in the internal assistance thread. When a permanent error is detected the error stack entries are moved to this error stack in QUIC_CHANNEL.</p>
<p>When returning to an application from a SSL_read()/SSL_write() call with a permanent connection error, entries from the QUIC_CHANNEL error stack are copied to the thread local error stack. They are always kept on the QUIC_CHANNEL error stack as well for possible further calls from an application. An additional error reason SSL_R_QUIC_CONNECTION_TERMINATED is added to the stack.</p>
<h1><a class="anchor" id="autotoc_md275"></a>
SSL_tick() return value</h1>
<p>The return value of SSL_tick() does not depend on whether there is a permanent error on the connection. The only case when SSL_tick() may return an error is when there was some fatal error processing it such as a memory allocation error where no further SSL_tick() calls make any sense.</p>
<h1><a class="anchor" id="autotoc_md276"></a>
Multi-stream-multi-thread mode</h1>
<p>There is nothing particular that needs to be handled specially for multi-stream-multi-thread mode as the error stack entries are always copied from the QUIC_CHANNEL after the failure. So if multiple threads are calling SSL_read()/SSL_write() simultaneously they all get the same error stack entries to report to the user. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
