<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC Frame-in-Flight Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC Frame-in-Flight Management</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The QUIC frame-in-flight manager is responsible for tracking frames which were sent which need to be regenerated if the packets they were placed into are designated as lost by the ACK manager. The ACK manager works on the level of packets, whereas the QUIC frame-in-flight manager (FIFM) works on the level of frames.</p>
<p>The FIFM comprises three components, collectively known as the FIFM:</p>
<ul>
<li>the Control Frame Queue (CFQ);</li>
<li>the Transmitted Packet Information Manager (TXPIM); and</li>
<li>the Frame-in-Flight Dispatcher (FIFD).</li>
</ul>
<p><img src="images/quic-fifm-overview.png" alt="" title="QUIC FIFM Overview" class="inline"/></p>
<p>These are introduced in turn below, but first we discuss the various QUIC frame types to establish the need for each component.</p>
<h1><a class="anchor" id="autotoc_md397"></a>
Analysis of QUIC Frame Retransmission Requirements</h1>
<h2><a class="anchor" id="autotoc_md398"></a>
Frame Types</h2>
<p>Standard QUIC uses the following frame types:</p>
<div class="fragment"><div class="line">HANDSHAKE_DONE          GCR / REGEN</div>
<div class="line">MAX_DATA                      REGEN</div>
<div class="line">DATA_BLOCKED                  REGEN</div>
<div class="line">MAX_STREAMS                   REGEN</div>
<div class="line">STREAMS_BLOCKED               REGEN</div>
<div class="line">NEW_CONNECTION_ID             GCR</div>
<div class="line">RETIRE_CONNECTION_ID          GCR</div>
<div class="line">PATH_CHALLENGE                  -</div>
<div class="line">PATH_RESPONSE                   -</div>
<div class="line">ACK                             -        (non-ACK-eliciting)</div>
<div class="line">CONNECTION_CLOSE              special    (non-ACK-eliciting)</div>
<div class="line">NEW_TOKEN                     GCR</div>
<div class="line">CRYPTO                        GCR or special</div>
<div class="line">RESET_STREAM                  REGEN</div>
<div class="line">STOP_SENDING                  REGEN</div>
<div class="line">MAX_STREAM_DATA               REGEN</div>
<div class="line">STREAM_DATA_BLOCKED           REGEN</div>
<div class="line">STREAM                        special</div>
<div class="line">PING                           -</div>
<div class="line">PADDING                        -         (non-ACK-eliciting)</div>
</div><!-- fragment --><p>The different frame types require various different ways of handling retransmission in the event of loss:</p>
<ul>
<li><b>GCR</b> (Generic Control Frame Retransmission): The raw bytes of the encoded frame can simply be sent again. This retransmission system does not need to understand the specific frame type. A simple queue can be used, with each queue entry being an octet string representing an encoded frame. This queue can also be used for initial transmission of <b>GCR</b> frames, not just retransmissions.</li>
<li><b>REGEN</b> (Regenerate): These frames can be marked for dynamic regeneration when a packet containing them is lost. This has the advantage of using up-to-date data at the time of transmission, so is preferred over <code>GCR</code> when possible.</li>
<li>Special — <code>STREAM</code>, <code>CRYPTO</code>: <code>STREAM</code> frame handling is handled as a special case by the QUIC Send Stream Manager. <code>CRYPTO</code> frame retransmission can also be handled using a QUIC Send Stream manager. (<code>CRYPTO</code> frames could also be handled via GCR, though suboptimally. We choose to use proper send stream management, just as for application data streams.)</li>
<li>Some frame types do not need to be retransmitted even if lost (<code>PING</code>, <code>PADDING</code>, <code>PATH_CHALLENGE</code>, <code>PATH_RESPONSE</code>).</li>
<li>Special — <code>CONNECTION_CLOSE</code>: This frame is a special case and is not retransmitted per se.</li>
</ul>
<h2><a class="anchor" id="autotoc_md399"></a>
Requirements</h2>
<p>The following requirements are identified:</p>
<ul>
<li>Need for a generic control queue which can store encoded control frames. This control queue will handle both initial transmission and retransmission of most control frames which do not have special requirements.</li>
<li>The ability to determine, when the ACK Manager determines that a packet has been acknowledged, lost or discarded:<ul>
<li><p class="startli">What stream IDs were sent in a packet, and the logical ranges of application data bytes for each (which may not be one contiguous range).</p>
<p class="startli">This is needed so that the QUIC Send Stream Manager for a given stream can be informed of lost or acked ranges in the stream.</p>
</li>
<li>The logical ranges of the CRYPTO stream which were sent in the packet (which may not be one contiguous range), for similar reasons.</li>
<li><p class="startli">Which stream IDs had a FIN bit set in the packet.</p>
<p class="startli">This is needed so that the QUIC Send Stream Manager can be informed for a given stream whether a FIN was lost or acked.</p>
</li>
<li>What control frames using the <b>GCR</b> strategy were sent in the packet so that they can be requeued (if lost) or released (if acked or discarded).</li>
<li>For each type of frame using the <b>REGEN</b> strategy, a flag as to whether that frame type was contained in the packet (so that the flag can be set again if the packet was lost).</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md400"></a>
The Control Frame Queue (CFQ)</h1>
<p><img src="images/quic-fifm-cfq.png" alt="" title="QUIC CFQ Overview" class="inline"/></p>
<p>The CFQ (<code>QUIC_CFQ</code>) stores encoded frames which can be blindly retransmitted in the event that they are lost. It facilitates the GCR retransmission strategy. One logical CFQ instance will be needed per PN space per connection. As an optimisation, these three CFQ instances per connection are all modelled by a single <code>QUIC_CFQ</code> instance.</p>
<p>Each frame in the CFQ is a simple opaque byte buffer, which has the following metadata associated with it:</p>
<ul>
<li>An integral priority value, used to maintain priority ordering.</li>
<li>The frame type, which is provided by the caller along with the buffer. This can be determined from the encoded frame buffer, but this saves the CFQ's users from needing to decode it. The CFQ itself does not use this value.</li>
<li>A state, which is either <code>NEW</code> or <code>TX</code>. Frames added to the CFQ have the <code>NEW</code> state initially. When the frame is transmitted, it is transitioned to the <code>TX</code> state. If the packet it was sent in is subsequently lost, it is transitioned back to the <code>NEW</code> state.</li>
</ul>
<p>Frames in the <code>NEW</code> state participate in a priority queue (the NEW queue) according to their priority and the CFQ's NEW queue can be iterated in priority order by callers.</p>
<p>When a packet containing a CFQ item is acknowledged, the CFQ is informed and the CFQ item is released. A free callback provided when the buffer was added to the CFQ is called, providing an opportunity to free or reuse the buffer. Buffers provided to the CFQ as part of a CFQ item must remain allocated for the duration of their membership of the CFQ. The CFQ maintains memory allocation of CFQ items themselves internally.</p>
<h2><a class="anchor" id="autotoc_md401"></a>
API</h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * QUIC Control Frame Queue Item</span></div>
<div class="line"><span class="comment"> * =============================</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The CFQ item structure has a public and a private part. This structure</span></div>
<div class="line"><span class="comment"> * documents the public part.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__cfq__item__st.html">quic_cfq_item_st</a> <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structquic__cfq__item__st.html">quic_cfq_item_st</a> {</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * These fields are not used by the CFQ, but are a convenience to assist the</span></div>
<div class="line"><span class="comment">     * TXPIM in keeping a list of GCR control frames which were sent in a</span></div>
<div class="line"><span class="comment">     * packet. They may be used for any purpose.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a>  *pkt_prev, *pkt_next;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* All other fields are private; use ossl_quic_cfq_item_* accessors. */</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define QUIC_CFQ_STATE_NEW      0</span></div>
<div class="line"><span class="preprocessor">#define QUIC_CFQ_STATE_TX       1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Returns the frame type of a CFQ item. */</span></div>
<div class="line">uint64_t ossl_quic_cfq_item_get_frame_type(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Returns a pointer to the encoded buffer of a CFQ item. */</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ossl_quic_cfq_item_get_encoded(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Returns the length of the encoded buffer in bytes. */</span></div>
<div class="line"><span class="keywordtype">size_t</span> ossl_quic_cfq_item_get_encoded_len(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Returns the CFQ item state, a QUIC_CFQ_STATE_* value. */</span></div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_cfg_item_get_state(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Returns the PN space for the CFQ item. */</span></div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_cfg_item_get_pn_space(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * QUIC Control Frame Queue</span></div>
<div class="line"><span class="comment"> * ========================</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__cfq__st.html">quic_cfq_st</a> <a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *ossl_quic_cfq_new(<span class="keywordtype">void</span>);</div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_cfq_free(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Input Side</span></div>
<div class="line"><span class="comment"> * ----------</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Enqueue a frame to the CFQ. encoded points to the opaque encoded frame.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * free_cb is called by the CFQ when the buffer is no longer needed;</span></div>
<div class="line"><span class="comment"> * free_cb_arg is an opaque value passed to free_cb.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * priority determines the relative ordering of control frames in a packet.</span></div>
<div class="line"><span class="comment"> * Higher numerical values for priority mean that a frame should come earlier in</span></div>
<div class="line"><span class="comment"> * a packet. pn_space is a QUIC_PN_SPACE_* value.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * On success, returns a QUIC_CFQ_ITEM pointer which acts as a handle to</span></div>
<div class="line"><span class="comment"> * the queued frame. On failure, returns NULL.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The frame is initially in the TX state, so there is no need to call</span></div>
<div class="line"><span class="comment"> * ossl_quic_cfq_mark_tx() immediately after calling this function.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The frame type is duplicated as the frame_type argument here, even though it</span></div>
<div class="line"><span class="comment"> * is also encoded into the buffer. This allows the caller to determine the</span></div>
<div class="line"><span class="comment"> * frame type if desired without having to decode the frame.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> void (cfq_free_cb)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> buf_len, <span class="keywordtype">void</span> *arg);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *ossl_quic_cfq_add_frame(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a>            *cfq,</div>
<div class="line">                                       uint32_t             priority,</div>
<div class="line">                                       uint32_t             pn_space,</div>
<div class="line">                                       uint64_t             frame_type,</div>
<div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *encoded,</div>
<div class="line">                                       <span class="keywordtype">size_t</span>               encoded_len,</div>
<div class="line">                                       cfq_free_cb         *free_cb,</div>
<div class="line">                                       <span class="keywordtype">void</span>                *free_cb_arg);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Effects an immediate transition of the given CFQ item to the TX state.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_cfq_mark_tx(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq, <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Effects an immediate transition of the given CFQ item to the NEW state,</span></div>
<div class="line"><span class="comment"> * allowing the frame to be retransmitted. If priority is not UINT32_MAX,</span></div>
<div class="line"><span class="comment"> * the priority is changed to the given value.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_cfq_mark_lost(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq, <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item,</div>
<div class="line">                             uint32_t priority);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Releases a CFQ item. The item may be in either state (NEW or TX) prior to the</span></div>
<div class="line"><span class="comment"> * call. The QUIC_CFQ_ITEM pointer must not be used following this call.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_cfq_release(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq, <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Output Side</span></div>
<div class="line"><span class="comment"> * -----------</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Gets the highest priority CFQ item in the given PN space awaiting</span></div>
<div class="line"><span class="comment"> * transmission. If there are none, returns NULL.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *ossl_quic_cfq_get_priority_head(<a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq, uint32_t pn_space);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Given a CFQ item, gets the next CFQ item awaiting transmission in priority</span></div>
<div class="line"><span class="comment"> * order in the given PN space. In other words, given the return value of</span></div>
<div class="line"><span class="comment"> * ossl_quic_cfq_get_priority_head(), returns the next-lower priority item.</span></div>
<div class="line"><span class="comment"> * Returns NULL if the given item is the last item in priority order.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *ossl_quic_cfq_item_get_priority_next(<a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item,</div>
<div class="line">                                                    uint32_t pn_space);</div>
<div class="ttc" id="astructquic__cfq__item__st_html"><div class="ttname"><a href="structquic__cfq__item__st.html">quic_cfq_item_st</a></div><div class="ttdef"><b>Definition</b> quic_cfq.h:27</div></div>
<div class="ttc" id="astructquic__cfq__st_html"><div class="ttname"><a href="structquic__cfq__st.html">quic_cfq_st</a></div><div class="ttdef"><b>Definition</b> quic_cfq.c:73</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md402"></a>
The Transmitted Packet Information Manager (TXPIM)</h1>
<p><img src="images/quic-fifm-txpim.png" alt="" title="QUIC TXPIM Overview" class="inline"/></p>
<p>The Transmitted Packet Information Manager (<code>QUIC_TXPIM</code>) is responsible for allocating and keeping bookkeeping structures for packets which have been transmitted, but not yet acknowledged, deemed lost or discarded. It is a self-contained memory pool handing out <code>QUIC_TXPIM_PKT</code> structures. Each <code>QUIC_TXPIM_PKT</code> is a self-contained data structure intended for consumption by the FIFM.</p>
<p>The <code>QUIC_TXPIM_PKT</code> structure can be used for:</p>
<ul>
<li>Keeping track of all GCR control frames which were transmitted in each packet, via a linked list of <code>QUIC_CFQ_ITEM</code>s.</li>
<li>Keeping track of all REGEN-strategy control frame types, via a flag for each frame type indicating whether the packet contained such a frame.</li>
<li>Keeping track of all stream IDs sent in a given packet, and what ranges of the logical stream were sent, and whether a FIN was sent.</li>
<li>Keeping track of what logical ranges of the CRYPTO stream were sent.</li>
</ul>
<p>In order to avoid unnecessary allocations, the FIFM also incorporates the ACK Manager's <code>QUIC_ACKM_TX_PKT</code> structure into its per-packet bookkeeping structure. The intention is for the <code>QUIC_TXPIM_PKT</code> to be the principal allocation made per transmitted packet. The TX packetiser will obtain a <code>QUIC_TXPIM_PKT</code> structure from the TXPIM, fill in the structure including the ACK Manager data, and submit it via the FIFD which we introduce below.</p>
<p>The TXPIM does do not anything with the <code>QUIC_TXPIM_PKT</code> structure itself other than managing its allocation and manipulation. Constructive use of the data kept in the TXPIM is made by the FIFD.</p>
<h2><a class="anchor" id="autotoc_md403"></a>
API</h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * QUIC Transmitted Packet Information Manager</span></div>
<div class="line"><span class="comment"> * ===========================================</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__txpim__st.html">quic_txpim_st</a> <a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__txpim__pkt__st.html">quic_txpim_pkt_st</a> {</div>
<div class="line">    <span class="comment">/* ACKM-specific data. Caller should fill this. */</span></div>
<div class="line">    QUIC_ACKM_TX_PKT    ackm_pkt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Linked list of CFQ items in this packet. */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a>      *retx_head;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Reserved for FIFD use. */</span></div>
<div class="line">    <a class="code hl_struct" href="structquic__fifd__st.html">QUIC_FIFD</a>          *fifd;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Regenerate-strategy frames. */</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        had_handshake_done          : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        had_max_data_frame          : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        had_max_streams_bidi_frame  : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        had_max_streams_uni_frame   : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        had_ack_frame               : 1;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Private data follows. */</span></div>
<div class="line">} <a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Represents a range of bytes in an application or CRYPTO stream. */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__txpim__chunk__st.html">quic_txpim_chunk_st</a> {</div>
<div class="line">    <span class="comment">/* The stream ID, or UINT64_MAX for the CRYPTO stream. */</span></div>
<div class="line">    uint64_t        stream_id;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * The inclusive range of bytes in the stream. Exceptionally, if end &lt;</span></div>
<div class="line"><span class="comment">     * start, designates a frame of zero length (used for FIN-only frames).</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    uint64_t        start, end;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Whether a FIN was sent for this stream in the packet. Not valid for</span></div>
<div class="line"><span class="comment">     * CRYPTO stream.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    has_fin : 1;</div>
<div class="line">} <a class="code hl_struct" href="structquic__txpim__chunk__st.html">QUIC_TXPIM_CHUNK</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *ossl_quic_txpim_new(<span class="keywordtype">void</span>);</div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_txpim_free(<a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *txpim);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Allocates a new QUIC_TXPIM_PKT structure from the pool. Returns NULL on</span></div>
<div class="line"><span class="comment"> * failure. The returned structure is cleared of all data and is in a fresh</span></div>
<div class="line"><span class="comment"> * initial state.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *ossl_quic_txpim_pkt_alloc(<a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *txpim);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Releases the TXPIM packet, returning it to the pool.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_txpim_pkt_release(<a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *txpim, <a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Clears the chunk list of the packet, removing all entries. */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_txpim_pkt_clear_chunks(<a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Appends a chunk to the packet. The structure is copied. */</span></div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_txpim_pkt_append_chunk(<a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code hl_struct" href="structquic__txpim__chunk__st.html">QUIC_TXPIM_CHUNK</a> *chunk);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Adds a CFQ item to the packet by prepending it to the retx_head list. */</span></div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_txpim_pkt_add_cfq_item(<a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt,</div>
<div class="line">                                      <a class="code hl_struct" href="structquic__cfq__item__st.html">QUIC_CFQ_ITEM</a> *item);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Returns a pointer to an array of stream chunk information structures for the</span></div>
<div class="line"><span class="comment"> * given packet. The caller must call ossl_quic_txpim_pkt_get_num_chunks() to</span></div>
<div class="line"><span class="comment"> * determine the length of this array.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The chunks are sorted by (stream_id, start) in ascending order.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structquic__txpim__chunk__st.html">QUIC_TXPIM_CHUNK</a> *ossl_quic_txpim_pkt_get_chunks(<a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Returns the number of entries in the array returned by</span></div>
<div class="line"><span class="comment"> * ossl_quic_txpim_pkt_get_chunks().</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> ossl_quic_txpim_pkt_get_num_chunks(<a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *fpkt);</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Returns the number of QUIC_TXPIM_PKTs allocated by the given TXPIM that have</span></div>
<div class="line"><span class="comment"> * yet to be returned to the TXPIM.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">size_t</span> ossl_quic_txpim_get_in_use(<a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *txpim);</div>
<div class="ttc" id="astructquic__fifd__st_html"><div class="ttname"><a href="structquic__fifd__st.html">quic_fifd_st</a></div><div class="ttdef"><b>Definition</b> quic_fifd.h:26</div></div>
<div class="ttc" id="astructquic__txpim__chunk__st_html"><div class="ttname"><a href="structquic__txpim__chunk__st.html">quic_txpim_chunk_st</a></div><div class="ttdef"><b>Definition</b> quic_txpim.h:49</div></div>
<div class="ttc" id="astructquic__txpim__pkt__st_html"><div class="ttname"><a href="structquic__txpim__pkt__st.html">quic_txpim_pkt_st</a></div><div class="ttdef"><b>Definition</b> quic_txpim.h:27</div></div>
<div class="ttc" id="astructquic__txpim__st_html"><div class="ttname"><a href="structquic__txpim__st.html">quic_txpim_st</a></div><div class="ttdef"><b>Definition</b> quic_txpim.c:27</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md404"></a>
The Frame-in-Flight Dispatcher (FIFD)</h1>
<p>Finally, the CFQ, TXPIM and some interfaces to the ACKM are tied together via the FIFD (<code>QUIC_FIFD</code>). The FIFD is completely stateless and provides reasonable implementations for the on-loss, on-acked and on-discarded callbacks issued by the ACK Manager.</p>
<p>The FIFD is used by obtaining a packet structure from the TXPIM, filling it in, and then calling <code>ossl_quic_fifd_pkt_commit()</code>. The FIFD submits the packet to the ACK Manager as a transmitted packet and provides its own callback implementations to the ACK Manager for the packet. Note that the <code>QUIC_TXPIM_PKT</code> is returned to the free pool once any of these callbacks occur; once a packet's fate is known (acked, lost or discarded), use is immediately made of the information in the <code>QUIC_TXPIM_PKT</code> and the <code>QUIC_TXPIM_PKT</code> is immediately released. CFQ items may be freed (on ACK or discard) or transitioned back to the NEW state (on loss).</p>
<p>The FIFD consumes various dependencies so that it can inform the appropriate subsystems in the event of a packet being acked, lost or discarded. In particular:</p>
<ul>
<li>It references a CFQ used to manage CFQ items;</li>
<li>It references an ACK manager which it informs of transmitted packets;</li>
<li>It references a TXPIM which manages each <code>QUIC_TXPIM_PKT</code>;</li>
<li>It is provided with a callback to obtain a QUIC Send Stream based on a stream ID. Thus the caller of the FIFD may implement whatever strategy it likes to map stream IDs to QUIC Send Stream instances.</li>
<li>It is provided with a callback which is called when it thinks a frame should be regenerated using the REGEN strategy. Some of these are specific to a given stream, in which case a stream ID is specified.</li>
</ul>
<p>All of the state is in the dependencies referenced by the FIFD. The FIFD itself simply glues all of these parts together.</p>
<h2><a class="anchor" id="autotoc_md405"></a>
API</h2>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__fifd__st.html">quic_fifd_st</a> {</div>
<div class="line">  <span class="comment">/* (internals) */</span></div>
<div class="line">} <a class="code hl_struct" href="structquic__fifd__st.html">QUIC_FIFD</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_fifd_init(<a class="code hl_struct" href="structquic__fifd__st.html">QUIC_FIFD</a> *fifd,</div>
<div class="line">                        <a class="code hl_struct" href="structquic__cfq__st.html">QUIC_CFQ</a> *cfq,</div>
<div class="line">                        QUIC_ACKM *ackm,</div>
<div class="line">                        <a class="code hl_struct" href="structquic__txpim__st.html">QUIC_TXPIM</a> *txpim,</div>
<div class="line">                        <span class="comment">/* stream_id is UINT64_MAX for the crypto stream */</span></div>
<div class="line">                        OSSL_QSS *(*get_qss_by_id)(uint64_t stream_id,</div>
<div class="line">                                                   <span class="keywordtype">void</span> *arg),</div>
<div class="line">                        <span class="keywordtype">void</span> *get_qss_by_id_arg,</div>
<div class="line">                        <span class="comment">/* stream_id is UINT64_MAX if not applicable */</span></div>
<div class="line">                        <span class="keywordtype">void</span> (*regen_frame)(uint64_t frame_type,</div>
<div class="line">                                            uint64_t stream_id,</div>
<div class="line">                                            <span class="keywordtype">void</span> *arg),</div>
<div class="line">                        <span class="keywordtype">void</span> *regen_frame_arg);</div>
<div class="line"><span class="keywordtype">void</span> ossl_quic_fifd_cleanup(<a class="code hl_struct" href="structquic__fifd__st.html">QUIC_FIFD</a> *fifd); <span class="comment">/* (no-op) */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ossl_quic_fifd_pkt_commit(<a class="code hl_struct" href="structquic__fifd__st.html">QUIC_FIFD</a> *fifd, <a class="code hl_struct" href="structquic__txpim__pkt__st.html">QUIC_TXPIM_PKT</a> *pkt);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md406"></a>
Typical Intended TX Packetiser Usage</h1>
<ul>
<li>TX Packetiser maintains flags for each REGEN-strategy frame type. It sets this flag when the regenerate callback is issued by the FIFD and clears it when transmitting a packet containing such a frame.</li>
<li>TX Packetiser obtains a <code>QUIC_TXPIM_PKT</code> structure by calling <code>ossl_quic_txpim_pkt_alloc()</code>.</li>
<li>TX Packetiser fills in the ACKM part of the <code>QUIC_TXPIM_PKT</code> (<code>QUIC_ACKM_TX_PKT</code>), except for the callback fields, which are handled by the FIFD.</li>
<li>TX Packetiser queries the ACK Manager to determine if an ACK frame is desired, and if so adds it to the packet.</li>
<li>TX Packetiser queries the CFQ to determine what control frames it places in a packet. It does this before adding STREAM or CRYPTO frames (i.e., all CFQ frames are considered of higher priority). For each such frame it places in a packet, it:<ul>
<li>calls <code>ossl_quic_txpim_pkt_add_cfq_item()</code> on the TXPIM to log the CFQ item as having been transmitted in the given packet, so that the CFQ item can be released or requeued depending on the ultimate fate of the packet.</li>
</ul>
</li>
<li>For each STREAM or CRYPTO frame included in a packet, the TX Packetiser:<ul>
<li>informs the QUIC Send Stream instance for that stream that a range of bytes has been transmitted;</li>
<li>also informs the QUIC Send Stream instance if FIN was set on a STREAM frame.</li>
<li>calls <code>ossl_quic_txpim_pkt_append_chunk()</code> to log a logical range of the given application or crypto stream as having been sent, so that it can be subsequently marked as acknowledged or lost depending on the ultimate fate of the packet.</li>
</ul>
</li>
<li><p class="startli">TX Packetiser calls <code>ossl_quic_fifd_pkt_commit()</code>. The FIFD takes care of submitting the packet to the ACK Manager and provides its own callback implementation. It also takes care of informing the CFQ that any CFQ items which were added via <code>ossl_quic_txpim_pkt_add_cfq_item()</code> have been transmitted.</p>
<p class="startli">In the event of packet loss, ACK or discard, the appropriate QUIC Send Stream, CFQ and regenerate callback calls are made. Regardless of the outcome, the TXPIM is released. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
