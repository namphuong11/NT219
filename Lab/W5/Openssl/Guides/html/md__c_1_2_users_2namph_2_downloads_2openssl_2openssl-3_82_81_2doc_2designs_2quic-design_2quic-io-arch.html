<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC I/O Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC I/O Architecture</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document discusses possible implementation options for the I/O architecture internal to the libssl QUIC implementation, discusses the underlying design constraints driving this decision and introduces the resulting I/O architecture. It also identifies potential hazards to existing applications, and identifies how those hazards are mitigated.</p>
<h1><a class="anchor" id="autotoc_md407"></a>
Objectives</h1>
<p>The <a class="el" href="md__c_1_2_users_2namph_2_downloads_2openssl_2openssl-3_82_81_2doc_2designs_2quic-design_2quic-requirements.html">requirements for QUIC</a> which have formed the basis for implementation include the following requirements:</p>
<ul>
<li>The application must have the ability to be in control of the event loop without requiring callbacks to process the various events. An application must also have the ability to operate in “blocking” mode.</li>
<li>High performance applications (primarily server based) using existing libssl APIs; using custom network interaction BIOs in order to get the best performance at a network level as well as OS interactions (IO handling, thread handling, using fibres). Would prefer to use the existing APIs - they don’t want to throw away what they’ve got. Where QUIC necessitates a change they would be willing to make minor changes.</li>
</ul>
<p>As such, there are several objectives for the I/O architecture of the QUIC implementation:</p>
<ul>
<li>We want to support both blocking and non-blocking semantics for application use of the libssl APIs.</li>
<li>In the case of non-blocking applications, it must be possible for an application to do its own polling and make its own event loop.</li>
<li>We want to support custom BIOs on the network side and to the extent feasible, minimise the level of adaptation needed for any custom BIOs already in use on the network side. More generally, the integrity of the BIO abstraction layer should be preserved.</li>
</ul>
<h1><a class="anchor" id="autotoc_md408"></a>
QUIC-Related Requirements</h1>
<p>Note that implementation of QUIC will require that the underlying network BIO passed to the QUIC implementation be configured to support datagram semantics instead of bytestream semantics as has been the case with traditional TLS over TCP. This will require applications using custom BIOs on the network side to make substantial changes to the implementation of those custom BIOs to model datagram semantics. These changes are not minor, but there is no way around this requirement.</p>
<p>It should also be noted that implementation of QUIC requires handling of timer events as well as the circumstances where a network socket becomes readable or writable. In many cases we need to handle these events simultaneously (e.g. wait until a socket becomes readable, or writable, or a timeout expires, whichever comes first).</p>
<p>Note that the discussion in this document primarily concerns usage of blocking vs. non-blocking I/O in the interface between the QUIC implementation and an underlying BIO provided to the QUIC implementation to provide it access to the network. This is independent of and orthogonal to the application interface to libssl, which will support both blocking and non-blocking I/O.</p>
<h1><a class="anchor" id="autotoc_md409"></a>
Blocking vs. Non-Blocking Modes in Underlying Network BIOs</h1>
<p>The above constraints make it effectively a requirement that non-blocking I/O be used for the calls to the underlying network BIOs. To illustrate this point, we first consider how QUIC might be implemented using blocking network I/O internally.</p>
<p>To function correctly and provide blocking semantics at the application level, our QUIC implementation must be able to block such that it can respond to any of the following events for the underlying network read and write BIOs immediately:</p>
<ul>
<li>The underlying network write BIO becomes writeable;</li>
<li>The underlying network read BIO becomes readable;</li>
<li>A timeout expires.</li>
</ul>
<h2><a class="anchor" id="autotoc_md410"></a>
Blocking sockets and select(3)</h2>
<p>Firstly, consider how this might be accomplished using the Berkeley sockets API. Blocking on all three wakeup conditions listed above would require use of an API such as select(3) or poll(3), regardless of whether the network socket is configured in blocking mode or not.</p>
<p>While in principle APIs such as select(3) can be used with a socket in blocking mode, this is not an advisable usage mode. If a socket is in blocking mode, calls to send(3) or recv(3) may block for some arbitrary period of time, meaning that our QUIC implementation cannot handle incoming data (if we are blocked on send), send outgoing data (if we are blocked on receive), or handle timeout events.</p>
<p>Though it can be argued that a select(3) call indicating readability or writeability should guarantee that a subsequent send(3) or recv(3) call will not block, there are several reasons why this is an extremely undesirable solution:</p>
<ul>
<li>It is quite likely that there are buggy OSes out there which perform spurious wakeups from select(3).</li>
<li>The fact that a socket is writeable does not necessarily mean that a datagram of the size we wish to send is writeable, so a send(3) call could block anyway.</li>
<li>This usage pattern precludes multithreaded use barring some locking scheme due to the possibility of other threads racing between the call to select(3) and the subsequent I/O call. This undermines our intentions to support multi-threaded network I/O on the backend.</li>
</ul>
<p>Moreover, our QUIC implementation will not drive the Berkeley sockets API directly but uses the BIO abstraction to access the network, so these issues are then compounded by the limitations of our existing BIO interfaces. We do not have a BIO interface which provides for select(3)-like functionality or which can implement the required semantics above.</p>
<p>Moreover, even if we used select(3) directly, select(3) only gives us a guarantee (under a non-buggy OS) that a single syscall will not block, however we have no guarantee in the API contract for BIO_read(3) or BIO_write(3) that any given BIO implementation has such a BIO call correspond to only a single system call (or any system call), so this does not work either. Therefore, trying to implement QUIC on top of blocking I/O in this way would require violating the BIO abstraction layer, and would not work with custom BIOs (even if the poll descriptor concept discussed below were adopted).</p>
<h2><a class="anchor" id="autotoc_md411"></a>
Blocking sockets and threads</h2>
<p>Another conceptual possibility is that blocking calls could be kept ongoing in parallel threads. Under this model, there would be three threads:</p>
<ul>
<li>a thread which exists solely to execute blocking calls to the <code>BIO_write</code> of an underlying network BIO,</li>
<li>a thread which exists solely to execute blocking calls to the <code>BIO_read</code> of an underlying network BIO,</li>
<li>a thread which exists solely to wait for and dispatch timeout events.</li>
</ul>
<p>This could potentially be reduced to two threads if it is assumed that <code>BIO_write</code> calls do not take an excessive amount of time.</p>
<p>The premise here is that the front-end I/O API (<code>SSL_read</code>, <code>SSL_write</code>, etc.) would coordinate and synchronise with these background worker threads via threading primitives such as conditional variables, etc.</p>
<p>This has a large number of disadvantages:</p>
<ul>
<li>There is a hard requirement for threading functionality in order to be able to support blocking semantics at the application level. Applications which require blocking semantics would only be able to function in thread assisted mode. In environments where threading support is not available or desired, our APIs would only be usable in a non-blocking fashion.</li>
<li><p class="startli">Several threads are spawned which the application is not in control of. This undermines our general approach of providing the application with control over OpenSSL's use of resources, such as allowing the application to do its own polling or provide its own allocators.</p>
<p class="startli">At a minimum for a client, there must be two threads per connection. This means if an application opens many outgoing connections, there will need to be <code>2n</code> extra threads spawned.</p>
</li>
<li>By blocking in <code>BIO_write</code> calls, this precludes correct implementation of QUIC. Unlike any analogue in TLS, QUIC packets are time sensitive and intended to be transmitted as soon as they are generated. QUIC packets contain fields such as the ACK Delay value, which is intended to describe the time between a packet being received and a return packet being generated. Correct calculation of this field is necessary to correct calculation of connection RTT. It is therefore important to only generate packets when they are ready to be sent, otherwise suboptimal performance will result. This is a usage model which aligns optimally to non-blocking I/O and which cannot be accommodated by blocking I/O.</li>
<li>Since existing custom BIOs will not be expecting concurrent <code>BIO_read</code> and <code>BIO_write</code> calls, they will need to be adapted to support this, which is likely to require substantial rework of those custom BIOs (trivial locking of calls obviously does not work since both of these calls must be able to block on network I/O simultaneously).</li>
</ul>
<p>Moreover, this does not appear to be a realistically implementable approach:</p>
<ul>
<li><p class="startli">The question is posed of how to handle connection teardown, which does not seem to be solvable. If parallel threads are blocked in blocking <code>BIO_read</code> and <code>BIO_write</code> calls on some underlying network BIO, there needs to be some way to force these calls to return once <code>SSL_free</code> is called and we need to tear down the connection. However, the BIO interface does not provide any way to do this. <em>At best</em> we might assume the BIO is a <code>BIO_s_dgram</code> (but cannot assume this in the general case), but even then we can only accomplish teardown by violating the BIO abstraction and closing the underlying socket.</p>
<p class="startli">This is the only portable way to ensure that a recv(3) call to the same socket returns. This obviously is a highly application-visible change (and is likely to be far more disruptive than configuring the socket into non-blocking mode).</p>
<p class="startli">Moreover, it is not workable anyway because it only works for a socket-based BIO and violates the BIO abstraction. For BIOs in general, there does not appear to be any viable solution to the teardown issue.</p>
</li>
</ul>
<p>Even if this approach were successfully implemented, applications will still need to change to using network BIOs with datagram semantics. For applications using custom BIOs, this is likely to require substantial rework of those BIOs. There is no possible way around this. Thus, even if this solution were adopted (notwithstanding the issues which preclude this noted above) for the purposes of accommodating applications using custom network BIOs in a blocking mode, these applications would still have to completely rework their implementation of those BIOs. In any case, it is expected to be comparatively rare that sophisticated applications implementing their own custom BIOs will do so in a blocking mode.</p>
<h2><a class="anchor" id="autotoc_md412"></a>
Use of non-blocking I/O</h2>
<p>By comparison, use of non-blocking I/O and select(3) or similar APIs on the network side makes satisfying our requirements for QUIC easy, and also allows our internal approach to I/O to be flexibly adapted in the future as requirements may evolve.</p>
<p>This is also the approach used by all other known QUIC implementations; it is highly unlikely that any QUIC implementations exist which use blocking network I/O, as (as mentioned above) it would lead to suboptimal performance due to the ACK delay issue.</p>
<p>Note that this is orthogonal to whether we provide blocking I/O semantics to the application. We can use blocking I/O internally while using this to provide either blocking or non-blocking semantics to the application, based on what the application requests.</p>
<p>This approach in general requires that a network socket be configured in non-blocking mode. Though some OSes support a <code>MSG_DONTWAIT</code> flag which allows a single I/O operation to be made non-blocking, not all OSes support this (e.g. Windows), thus this cannot be relied on. As such, we need to configure any socket FD we use into non-blocking mode.</p>
<p>Of the approaches outlined in this document, the use of non-blocking I/O has the fewest disadvantages and is the only approach which appears to actually be implementable in practice. Moreover, most of the disadvantages can be readily mitigated:</p>
<ul>
<li><p class="startli">We rely on having a select(3) or poll(3) like function available from the OS.</p>
<p class="startli">However:</p><ul>
<li>Firstly, we already rely on select(3) in our code, at least in non-<code>no-sock</code> builds, so this does not appear to raise any portability issues;</li>
<li><p class="startli">Secondly, we have the option of providing a custom poller interface which allows an application to provide its own implementation of a select(3)-like function. In fact, this has the potential to be quite powerful and would allow the application to implement its own pollable BIOs, and therefore perform blocking I/O on top of any custom BIO.</p>
<p class="startli">For example, while historically none of our own memory-based BIOs have supported blocking semantics, a sophisticated application could if it wished choose to implement a custom blocking memory BIO and implement a custom poller which synchronises using a custom poll descriptor based around condition variables rather than sockets. Thus this scheme is highly flexible.</p>
<p class="startli">(It is worth noting also that the implementation of blocking semantics at the application level also does not rely on any privileged access to the internals of the QUIC implementation and an application could if it wished build blocking semantics out of a non-blocking QUIC instance; this is not particularly difficult, though providing custom pollers here would mean there should be no need for an application to do so.)</p>
</li>
</ul>
</li>
<li><p class="startli">Configuring a socket into non-blocking mode might confuse an application.</p>
<p class="startli">However:</p><ul>
<li><p class="startli">Applications will already have to make changes to any network-side BIOs, for example switching from a <code>BIO_s_socket</code> to a <code>BIO_s_dgram</code>, or from a BIO pair to a <code>BIO_s_dgram_pair</code>. Custom BIOs will need to be substantially reworked to switch from bytestream semantics to datagram semantics. Such applications will already need substantial changes, and this is unavoidable.</p>
<p class="startli">Of course, application impacts and migration guidance can (and will) all be documented.</p>
</li>
<li>In order for an application to be confused by us putting a socket into non-blocking mode, it would need to be trying to use the socket in some way. But it is not possible for an application to pass a socket to our QUIC implementation, and also try to use the socket directly, and have QUIC still work. Using QUIC necessarily requires that an application not also be trying to make use of the same socket.</li>
<li>There are some circumstances where an application might want to multiplex other protocols onto the same UDP socket, for example with protocols like RTP/RTCP or STUN; this can be facilitated using the QUIC fixed bit. However, these use cases cannot be supported without explicit assistance from a QUIC implementation and this use case cannot be facilitated by simply sharing a network socket, as incoming datagrams will not be routed correctly. (We may offer some functionality in future to allow this to be coordinated but this is not for MVP.) Thus this also is not a concern. Moreover, it is extremely unlikely that any such applications are using sockets in blocking mode anyway.</li>
</ul>
</li>
</ul>
<p>The poll descriptor interface adds complexity to the BIO interface.</p>
<p>Advantages:</p>
<ul>
<li><p class="startli">An application retains full control of its event loop in non-blocking mode.</p>
<p class="startli">When using libssl in application-level blocking mode, via a custom poller interface, the application would actually be able to exercise more control over I/O than it actually is at present when using libssl in blocking mode.</p>
</li>
<li>Feasible to implement and already working in tests. Minimises further development needed to ship.</li>
<li>Does not rely on creating threads and can support blocking I/O at the application level without relying on thread assisted mode.</li>
<li>Does not require an application-provided network-side custom BIO to be reworked to support concurrent calls to it.</li>
<li>The poll descriptor interface will allow applications to implement custom modes of polling in the future (e.g. an application could even building blocking application-level I/O on top of a on a custom memory-based BIO using condition variables, if it wished). This is actually more flexible than the current TLS stack, which cannot be used in blocking mode when used with a memory-based BIO.</li>
<li>Allows performance-optimal implementation of QUIC RFC requirements.</li>
<li>Ensures our internal I/O architecture remains flexible for future evolution without breaking compatibility in the future.</li>
</ul>
<h1><a class="anchor" id="autotoc_md413"></a>
Use of Internal Non-Blocking I/O</h1>
<p>Based on the above evaluation, implementation has been undertaken using non-blocking I/O internally. Applications can use blocking or non-blocking I/O at the libssl API level. Network-level BIOs must operate in a non-blocking mode or be configurable by QUIC to this end.</p>
<p><img src="images/quic-io-arch-1.png" alt="Block Diagram" title="Block Diagram" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md414"></a>
Support of arbitrary BIOs</h2>
<p>We need to support not just socket FDs but arbitrary BIOs as the basis for the use of QUIC. The use of QUIC with e.g. <code>BIO_s_dgram_pair</code>, a bidirectional memory buffer with datagram semantics, is to be supported as part of MVP. This must be reconciled with the desire to support application-managed event loops.</p>
<p>Broadly, the intention so far has been to enable the use of QUIC with an application event loop in application-level non-blocking mode by exposing an appropriate OS-level synchronisation primitive to the application. On *NIX platforms, this essentially means we provide the application with:</p>
<ul>
<li>An FD which should be polled for readability, writability, or both; and</li>
<li>A deadline (if any is currently applicable).</li>
</ul>
<p>Once either of these conditions is met, the QUIC state machine can be (potentially) advanced meaningfully, and the application is expected to reenter the QUIC state machine by calling <code>SSL_tick()</code> (or <code>SSL_read()</code> or <code>SSL_write()</code>).</p>
<p>This model is readily supported when the read and write BIOs we are provided with are socket BIOs:</p>
<ul>
<li>The read-pollable FD is the FD of the read BIO.</li>
<li>The write-pollable FD is the FD of the write BIO.</li>
</ul>
<p>However, things become more complex when we are dealing with memory-based BIOs such as <code>BIO_dgram_pair</code> which do not naturally correspond to any OS primitive which can be used for synchronisation, or when we are dealing with an application-provided custom BIO.</p>
<h2><a class="anchor" id="autotoc_md415"></a>
Pollable and Non-Pollable BIOs</h2>
<p>In order to accommodate these various cases, we draw a distinction between pollable and non-pollable BIOs.</p>
<ul>
<li>A pollable BIO is a BIO which can provide some kind of OS-level synchronisation primitive, which can be used to determine when the BIO might be able to do useful work once more.</li>
<li>A non-pollable BIO has no naturally associated OS-level synchronisation primitive, but its state only changes in response to calls made to it (or to a related BIO, such as the other end of a pair).</li>
</ul>
<h3><a class="anchor" id="autotoc_md416"></a>
Supporting Pollable BIOs</h3>
<p>“OS-level synchronisation primitive” is deliberately vague. Most modern OSes use unified handle spaces (UNIX, Windows) though it is likely there are more obscure APIs on these platforms which have other handle spaces. However, this unification is not necessarily significant.</p>
<p>For example, Windows sockets are kernel handles and thus like any other object they can be used with the generic Win32 <code>WaitForSingleObject()</code> API, but not in a useful manner; the generic readiness mechanism for WIndows handles is not plumbed in for socket handles, and so sockets are simply never considered ready for the purposes of this API, which will never return. Instead, the WinSock-specific <code>select()</code> call must be used. On the other hand, other kinds of synchronisation primitive like a Win32 Event must use <code>WaitForSingleObject()</code>.</p>
<p>Thus while in theory most modern operating systems have unified handle spaces in practice there are substantial usage differences between different handle types. As such, an API to expose a synchronisation primitive should be of a tagged union design supporting possible variation.</p>
<p>A BIO object will provide methods to retrieve a pollable OS-level synchronisation primitive which can be used to determine when the QUIC state machine can (potentially) do more work. This maintains the integrity of the BIO abstraction layer. Equivalent SSL object API calls which forward to the equivalent calls of the underlying network BIO will also be provided.</p>
<p>The core mechanic is as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define BIO_POLL_DESCRIPTOR_TYPE_NONE        0</span></div>
<div class="line"><span class="preprocessor">#define BIO_POLL_DESCRIPTOR_TYPE_SOCK_FD     1</span></div>
<div class="line"><span class="preprocessor">#define BIO_POLL_DESCRIPTOR_CUSTOM_START     8192</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define BIO_POLL_DESCRIPTOR_NUM_CUSTOM       4</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>bio_poll_descriptor_st {</div>
<div class="line">    <span class="keywordtype">int</span> type;</div>
<div class="line">    <span class="keyword">union </span>{</div>
<div class="line">        <span class="keywordtype">int</span> fd;</div>
<div class="line">        <span class="keyword">union </span>{</div>
<div class="line">            <span class="keywordtype">void</span>        *ptr;</div>
<div class="line">            uint64_t    u64;</div>
<div class="line">        } custom[BIO_POLL_DESCRIPTOR_NUM_CUSTOM];</div>
<div class="line">    } value;</div>
<div class="line">} BIO_POLL_DESCRIPTOR;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> BIO_get_rpoll_descriptor(BIO *ssl, BIO_POLL_DESCRIPTOR *desc);</div>
<div class="line"><span class="keywordtype">int</span> BIO_get_wpoll_descriptor(BIO *ssl, BIO_POLL_DESCRIPTOR *desc);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SSL_get_rpoll_descriptor(SSL *ssl, BIO_POLL_DESCRIPTOR *desc);</div>
<div class="line"><span class="keywordtype">int</span> SSL_get_wpoll_descriptor(SSL *ssl, BIO_POLL_DESCRIPTOR *desc);</div>
</div><!-- fragment --><p>Currently only a single descriptor type is defined, which is a FD on *NIX and a Winsock socket handle on Windows. These use the same type to minimise code changes needed on different platforms in the common case of an OS network socket. (Use of an <code>int</code> here is strictly incorrect for Windows; however, this style of usage is prevalent in the OpenSSL codebase, so for consistency we continue the pattern here.)</p>
<p>Poll descriptor types at or above <code>BIO_POLL_DESCRIPTOR_CUSTOM_START</code> are reserved for application-defined use. The <code>value.custom</code> field of the <code>BIO_POLL_DESCRIPTOR</code> structure is provided for applications to store values of their choice in. An application is free to define the semantics.</p>
<p>libssl will not know how to poll custom poll descriptors itself, thus these are only useful when the application will provide a custom poller function, which performs polling on behalf of libssl and which implements support for those custom poll descriptors.</p>
<p>For <code>BIO_s_ssl</code>, the <code>BIO_get_[rw]poll_descriptor</code> functions are equivalent to the <code>SSL_get_[rw]poll_descriptor</code> functions. The <code>SSL_get_[rw]poll_descriptor</code> functions are equivalent to calling <code>BIO_get_[rw]poll_descriptor</code> on the underlying BIOs provided to the SSL object. For a socket BIO, this will likely just yield the socket's FD. For memory-based BIOs, see below.</p>
<h3><a class="anchor" id="autotoc_md417"></a>
Supporting Non-Pollable BIOs</h3>
<p>Where we are provided with a non-pollable BIO, we cannot provide the application with any primitive used for synchronisation and it is assumed that the application will handle its own network I/O, for example via a <code>BIO_s_dgram_pair</code>.</p>
<p>When libssl calls <code>BIO_get_[rw]poll_descriptor</code> on the underlying BIO, the call fails, indicating that a non-pollable BIO is being used. Thus, if an application calls <code>SSL_get_[rw]poll_descriptor</code>, that call also fails.</p>
<p>There are various circumstances which need to be handled:</p>
<ul>
<li><p class="startli">The QUIC implementation wants to write data to the network but is currently unable to (e.g. <code>BIO_s_dgram_pair</code> is full).</p>
<p class="startli">This is not hard as our internal TX record layer allows arbitrary buffering. The only limit comes when QUIC flow control (which only applies to application stream data) applies a limit; then calls to e.g. <code>SSL_write</code> we must fail with <code>SSL_ERROR_WANT_WRITE</code>.</p>
</li>
<li><p class="startli">The QUIC implementation wants to read data from the network but is currently unable to (e.g. <code>BIO_s_dgram_pair</code> is empty).</p>
<p class="startli">Here calls like <code>SSL_read</code> need to fail with <code>SSL_ERROR_WANT_READ</code>; we thereby support libssl's classic nonblocking I/O interface.</p>
</li>
</ul>
<p>It is worth noting that theoretically a memory-based BIO could be implemented which is pollable, for example using condition variables. An application could implement a custom BIO, custom poll descriptor and custom poller to facilitate this.</p>
<h2><a class="anchor" id="autotoc_md418"></a>
Configuration of Blocking vs. Non-Blocking Mode</h2>
<p>Traditionally an SSL object has operated either in blocking mode or non-blocking mode without requiring explicit configuration; if a socket returns EWOULDBLOCK or similar, it is handled appropriately, and if a socket call blocks, there is no issue. Since the QUIC implementation is building on non-blocking I/O, this implicit configuration of non-blocking mode is not feasible.</p>
<p>Note that Windows does not have an API for determining whether a socket is in blocking mode, so it is not possible to use the initial state of an underlying socket to determine if the application wants to use non-blocking I/O or not. Moreover this would undermine the BIO abstraction.</p>
<p>As such, an explicit call is introduced to configure an SSL (QUIC) object into non-blocking mode:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SSL_set_blocking_mode(SSL *s, <span class="keywordtype">int</span> blocking);</div>
<div class="line"><span class="keywordtype">int</span> SSL_get_blocking_mode(SSL *s);</div>
</div><!-- fragment --><p>Applications desiring non-blocking operation will need to call this API to configure a new QUIC connection accordingly. Blocking mode is chosen as the default for parity with traditional Berkeley sockets APIs and to make things simpler for blocking applications, which are likely to be seeking a simpler solution. However, blocking mode cannot be supported with a non-pollable BIO, and thus blocking mode defaults to off when used with such a BIO.</p>
<p>A method is also needed for the QUIC implementation to inform an underlying BIO that it must not block. The SSL object will call this function when it is provided with an underlying BIO. For a socket BIO this can set the socket as non-blocking; for a memory-based BIO it is a no-op; for <code>BIO_s_ssl</code> it is equivalent to a call to <code>SSL_set_blocking_mode()</code>.</p>
<h2><a class="anchor" id="autotoc_md419"></a>
Internal Polling</h2>
<p>When blocking mode is configured, the QUIC implementation will call <code>BIO_get_[rw]poll_descriptor</code> on the underlying BIOs and use a suitable OS function (e.g. <code>select()</code>) or, if configured, custom poller function, to block. This will be implemented by an internal function which can accept up to two poll descriptors (one for the read BIO, one for the write BIO), which might be identical.</p>
<p>Blocking mode cannot be used with a non-pollable underlying BIO. If <code>BIO_get[rw]poll_descriptor</code> is not implemented for either of the underlying read and write BIOs, blocking mode cannot be enabled and blocking mode defaults to off. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
