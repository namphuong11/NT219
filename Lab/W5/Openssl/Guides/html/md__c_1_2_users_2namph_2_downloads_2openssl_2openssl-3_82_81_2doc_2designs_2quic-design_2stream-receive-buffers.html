<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: Stream Receive Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Stream Receive Buffers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a QUIC specific module that retains the received stream data until the application reads it with SSL_read() or any future stream read calls.</p>
<h1><a class="anchor" id="autotoc_md471"></a>
Receive Buffers requirements for MVP</h1>
<p>These are the requirements that were identified for MVP:</p>
<ul>
<li>As packets with stream frames are received in arbitrary frames the received data must be stored until all the data with earlier offsets are received.</li>
<li>As packets can be received before application calls SSL_read() to read the data the data must be stored.</li>
<li>The application should be able to set the limit on how much data should be stored. The flow controller should be used to limit the peer to not send more data. Without the flow control limit a rogue peer could trigger a DoS via unlimited flow of incoming stream data frames.</li>
<li>After the data is passed via SSL_read() to the application the stored data can be released and flow control limit can be raised.</li>
<li>As the peer can recreate stream data frames when resending them, the implementation must be able to handle properly frames with partially or fully overlapping data with previously received frames.</li>
</ul>
<h1><a class="anchor" id="autotoc_md472"></a>
Optional Receive Buffers requirements</h1>
<p>These are optional features of the stream receive buffers implementation. They are not required for MVP but they are otherwise desirable:</p>
<ul>
<li>To support a single copy operation with a future stream read call the received data should not be copied out of the decrypted packets to store the data. The only information actually stored would be a list of offset, length, and pointers to data, along with a pointer to the decrypted QUIC packet that stores the actual frame.</li>
</ul>
<h1><a class="anchor" id="autotoc_md473"></a>
Proposed new public API calls</h1>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SSL_set_max_stored_stream_data(SSL *stream, <span class="keywordtype">size_t</span> length);</div>
</div><!-- fragment --><p>This function adjusts the current data flow control limit on the <code>stream</code> to allow storing <code>length</code> bytes of quic stream data before it is read by the application.</p>
<p>OpenSSL handles sending MAX_STREAM_DATA frames appropriately when the application reads the stored data.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> SSL_set_max_unprocessed_packet_data(SSL *connection,</div>
<div class="line">                                        <span class="keywordtype">size_t</span> length);</div>
</div><!-- fragment --><p>This sets the limit on unprocessed quic packet data <code>length</code> in bytes that is allowed to be allocated for the <code>connection</code>. See the Other considerations section below.</p>
<h1><a class="anchor" id="autotoc_md474"></a>
Interfaces to other QUIC implementation modules</h1>
<h2><a class="anchor" id="autotoc_md475"></a>
Front End I/O API</h2>
<p>SSL_read() copies data out of the stored buffers if available and eventually triggers release of stored unprocessed packet(s).</p>
<p>SSL_peek(), SSL_pending(), SSL_has_pending() peek into the stored buffers for any information about the stored data.</p>
<h2><a class="anchor" id="autotoc_md476"></a>
RX Depacketizer</h2>
<p>The Receive Buffers module obtains the stream data via the ssl_queue_data() callback.</p>
<p>The module uses ossl_qrx_pkt_wrap_up_ref() and ossl_qrx_pkt_wrap_release() functions to keep and release decrypted packets with unprocessed data.</p>
<h2><a class="anchor" id="autotoc_md477"></a>
Flow Control</h2>
<p>The Receive Buffers module provides an appropriate value for the Flow Control module to send MAX_DATA and MAX_STREAM_DATA frames. Details TBD.</p>
<h2><a class="anchor" id="autotoc_md478"></a>
QUIC Read Record Layer</h2>
<p>The Receive Buffers module needs to know whether it should stop holding the decrypted quic packets and start copying the stream data due to the limit reached. See the <code>SSL_set_max_unprocessed_quic_packet_data()</code> function above and the Other considerations section below. Details TBD.</p>
<h1><a class="anchor" id="autotoc_md479"></a>
Implementation details</h1>
<p>The QUIC_RSTREAM object holds the received stream data in the SFRAME_LIST structure. This is a sorted list of partially (never fully) overlapping data frames. Each list item holds a pointer to the received packet wrapper for refcounting and proper release of the received packet data once the stream data is read by the application.</p>
<p>Each SFRAME_LIST item has range.start and range.end values greater than the range.start and range.end values of the previous item in the list. This invariant is ensured on the insertion of overlapping stream frames. Any redundant frames are released. Insertion at the end of the list is optimised as in the ideal situation when no packets are lost we always just append new frames.</p>
<p>See <code><a class="el" href="quic__stream_8h_source.html">include/internal/quic_stream.h</a></code> and <code><a class="el" href="quic__sf__list_8h_source.html">include/internal/quic_sf_list.h</a></code> for internal API details.</p>
<h1><a class="anchor" id="autotoc_md480"></a>
Other considerations</h1>
<p>The peer is allowed to recreate the stream data frames. As we aim for a single-copy operation a rogue peer could use this to override the stored data limits by sending duplicate frames with only slight changes in the offset. For example: 1st frame - offset 0 length 1000, 2nd frame - offset 1 length 1000, 3rd frame - offset 2 length 1000, and so on. We would have to keep the packet data for all these frames which would effectively raise the stream data flow control limit quadratically.</p>
<p>And this is not the only way how a rogue peer could make us occupy much more data than what is allowed by the stream data flow control limit in the single-copy scenario.</p>
<p>Although intuitively the MAX_DATA flow control limit might be used to somehow limit the allocated packet buffer size, it is defined as sum of allowed data to be sent across all the streams in the connection instead. The packet buffer will contain much more data than just the stream frames especially with a rogue peer, that means MAX_DATA limit cannot be used to limit the memory occupied by packet buffers.</p>
<p>To resolve this problem, we fall back to copying the data off the decrypted packet buffer once we reach a limit on unprocessed decrypted packets. We might also consider falling back to copying the data in case we receive stream data frames that are partially overlapping and one frame not being a subrange of the other.</p>
<p>Because in MVP only a single bidirectional stream to receive any data will be supported, the MAX_DATA flow control limit should be equal to MAX_STREAM_DATA limit for that stream. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
