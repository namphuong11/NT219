<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: Windows-related issues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Windows-related issues</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Supporting Windows introduces some complications due to some "fun" peculiarities of Windows's socket API.</p>
<p>In general, Windows does not provide a poll(2) call. WSAPoll(2) was introduced in Vista and supposed to bring this functionality, but it had a bug in it which Microsoft refused to fix, making it rather pointless. However Microsoft has now finally fixed this bug in a build of Windows 10. So WSAPoll(2) is a viable method, but only on fairly new versions of Windows.</p>
<p>Traditionally, polling has been done on windows using select(). However, this call works a little differently than on POSIX platforms. Whereas on POSIX platforms select() accepts a bitmask of FDs, on Windows select() accepts a structure which embeds a fixed-length array of socket handles. This is necessary because sockets are NT kernel handles on Windows and thus are not allocated contiguously like FDs. As such, Windows select() is actually very similar to POSIX poll(), making select() a viable option for polling on Windows.</p>
<p>Neither select() nor poll() are, of course, high performance polling options. Windows does not provide anything like epoll or kqueue. For high performance network I/O, you are expected to use a Windows API called I/O Completion Ports (IOCP).</p>
<p>Supporting these is a pain for applications designed around polling. The reason is that IOCPs are a higher-level interface; it is easy to build an IOCP-like interface on top of polling, but it is not really possible to build a polling-like interface on top of IOCPs.</p>
<p>For this reason it's actually common for asynchronous I/O libraries to basically contain two separate implementations of their APIs internally, or at least a substantial chunk of their code (e.g. libuv, nanomsg). It turns out to be easier just to write a poll-based implementation of an I/O reactor and an IOCP-based implementation than try to overcome the impedance discontinuities.</p>
<p>The difference between polling and IOCPs is that polling reports <em>readiness</em> whereas IOCPs report <em>completion of an operation</em>. For example, in the IOCP model, you make a read or write on a socket and an event is posted to the IOCP when the read or write is complete. This is a fundamentally different model and actually more similar to a high-level asynchronous I/O library such as libuv or so on.</p>
<p>Evaluation of the existing demos and their applicability to Windows IOCP:</p>
<ul>
<li>ddd-01-conn-blocking: Blocking example, use of IOCP is not applicable.</li>
<li>ddd-02-conn-nonblocking: Socket is managed by OpenSSL, and IOCP is not supported.</li>
<li>ddd-03-fd-blocking: Blocking example, use of IOCP is not applicable.</li>
<li><p class="startli">ddd-04-fd-nonblocking: libssl is passed an FD with BIO_set_fd.</p>
<p class="startli">BIO_s_sock doesn't appear to support overlapped (that is, IOCP-based) I/O as this requires use of special WSASend() and WSARecv() functions, rather than standard send()/recv().</p>
<p class="startli">Since libssl already doesn't support IOCP for use of BIO_s_sock, we might say here that any existing application using BIO_s_sock obviously isn't trying to use IOCP, and therefore we don't need to worry about the adapability of this example to IOCP.</p>
</li>
<li><p class="startli">ddd-05-mem-nonblocking: Since the application is in full control of passing data from the memory BIO to the network, or vice versa, the application can use IOCP if it wishes.</p>
<p class="startli">This is demonstrated in the following demo:</p>
</li>
<li>ddd-06-mem-uv: This demo uses a memory BIO and libuv. Since libuv supports IOCP, it proves that a memory BIO can be used to support IOCP-based usage.</li>
</ul>
<p>Further, a cursory examination of code on GitHub seems to suggest that when people do use IOCP with libssl, they do it using memory BIOs passed to libssl. So ddd-05 and ddd-06 essentially demonstrate this use case, especially ddd-06 as it uses IOCP internally on Windows.</p>
<p>My conclusion here is that since libssl does not support IOCP in the first place, we don't need to be particularly worried about this. But in the worst case there are always workable solutions, as in demos 5 and 6. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
