<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: Design Problem: Abstract Record Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Design Problem: Abstract Record Layer</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document covers the design of an abstract record layer for use in (D)TLS. The QUIC record layer is handled separately.</p>
<p>A record within this document refers to a packet of data. It will typically contain some header data and some payload data, and will often be cryptographically protected. A record may or may not have a one-to-one correspondence with network packets, depending on the implementation details of an individual record layer.</p>
<p>The term record comes directly from the TLS and DTLS specifications.</p>
<p>Libssl supports a number of different types of record layer, and record layer variants:</p>
<ul>
<li>Standard TLS record layer</li>
<li>Standard DTLS record layer</li>
<li>Kernel TLS record layer</li>
</ul>
<p>Within the TLS record layer there are options to handle "multiblock" and "pipelining" which are different approaches for supporting the reading or writing of multiple records at the same time. All record layer variants also have to be able to handle different protocol versions.</p>
<p>These different record layer implementations, variants and protocol versions have each been added at different times and over many years. The result is that each took slightly different approaches for achieving the goals that were appropriate at the time and the integration points where they were added were spread throughout the code.</p>
<p>The introduction of QUIC support will see the implementation of a new record layer, i.e. the QUIC-TLS record layer. This refers to the "inner" TLS implementation used by QUIC. Records here will be in the form of QUIC CRYPTO frames.</p>
<h1><a class="anchor" id="autotoc_md454"></a>
Requirements</h1>
<p>The technical requirements <a href="https://github.com/openssl/openssl/blob/master/doc/designs/quic-design/quic-requirements.md">document</a> lists these requirements that are relevant to the record layer:</p>
<ul>
<li>The current libssl record layer includes support for TLS, DTLS and KTLS. QUIC will introduce another variant and there may be more over time. The OMC requires a pluggable record layer interface to be implemented to enable this to be less intrusive, more maintainable, and to harmonize the existing record layer interactions between TLS, DTLS, KTLS and the planned QUIC protocols. The pluggable record layer interface will be internal only for MVP and be public in a future release.</li>
<li>The minimum viable product (MVP) for the next release is a pluggable record layer interface and a single stream QUIC client in the form of s_client that does not require significant API changes. In the MVP, interoperability should be prioritized over strict standards compliance.</li>
<li>Once we have a fully functional QUIC implementation (in a subsequent release), it should be possible for external libraries to be able to use the pluggable record layer interface and it should offer a stable ABI (via a provider).</li>
</ul>
<p>The MVP requirements are:</p>
<ul>
<li>a pluggable record layer (not public for MVP)</li>
</ul>
<h1><a class="anchor" id="autotoc_md455"></a>
Candidate Solutions that were considered</h1>
<p>This section outlines two different solution approaches that were considered for the abstract record layer</p>
<h2><a class="anchor" id="autotoc_md456"></a>
Use a METHOD based approach</h2>
<p>A <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach is simply a structure containing function pointers. It is a common pattern in the OpenSSL codebase. Different strategies for implementing a <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> can be employed, but these differences are hidden from the caller of the <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a>.</p>
<p>In this solution we would seek to implement a different <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> for each of the types of record layer that we support, i.e. there would be one for the standard TLS record layer, one for the standard DTLS record layer, one for kernel TLS and one for QUIC-TLS.</p>
<p>In the MVP the <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> approach would be private. However, once it has stabilised, it would be straight forward to supply public functions to enable end user applications to construct their own METHODs.</p>
<p>This option is simpler to implement than the alternative of having a provider based approach. However it could be used as a "stepping stone" for that, i.e. the MVP could implement a <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach, and subsequent releases could convert the METHODs into fully fetchable algorithms.</p>
<p>Pros:</p>
<ul>
<li>Simple approach that has been used historically in OpenSSL</li>
<li>Could be used as the basis for the final public solution</li>
<li>Could also be used as the basis for a fetchable solution in a subsequent release</li>
<li>If this option is later converted to a fetchable solution then much of the effort involved in making the record layer fetchable can be deferred to a later release</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not consistent with the provider based approach we used for extensibility in 3.0</li>
<li>If this option is implemented and later converted to a fetchable solution then some rework might be required</li>
</ul>
<h2><a class="anchor" id="autotoc_md457"></a>
Use a provider based approach</h2>
<p>This approach is very similar to the alternative <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach. The main difference is that the record layer implementations would be held in providers and "fetched" in much the same way that cryptographic algorithms are fetched in OpenSSL 3.0.</p>
<p>This approach is more consistent with the approach adopted for extensibility in 3.0. METHODS are being deprecated with providers being used extensively.</p>
<p>Complex objects (e.g. an <code>SSL</code> object) cannot be passed across the libssl/provider boundary. This imposes some restrictions on the design of the functions that can be implemented. Additionally implementing the infrastructure for a new fetchable operation is more involved than a <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach.</p>
<p>Pros:</p>
<ul>
<li>Consistent with the extensibility solution used in 3.0</li>
<li>If this option is implemented immediately in the MVP then it would avoid later rework if adopted in a subsequent release</li>
</ul>
<p>Cons:</p>
<ul>
<li>More complicated to implement than the simple <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach</li>
<li>Cannot pass complex objects across the provider boundary</li>
</ul>
<h2><a class="anchor" id="autotoc_md458"></a>
Selected solution</h2>
<p>The <a class="el" href="struct_m_e_t_h_o_d.html">METHOD</a> based approach has been selected for MVP, with the expectation that subsequent releases will convert it to a full provider based solution accessible to third party applications.</p>
<h1><a class="anchor" id="autotoc_md459"></a>
Solution Description: The METHOD based approach</h1>
<p>This section focuses on the selected approach of using METHODs and further elaborates on how the design works.</p>
<p>A proposed internal record method API is given in Appendix A.</p>
<p>An <code>OSSL_RECORD_METHOD</code> represents the implementation of a particular type of record layer. It contains a set of function pointers to represent the various actions that can be performed by a record layer.</p>
<p>An <code>OSSL_RECORD_LAYER</code> object represents a specific instantiation of a particular <code>OSSL_RECORD_METHOD</code>. It contains the state used by that <code>OSSL_RECORD_METHOD</code> for a specific connection (i.e. <code>SSL</code> object). Any <code>SSL</code> object will have at least 2 <code>OSSL_RECORD_LAYER</code> objects associated with it - one for reading and one for writing. In some cases there may be more than 2 - for example in DTLS it may be necessary to retransmit records from a previous epoch. There will be different <code>OSSL_RECORD_LAYER</code> objects for different protection levels or epochs. It may be that different <code>OSSL_RECORD_METHOD</code>s are used for different protection levels. For example a connection might start using the standard TLS record layer during the handshake, and later transition to using the kernel TLS record layer once the handshake is complete.</p>
<p>A new <code>OSSL_RECORD_LAYER</code> is created by calling the <code>new</code> function of the associated <code>OSSL_RECORD_METHOD</code>, and freed by calling the <code>free</code> function. The parameters to the <code>new</code> function also supply all of the cryptographic state (e.g. keys, ivs, symmetric encryption algorithms, hash algorithm etc) used by the record layer. The internal structure details of an <code>OSSL_RECORD_LAYER</code> are entirely hidden to the rest of libssl and can be specific to the given <code>OSSL_RECORD_METHOD</code>. In practice the standard internal TLS, DTLS and KTLS <code>OSSL_RECORD_METHOD</code>s all use a common <code>OSSL_RECORD_LAYER</code> structure. However the QUIC-TLS implementation is likely to use a different structure layout.</p>
<p>All of the header and payload data for a single record will be represented by an <code>OSSL_RECORD_TEMPLATE</code> structure when writing. Libssl will construct a set of templates for records to be written out and pass them to the "write" record layer. In most cases only a single record is ever written out at one time, however there are some cases (such as when using the "pipelining" or "multibuffer" optimisations) that multiple records can be written in one go.</p>
<p>It is the record layer's responsibility to know whether it can support multiple records in one go or not. It is libssl's responsibility to split the payload data into <code>OSSL_RECORD_TEMPLATE</code> objects. Libssl will call the record layer's <code>get_max_records()</code> function to determine how many records a given payload should be split into. If that value is more than one, then libssl will construct (up to) that number of <code>OSSL_RECORD_TEMPLATE</code>s and pass the whole set to the record layer's <code>write_records()</code> function.</p>
<p>The implementation of the <code>write_records</code> function must construct the appropriate number of records, apply protection to them as required and then write them out to the underlying transport layer BIO. In the event that not all the data can be transmitted at the current time (e.g. because the underlying transport has indicated a retry), then the <code>write_records</code> function will return a "retry" response. It is permissible for the data to be partially sent, but this is still considered a "retry" until all of the data is sent.</p>
<p>On a success or retry response libssl may free its buffers immediately. The <code>OSSL_RECORD_LAYER</code> object will have to buffer any untransmitted data until it is eventually sent.</p>
<p>If a "retry" occurs, then libssl will subsequently call <code>retry_write_records</code> and continue to do so until a success return value is received. Libssl will never call <code>write_records</code> a second time until a previous call to <code>write_records</code> or <code>retry_write_records</code> has indicated success.</p>
<p>Libssl will read records by calling the <code>read_record</code> function. The <code>OSSL_RECORD_LAYER</code> may read multiple records in one go and buffer them, but the <code>read_record</code> function only ever returns one record at a time. The <code>OSSL_RECORD_LAYER</code> object owns the buffers for the record that has been read and supplies a pointer into that buffer back to libssl for the payload data, as well as other information about the record such as its length and the type of data contained in it. Each record has an associated opaque handle <code>rechandle</code>. The record data must remain buffered by the <code>OSSL_RECORD_LAYER</code> until it has been released via a call to <code>release_record()</code>.</p>
<p>A record layer implementation supplies various functions to enable libssl to query the current state. In particular:</p>
<p><code>unprocessed_read_pending()</code>: to query whether there is data buffered that has already been read from the underlying BIO, but not yet processed.</p>
<p><code>processed_read_pending()</code>: to query whether there is data buffered that has been read from the underlying BIO and has been processed. The data is not necessarily application data.</p>
<p><code>app_data_pending()</code>: to query the amount of processed application data that is buffered and available for immediate read.</p>
<p><code>get_alert_code()</code>: to query the alert code that should be used in the event that a previous attempt to read or write records failed.</p>
<p><code>get_state()</code>: to obtain a printable string to describe the current state of the record layer.</p>
<p><code>get_compression()</code>: to obtain information about the compression method currently being used by the record layer.</p>
<p><code>get_max_record_overhead()</code>: to obtain the maximum amount of bytes the record layer will add to the payload bytes before transmission. This does not include any expansion that might occur during compression. Currently this is only implemented for DTLS.</p>
<p>In addition, libssl will tell the record layer about various events that might occur that are relevant to the record layer's operation:</p>
<p><code>set1_bio()</code>: called if the underlying BIO being used by the record layer has been changed.</p>
<p><code>set_protocol_version()</code>: called during protocol version negotiation when a specific protocol version has been selected.</p>
<p><code>set_plain_alerts()</code>: to indicate that receiving unencrypted alerts is allowed in the current context, even if normally we would expect to receive encrypted data. This is only relevant for TLSv1.3.</p>
<p><code>set_first_handshake()</code>: called at the beginning and end of the first handshake for any given (D)TLS connection.</p>
<p><code>set_max_pipelines()</code>: called to configure the maximum number of pipelines of data that the record layer should process in one go. By default this is 1.</p>
<p><code>set_in_init()</code>: called by libssl to tell the record layer whether we are currently <code>in_init</code> or not. Defaults to "true".</p>
<p><code>set_options()</code>: called by libssl in the event that the current set of options to use has been updated.</p>
<p><code>set_max_frag_len()</code>: called by libssl to set the maximum allowed fragment length that is in force at the moment. This might be the result of user configuration, or it may be negotiated during the handshake.</p>
<p><code>increment_sequence_ctr()</code>: force the record layer to increment its sequence counter. In most cases the record layer will entirely manage its own sequence counters. However in the DTLSv1_listen() corner case, libssl needs to initialise the record layer with an incremented sequence counter.</p>
<p><code>alloc_buffers()</code>: called by libssl to request that the record layer allocate its buffers. This is a hint only and the record layer is expected to manage its own buffer allocation and freeing.</p>
<p><code>free_buffers()</code>: called by libssl to request that the record layer free its buffers. This is a hint only and the record layer is expected to manage its own buffer allocation and freeing.</p>
<h1><a class="anchor" id="autotoc_md460"></a>
Appendix A: The internal record method API</h1>
<p>The internal <a class="el" href="recordmethod_8h_source.html">recordmethod.h</a> header file for the record method API:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">/*</div>
<div class="line"> * We use the term &quot;record&quot; here to refer to a packet of data. Records are</div>
<div class="line"> * typically protected via a cipher and MAC, or an AEAD cipher (although not</div>
<div class="line"> * always). This usage of the term record is consistent with the TLS concept.</div>
<div class="line"> * In QUIC the term &quot;record&quot; is not used but it is analogous to the QUIC term</div>
<div class="line"> * &quot;packet&quot;. The interface in this file applies to all protocols that protect</div>
<div class="line"> * records/packets of data, i.e. (D)TLS and QUIC. The term record is used to</div>
<div class="line"> * refer to both contexts.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * An OSSL_RECORD_METHOD is a protocol specific method which provides the</div>
<div class="line"> * functions for reading and writing records for that protocol. Which</div>
<div class="line"> * OSSL_RECORD_METHOD to use for a given protocol is defined by the SSL_METHOD.</div>
<div class="line"> */</div>
<div class="line">typedef struct ossl_record_method_st OSSL_RECORD_METHOD;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * An OSSL_RECORD_LAYER is just an externally defined opaque pointer created by</div>
<div class="line"> * the method</div>
<div class="line"> */</div>
<div class="line">typedef struct ossl_record_layer_st OSSL_RECORD_LAYER;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"># define OSSL_RECORD_ROLE_CLIENT 0</div>
<div class="line"># define OSSL_RECORD_ROLE_SERVER 1</div>
<div class="line"> </div>
<div class="line"># define OSSL_RECORD_DIRECTION_READ  0</div>
<div class="line"># define OSSL_RECORD_DIRECTION_WRITE 1</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Protection level. For &lt;= TLSv1.2 only &quot;NONE&quot; and &quot;APPLICATION&quot; are used.</div>
<div class="line"> */</div>
<div class="line"># define OSSL_RECORD_PROTECTION_LEVEL_NONE        0</div>
<div class="line"># define OSSL_RECORD_PROTECTION_LEVEL_EARLY       1</div>
<div class="line"># define OSSL_RECORD_PROTECTION_LEVEL_HANDSHAKE   2</div>
<div class="line"># define OSSL_RECORD_PROTECTION_LEVEL_APPLICATION 3</div>
<div class="line"> </div>
<div class="line"># define OSSL_RECORD_RETURN_SUCCESS           1</div>
<div class="line"># define OSSL_RECORD_RETURN_RETRY             0</div>
<div class="line"># define OSSL_RECORD_RETURN_NON_FATAL_ERR    -1</div>
<div class="line"># define OSSL_RECORD_RETURN_FATAL            -2</div>
<div class="line"># define OSSL_RECORD_RETURN_EOF              -3</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Template for creating a record. A record consists of the |type| of data it</div>
<div class="line"> * will contain (e.g. alert, handshake, application data, etc) along with a</div>
<div class="line"> * buffer of payload data in |buf| of length |buflen|.</div>
<div class="line"> */</div>
<div class="line">struct ossl_record_template_st {</div>
<div class="line">    int type;</div>
<div class="line">    unsigned int version;</div>
<div class="line">    const unsigned char *buf;</div>
<div class="line">    size_t buflen;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">typedef struct ossl_record_template_st OSSL_RECORD_TEMPLATE;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Rather than a &quot;method&quot; approach, we could make this fetchable - Should we?</div>
<div class="line"> * There could be some complexity in finding suitable record layer implementations</div>
<div class="line"> * e.g. we need to find one that matches the negotiated protocol, cipher,</div>
<div class="line"> * extensions, etc. The selection_cb approach given above doesn&#39;t work so well</div>
<div class="line"> * if unknown third party providers with OSSL_RECORD_METHOD implementations are</div>
<div class="line"> * loaded.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * If this becomes public API then we will need functions to create and</div>
<div class="line"> * free an OSSL_RECORD_METHOD, as well as functions to get/set the various</div>
<div class="line"> * function pointers....unless we make it fetchable.</div>
<div class="line"> */</div>
<div class="line">struct ossl_record_method_st {</div>
<div class="line">    /*</div>
<div class="line">     * Create a new OSSL_RECORD_LAYER object for handling the protocol version</div>
<div class="line">     * set by |vers|. |role| is 0 for client and 1 for server. |direction|</div>
<div class="line">     * indicates either read or write. |level| is the protection level as</div>
<div class="line">     * described above. |settings| are mandatory settings that will cause the</div>
<div class="line">     * new() call to fail if they are not understood (for example to require</div>
<div class="line">     * Encrypt-Then-Mac support). |options| are optional settings that will not</div>
<div class="line">     * cause the new() call to fail if they are not understood (for example</div>
<div class="line">     * whether to use &quot;read ahead&quot; or not).</div>
<div class="line">     *</div>
<div class="line">     * The BIO in |transport| is the BIO for the underlying transport layer.</div>
<div class="line">     * Where the direction is &quot;read&quot;, then this BIO will only ever be used for</div>
<div class="line">     * reading data. Where the direction is &quot;write&quot;, then this BIO will only</div>
<div class="line">     * every be used for writing data.</div>
<div class="line">     *</div>
<div class="line">     * An SSL object will always have at least 2 OSSL_RECORD_LAYER objects in</div>
<div class="line">     * force at any one time (one for reading and one for writing). In some</div>
<div class="line">     * protocols more than 2 might be used (e.g. in DTLS for retransmitting</div>
<div class="line">     * messages from an earlier epoch).</div>
<div class="line">     *</div>
<div class="line">     * The created OSSL_RECORD_LAYER object is stored in *ret on success (or</div>
<div class="line">     * NULL otherwise). The return value will be one of</div>
<div class="line">     * OSSL_RECORD_RETURN_SUCCESS, OSSL_RECORD_RETURN_FATAL or</div>
<div class="line">     * OSSL_RECORD_RETURN_NON_FATAL. A non-fatal return means that creation of</div>
<div class="line">     * the record layer has failed because it is unsuitable, but an alternative</div>
<div class="line">     * record layer can be tried instead.</div>
<div class="line">     */</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * If we eventually make this fetchable then we will need to use something</div>
<div class="line">     * other than EVP_CIPHER. Also mactype would not be a NID, but a string. For</div>
<div class="line">     * now though, this works.</div>
<div class="line">     */</div>
<div class="line">    int (*new_record_layer)(OSSL_LIB_CTX *libctx,</div>
<div class="line">                            const char *propq, int vers,</div>
<div class="line">                            int role, int direction,</div>
<div class="line">                            int level,</div>
<div class="line">                            uint16_t epoch,</div>
<div class="line">                            unsigned char *key,</div>
<div class="line">                            size_t keylen,</div>
<div class="line">                            unsigned char *iv,</div>
<div class="line">                            size_t ivlen,</div>
<div class="line">                            unsigned char *mackey,</div>
<div class="line">                            size_t mackeylen,</div>
<div class="line">                            const EVP_CIPHER *ciph,</div>
<div class="line">                            size_t taglen,</div>
<div class="line">                            int mactype,</div>
<div class="line">                            const EVP_MD *md,</div>
<div class="line">                            COMP_METHOD *comp,</div>
<div class="line">                            BIO *prev,</div>
<div class="line">                            BIO *transport,</div>
<div class="line">                            BIO *next,</div>
<div class="line">                            BIO_ADDR *local,</div>
<div class="line">                            BIO_ADDR *peer,</div>
<div class="line">                            const OSSL_PARAM *settings,</div>
<div class="line">                            const OSSL_PARAM *options,</div>
<div class="line">                            const OSSL_DISPATCH *fns,</div>
<div class="line">                            void *cbarg,</div>
<div class="line">                            OSSL_RECORD_LAYER **ret);</div>
<div class="line">    int (*free)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    int (*reset)(OSSL_RECORD_LAYER *rl); /* Is this needed? */</div>
<div class="line"> </div>
<div class="line">    /* Returns 1 if we have unprocessed data buffered or 0 otherwise */</div>
<div class="line">    int (*unprocessed_read_pending)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Returns 1 if we have processed data buffered that can be read or 0 otherwise</div>
<div class="line">     * - not necessarily app data</div>
<div class="line">     */</div>
<div class="line">    int (*processed_read_pending)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * The amount of processed app data that is internally buffered and</div>
<div class="line">     * available to read</div>
<div class="line">     */</div>
<div class="line">    size_t (*app_data_pending)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Find out the maximum number of records that the record layer is prepared</div>
<div class="line">     * to process in a single call to write_records. It is the caller&#39;s</div>
<div class="line">     * responsibility to ensure that no call to write_records exceeds this</div>
<div class="line">     * number of records. |type| is the type of the records that the caller</div>
<div class="line">     * wants to write, and |len| is the total amount of data that it wants</div>
<div class="line">     * to send. |maxfrag| is the maximum allowed fragment size based on user</div>
<div class="line">     * configuration, or TLS parameter negotiation. |*preffrag| contains on</div>
<div class="line">     * entry the default fragment size that will actually be used based on user</div>
<div class="line">     * configuration. This will always be less than or equal to |maxfrag|. On</div>
<div class="line">     * exit the record layer may update this to an alternative fragment size to</div>
<div class="line">     * be used. This must always be less than or equal to |maxfrag|.</div>
<div class="line">     */</div>
<div class="line">    size_t (*get_max_records)(OSSL_RECORD_LAYER *rl, uint8_t type, size_t len,</div>
<div class="line">                              size_t maxfrag, size_t *preffrag);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Write |numtempl| records from the array of record templates pointed to</div>
<div class="line">     * by |templates|. Each record should be no longer than the value returned</div>
<div class="line">     * by get_max_record_len(), and there should be no more records than the</div>
<div class="line">     * value returned by get_max_records().</div>
<div class="line">     * Where possible the caller will attempt to ensure that all records are the</div>
<div class="line">     * same length, except the last record. This may not always be possible so</div>
<div class="line">     * the record method implementation should not rely on this being the case.</div>
<div class="line">     * In the event of a retry the caller should call retry_write_records()</div>
<div class="line">     * to try again. No more calls to write_records() should be attempted until</div>
<div class="line">     * retry_write_records() returns success.</div>
<div class="line">     * Buffers allocated for the record templates can be freed immediately after</div>
<div class="line">     * write_records() returns - even in the case a retry.</div>
<div class="line">     * The record templates represent the plaintext payload. The encrypted</div>
<div class="line">     * output is written to the |transport| BIO.</div>
<div class="line">     * Returns:</div>
<div class="line">     *  1 on success</div>
<div class="line">     *  0 on retry</div>
<div class="line">     * -1 on failure</div>
<div class="line">     */</div>
<div class="line">    int (*write_records)(OSSL_RECORD_LAYER *rl, OSSL_RECORD_TEMPLATE *templates,</div>
<div class="line">                         size_t numtempl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Retry a previous call to write_records. The caller should continue to</div>
<div class="line">     * call this until the function returns with success or failure. After</div>
<div class="line">     * each retry more of the data may have been incrementally sent.</div>
<div class="line">     * Returns:</div>
<div class="line">     *  1 on success</div>
<div class="line">     *  0 on retry</div>
<div class="line">     * -1 on failure</div>
<div class="line">     */</div>
<div class="line">    int (*retry_write_records)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Read a record and return the record layer version and record type in</div>
<div class="line">     * the |rversion| and |type| parameters. |*data| is set to point to a</div>
<div class="line">     * record layer buffer containing the record payload data and |*datalen|</div>
<div class="line">     * is filled in with the length of that data. The |epoch| and |seq_num|</div>
<div class="line">     * values are only used if DTLS has been negotiated. In that case they are</div>
<div class="line">     * filled in with the epoch and sequence number from the record.</div>
<div class="line">     * An opaque record layer handle for the record is returned in |*rechandle|</div>
<div class="line">     * which is used in a subsequent call to |release_record|. The buffer must</div>
<div class="line">     * remain available until release_record is called.</div>
<div class="line">     *</div>
<div class="line">     * Internally the the OSSL_RECORD_METHOD the implementation may read/process</div>
<div class="line">     * multiple records in one go and buffer them.</div>
<div class="line">     */</div>
<div class="line">    int (*read_record)(OSSL_RECORD_LAYER *rl, void **rechandle, int *rversion,</div>
<div class="line">                      uint8_t *type, unsigned char **data, size_t *datalen,</div>
<div class="line">                      uint16_t *epoch, unsigned char *seq_num);</div>
<div class="line">    /*</div>
<div class="line">     * Release a buffer associated with a record previously read with</div>
<div class="line">     * read_record. Records are guaranteed to be released in the order that they</div>
<div class="line">     * are read.</div>
<div class="line">     */</div>
<div class="line">    int (*release_record)(OSSL_RECORD_LAYER *rl, void *rechandle);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * In the event that a fatal error is returned from the functions above then</div>
<div class="line">     * get_alert_code() can be called to obtain a more details identifier for</div>
<div class="line">     * the error. In (D)TLS this is the alert description code.</div>
<div class="line">     */</div>
<div class="line">    int (*get_alert_code)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Update the transport BIO from the one originally set in the</div>
<div class="line">     * new_record_layer call</div>
<div class="line">     */</div>
<div class="line">    int (*set1_bio)(OSSL_RECORD_LAYER *rl, BIO *bio);</div>
<div class="line"> </div>
<div class="line">    /* Called when protocol negotiation selects a protocol version to use */</div>
<div class="line">    int (*set_protocol_version)(OSSL_RECORD_LAYER *rl, int version);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Whether we are allowed to receive unencrypted alerts, even if we might</div>
<div class="line">     * otherwise expect encrypted records. Ignored by protocol versions where</div>
<div class="line">     * this isn&#39;t relevant</div>
<div class="line">     */</div>
<div class="line">    void (*set_plain_alerts)(OSSL_RECORD_LAYER *rl, int allow);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Called immediately after creation of the record layer if we are in a</div>
<div class="line">     * first handshake. Also called at the end of the first handshake</div>
<div class="line">     */</div>
<div class="line">    void (*set_first_handshake)(OSSL_RECORD_LAYER *rl, int first);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Set the maximum number of pipelines that the record layer should process.</div>
<div class="line">     * The default is 1.</div>
<div class="line">     */</div>
<div class="line">    void (*set_max_pipelines)(OSSL_RECORD_LAYER *rl, size_t max_pipelines);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Called to tell the record layer whether we are currently &quot;in init&quot; or</div>
<div class="line">     * not. Default at creation of the record layer is &quot;yes&quot;.</div>
<div class="line">     */</div>
<div class="line">    void (*set_in_init)(OSSL_RECORD_LAYER *rl, int in_init);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Get a short or long human readable description of the record layer state</div>
<div class="line">     */</div>
<div class="line">    void (*get_state)(OSSL_RECORD_LAYER *rl, const char **shortstr,</div>
<div class="line">                      const char **longstr);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Set new options or modify ones that were originally specified in the</div>
<div class="line">     * new_record_layer call.</div>
<div class="line">     */</div>
<div class="line">    int (*set_options)(OSSL_RECORD_LAYER *rl, const OSSL_PARAM *options);</div>
<div class="line"> </div>
<div class="line">    const COMP_METHOD *(*get_compression)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Set the maximum fragment length to be used for the record layer. This</div>
<div class="line">     * will override any previous value supplied for the &quot;max_frag_len&quot;</div>
<div class="line">     * setting during construction of the record layer.</div>
<div class="line">     */</div>
<div class="line">    void (*set_max_frag_len)(OSSL_RECORD_LAYER *rl, size_t max_frag_len);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * The maximum expansion in bytes that the record layer might add while</div>
<div class="line">     * writing a record</div>
<div class="line">     */</div>
<div class="line">    size_t (*get_max_record_overhead)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Increment the record sequence number</div>
<div class="line">     */</div>
<div class="line">    int (*increment_sequence_ctr)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Allocate read or write buffers. Does nothing if already allocated.</div>
<div class="line">     * Assumes default buffer length and 1 pipeline.</div>
<div class="line">     */</div>
<div class="line">    int (*alloc_buffers)(OSSL_RECORD_LAYER *rl);</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Free read or write buffers. Fails if there is pending read or write</div>
<div class="line">     * data. Buffers are automatically reallocated on next read/write.</div>
<div class="line">     */</div>
<div class="line">    int (*free_buffers)(OSSL_RECORD_LAYER *rl);</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
