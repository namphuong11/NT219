<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: Fetching composite algorithms and using them - adding the bits still missing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Fetching composite algorithms and using them - adding the bits still missing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md213"></a>
Quick background</h1>
<p>We currently support - at least in the public libcrypto API - explicitly fetching composite algorithms (such as AES-128-CBC or HMAC-SHA256), and using them in most cases. In some cases (symmetric ciphers), our providers also provide them.</p>
<p>However, there is one class of algorithms where the support for <em>using</em> explicitly fetched algorithms is lacking: asymmetric algorithms.</p>
<p>For a longer background and explanation, see Background / tl;dr at the end of this design.</p>
<h1><a class="anchor" id="autotoc_md214"></a>
Public API - Add variants of <code>EVP_PKEY_CTX</code> initializers</h1>
<p>As far as this design is concerned, these API sets are affected:</p>
<ul>
<li>SIGNATURE (DigestSign and DigestVerify)</li>
<li>ASYM_CIPHER</li>
<li>KEYEXCH</li>
</ul>
<p>The proposal is to add these functions:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">EVP_DigestSignInit_ex2(EVP_PKEY_CTX **pctx,</div>
<div class="line">                       EVP_SIGNATURE *sig, EVP_PKEY *pkey,</div>
<div class="line">                       OSSL_LIB_CTX *libctx, const OSSL_PARAM params[]);</div>
<div class="line">EVP_DigestVerifyInit_ex2(EVP_PKEY_CTX **pctx,</div>
<div class="line">                         EVP_SIGNATURE *sig, EVP_PKEY *pkey,</div>
<div class="line">                         OSSL_LIB_CTX *libctx, const OSSL_PARAM params[]);</div>
<div class="line"> </div>
<div class="line">int EVP_PKEY_encrypt_init_ex2(EVP_PKEY_CTX *ctx, EVP_ASYM_CIPHER *asymciph,</div>
<div class="line">                              const OSSL_PARAM params[]);</div>
<div class="line">int EVP_PKEY_decrypt_init_ex2(EVP_PKEY_CTX *ctx, EVP_ASYM_CIPHER *asymciph,</div>
<div class="line">                              const OSSL_PARAM params[]);</div>
<div class="line"> </div>
<div class="line">int EVP_PKEY_derive_init_ex2(EVP_PKEY_CTX *ctx, EVP_KEYEXCH *exchange,</div>
<div class="line">                             const OSSL_PARAM params[]);</div>
</div><!-- fragment --><p>Because <code>EVP_SIGNATURE</code>, <code>EVP_ASYM_CIPHER</code> and <code>EVP_KEYEXCH</code> aren't limited to composite algorithms, these functions can be used just as well with explicit fetches of simple algorithms, say "RSA". In that case, the caller will need to pass necessary auxiliary parameters through the <code>OSSL_PARAM</code> or a call to a corresponding <code>set_params</code> function.</p>
<h1><a class="anchor" id="autotoc_md215"></a>
Requirements on the providers</h1>
<p>Because it's not immediately obvious from a composite algorithm name what key type it requires / supports, at least in code, allowing the use of an explicitly fetched implementation of a composite algorithm requires that providers cooperate by declaring what key type is required / supported by each algorithm.</p>
<p>For non-composite operation algorithms (like "RSA"), this is not necessary, see the fallback strategies below.</p>
<p>There are two ways this could be implemented:</p>
<ol type="1">
<li><p class="startli">through an added provider function that would work like keymgmt's <code>query_operation_name</code> function, but would return a key type name instead:</p>
<p class="startli">``` C </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md216"></a>
define OSSL_FUNC_SIGNATURE_QUERY_KEY_TYPE 26</h1>
<p>OSSL_CORE_MAKE_FUNC(const char *, signature_query_key_type, (void))</p>
<h1><a class="anchor" id="autotoc_md217"></a>
define OSSL_FUNC ASYM_CIPHER_QUERY_KEY_TYPE 12</h1>
<p>OSSL_CORE_MAKE_FUNC(const char *, asym_cipher_query_key_type, (void))</p>
<h1><a class="anchor" id="autotoc_md218"></a>
define OSSL_FUNC_KEYEXCH_QUERY_KEY_TYPE 11</h1>
<p>OSSL_CORE_MAKE_FUNC(const char *, keyexch_query_key_type, (void)) ```</p>
<ol type="1">
<li>through a gettable <code>OSSL_PARAM</code>, using the param identity "keytype"</li>
</ol>
<h2><a class="anchor" id="autotoc_md219"></a>
Fallback strategies</h2>
<p>Because existing providers haven't been updated to declare composite algorithms, or to respond to the key type query, some fallback strategies will be needed to find out if the <code>EVP_PKEY</code> key type is possible to use with the fetched algorithm:</p>
<ul>
<li>Check if the fetched operation name matches the key type (keymgmt name) of the <code>EVP_PKEY</code> that's involved in the operation. For example, this is useful when someone fetched the <code>EVP_SIGNATURE</code> "RSA".</li>
<li>Check if the fetched algorithm name matches the name returned by the keymgmt's <code>query_operation_name</code> function. For example, this is useful when someone fetched the <code>EVP_SIGNATURE</code> "ECDSA", for which the key type to use is "EC".</li>
<li>libcrypto currently has knowledge of some composite algorithm names and what they are composed of, accessible with <code>OBJ_find_sigid_algs</code> and similar functionality. This knowledge is regarded legacy, but can be used to figure out the key type.</li>
</ul>
<p>If none of these strategies work out, the operation initialization should fail.</p>
<p>These strategies have their limitations, but the built-in legacy knowledge we currently have in libcrypto should be enough to cover most bases.</p>
<hr  />
<hr  />
<h2><a class="anchor" id="autotoc_md222"></a>
Background / tl;dr</h2>
<h3><a class="anchor" id="autotoc_md223"></a>
What is a composite algorithm?</h3>
<p>A composite algorithm is an algorithm that's composed of more than one other algorithm. In OpenSSL parlance with a focus on signatures, they have been known as "sigalgs", but this is really broader than just signature algorithms. Examples are:</p>
<ul>
<li>AES-128-CBC</li>
<li>hmacWithSHA256</li>
<li>sha256WithRSAEncryption</li>
</ul>
<h3><a class="anchor" id="autotoc_md224"></a>
The connection with AlgorithmIdentifiers</h3>
<p>AlgorithmIdentifier is an ASN.1 structure that defines an algorithm as an OID, along with parameters that should be passed to that algorithm.</p>
<p>It is expected that an application should be able to take that OID and fetch it directly, after conversion to string form (either a name if the application or libcrypto happens to know it, or the OID itself in canonical numerical form). To enable this, explicit fetching is necessary.</p>
<h3><a class="anchor" id="autotoc_md225"></a>
What we have today</h3>
<p>As a matter of fact, we already have built-in support for fetching composite algorithms, although our providers do not fully participate in that support, and <em>most of the time</em>, we also have public APIs to use the fetched result, commonly known as support for explicit fetching.</p>
<p>The idea is that providers can declare the different compositions of a base algorithm in the <code>OSSL_ALGORITHM</code> array, each pointing to different <code>OSSL_DISPATCH</code> tables, which would in turn refer to pretty much the same functions, apart from the constructor function.</p>
<p>For example, we already do this with symmetric ciphers.</p>
<p>Another example, which we could implement in our providers today, would be compositions of HMAC:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">static const OSSL_ALGORITHM deflt_macs[] = {</div>
<div class="line">    /* ... */</div>
<div class="line">    { &quot;HMAC-SHA1:hmacWithSHA1:1.2.840.113549.2.7&quot;,</div>
<div class="line">      &quot;provider=default&quot;, ossl_hmac_sha1_functions },</div>
<div class="line">    { &quot;HMAC-SHA224:hmacWithSHA224:1.2.840.113549.2.8&quot;,</div>
<div class="line">      &quot;provider=default&quot;, ossl_hmac_sha224_functions },</div>
<div class="line">    { &quot;HMAC-SHA256:hmacWithSHA256:1.2.840.113549.2.9&quot;,</div>
<div class="line">      &quot;provider=default&quot;, ossl_hmac_sha256_functions },</div>
<div class="line">    { &quot;HMAC-SHA384:hmacWithSHA384:1.2.840.113549.2.10&quot;,</div>
<div class="line">      &quot;provider=default&quot;, ossl_hmac_sha384_functions },</div>
<div class="line">    { &quot;HMAC-SHA512:hmacWithSHA512:1.2.840.113549.2.11&quot;,</div>
<div class="line">      &quot;provider=default&quot;, ossl_hmac_sha512_functions },</div>
<div class="line">    /* ... */</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md226"></a>
What we don't have today</h3>
<p>There are some classes of algorithms for which we have no support for using the result of explicit fetching. So for example, while it's possible for a provider to declare composite algorithms through the <code>OSSL_ALGORITHM</code> array, there's currently no way for an application to use them.</p>
<p>This all revolves around asymmetric algorithms, where we currently only support implicit fetching.</p>
<p>This is hurtful in multiple ways:</p>
<ul>
<li>It fails the provider authors in terms being able to consistently declare all algorithms through <code>OSSL_ALGORITHM</code> arrays.</li>
<li>It fails the applications in terms of being able to fetch algorithms and use the result.</li>
<li>It fails discoverability, for example through the <code>openssl list</code> command. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
