<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC Thread Assisted Mode Synchronisation Requirements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC Thread Assisted Mode Synchronisation Requirements</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In thread assisted mode, we create a background thread to ensure that periodic QUIC processing is handled in a timely fashion regardless of whether an application is frequently calling (or blocked in) SSL API I/O functions.</p>
<p>Part of the QUIC state comprises the TLS handshake layer. However, synchronising access to this is extremely difficult.</p>
<p>At first glance, one could synchronise handshake layer public APIs by locking a per-connection mutex for the duration of any public API call which we forward to the handshake layer. Since we forward a very large number of APIs to the handshake layer, this would require a very large number of code changes to add the locking to every single public HL-related API call.</p>
<p>However, on second glance, this does not even solve the problem, as applications existing usage of the HL APIs assumes exclusive access, and thus consistency over multiple API calls. For example: </p><pre class="fragment">x = SSL_get_foo(s);
/* application mutates x */
SSL_set_foo(s, x);
</pre><p> For locking of API calls the lock would only be held for the separate get and set calls, but the combination of the two would not be safe if the assist thread can process some event which causes mutation of <code>foo</code>.</p>
<p>As such, there are really only three possible solutions:</p>
<ul>
<li><p class="startli"><b>1. Application-controlled explicit locking.</b></p>
<p class="startli">We would offer something like <code>SSL_lock()</code> and <code>SSL_unlock()</code>. An application performing a single HL API call, or a sequence of related HL calls, would be required to take the lock. As a special exemption, an application is not required to take the lock prior to connection (specifically, prior to the instantiation of a QUIC channel and consequent assist thread creation).</p>
<p class="startli">The key disadvantage here is that it requires more API changes on the application side, although since most HL API calls made by an application probably happen prior to initiating a connection, things may not be that bad. It would also only be required for applications which want to use thread assisted mode.</p>
<p class="startli">Pro: Most “robust” solution in terms of HL evolution.</p>
<p class="startli">Con: API changes.</p>
</li>
<li><p class="startli"><b>2. Handshake layer always belongs to the application thread.</b></p>
<p class="startli">In this model, the handshake layer “belongs” to the application thread and the assist thread is never allowed to touch it:</p><ul>
<li><code>SSL_tick()</code> (or another I/O function) called by the application fully services the connection.</li>
<li>The assist thread performs a reduced tick operation which does everything except servicing the crypto stream, or any other events we may define in future which would be processed by the handshake layer.</li>
<li>This is rather hacky but should work adequately. When using TLS 1.3 as the handshake layer, the only thing we actually need to worry about servicing after handshake completion is the New Session Ticket message, which doesn't need to be acknowledged and isn't “urgent”. The other post-handshake messages used by TLS 1.3 aren't relevant to QUIC TLS:<ul>
<li>Post-handshake authentication is not allowed;</li>
<li>Key update uses a separate, QUIC-specific method;</li>
<li>TLS alerts are signalled via <code>CONNECTION_CLOSE</code> frames rather than the TLS 1.3 Alert message; thus if a peer's HL does raise an alert after handshake completion (which would in itself be highly unusual), we simply receive a <code>CONNECTION_CLOSE</code> frame and process it normally.</li>
</ul>
</li>
</ul>
<p class="startli">Thus so long as we don't expect our own TLS implementation to spontaneously generate alerts or New Session Ticket messages after handshake completion, this should work.</p>
<p class="startli">Pro: No API changes.</p>
<p class="startli">Con: Somewhat hacky solution.</p>
</li>
<li><p class="startli"><b>3. Handshake layer belongs to the assist thread after connection begins.</b></p>
<p class="startli">In this model, the application may make handshake layer calls freely prior to connecting, but after that, ownership of the HL is transferred to the assist thread and may not be touched further. We would need to block all API calls which would forward to the HL after connection commences (specifically, after the QUIC channel is instantiated).</p>
<p class="startli">Con: Many applications probably expect to be able to query the HL after connection. We could selectively enable some important post-handshake HL calls by specially implementing synchronised forwarders, but doing this in the general case runs into the same issues as option 1 above. We could only enable APIs we think have safe semantics here; e.g. implement only getters and not setters, focus on APIs which return data which doesn't change after connection. The work required is proportional to the number of APIs to be enabled. Some APIs may not have ways to indicate failure; for such APIs which we don't implement for thread assisted post-handshake QUIC, we would essentially return incorrect data here.</p>
</li>
</ul>
<p>Option 2 has been chosen as the basis for implementation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
