<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC Fault Injector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC Fault Injector</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The OpenSSL QUIC implementation receives QUIC packets from the network layer and processes them accordingly. It will need to behave appropriately in the event of a misbehaving peer, i.e. one which is sending protocol elements (e.g. datagrams, packets, frames, etc) that are not in accordance with the specifications or OpenSSL's expectations.</p>
<p>The QUIC Fault Injector is a component within the OpenSSL test framework that can be used to simulate misbehaving peers and confirm that OpenSSL QUIC implementation behaves in the expected manner in the event of such misbehaviour.</p>
<p>Typically an individual test will inject one particular misbehaviour (i.e. a fault) into an otherwise normal QUIC connection. Therefore the fault injector will have to be capable of creating fully normal QUIC protocol elements, but also offer the flexibility for a test to modify those normal protocol elements as required for the specific test circumstances. The OpenSSL QUIC implementation in libssl does not offer the capability to send faults since it is designed to be RFC compliant.</p>
<p>The QUIC Fault Injector will be external to libssl (it will be in the test framework) but it will reuse the standards compliant QUIC implementation in libssl and will make use of 3 integration points to inject faults. 2 of these integration points will use new callbacks added to libssl. The final integration point does not require any changes to libssl to work.</p>
<h1><a class="anchor" id="autotoc_md383"></a>
QUIC Integration Points</h1>
<h2><a class="anchor" id="autotoc_md384"></a>
TLS Handshake</h2>
<p>Fault Injector based tests may need to inject faults directly into the TLS handshake data (i.e. the contents of CRYPTO frames). However such faults may need to be done in handshake messages that would normally be encrypted. Additionally the contents of handshake messages are hashed and each peer confirms that the other peer has the same calculated hash value as part of the "Finished" message exchange - so any modifications would be rejected and the handshake would fail.</p>
<p>An example test might be to confirm that an OpenSSL QUIC client behaves correctly in the case that the server provides incorrectly formatted transport parameters. These transport parameters are sent from the server in the EncryptedExtensions message. That message is encrypted and so cannot be modified by a "man-in-the-middle".</p>
<p>To support this integration point two new callbacks will be introduced to libssl that enables modification of handshake data prior to it being encrypted and hashed. These callbacks will be internal only (i.e. not part of the public API) and so only usable by the Fault Injector.</p>
<p>The new libssl callbacks will be as follows:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">typedef int (*ossl_statem_mutate_handshake_cb)(const unsigned char *msgin,</div>
<div class="line">                                               size_t inlen,</div>
<div class="line">                                               unsigned char **msgout,</div>
<div class="line">                                               size_t *outlen,</div>
<div class="line">                                               void *arg);</div>
<div class="line"> </div>
<div class="line">typedef void (*ossl_statem_finish_mutate_handshake_cb)(void *arg);</div>
<div class="line"> </div>
<div class="line">int ossl_statem_set_mutator(SSL *s,</div>
<div class="line">                            ossl_statem_mutate_handshake_cb mutate_handshake_cb,</div>
<div class="line">                            ossl_statem_finish_mutate_handshake_cb finish_mutate_handshake_cb,</div>
<div class="line">                            void *mutatearg);</div>
</div><!-- fragment --><p>The two callbacks are set via a single internal function call <code>ossl_statem_set_mutator</code>. The mutator callback <code>mutate_handshake_cb</code> will be called after each handshake message has been constructed and is ready to send, but before it has been passed through the handshake hashing code. It will be passed a pointer to the constructed handshake message in <code>msgin</code> along with its associated length in <code>inlen</code>. The mutator will construct a replacement handshake message (typically by copying the input message and modifying it) and store it in a newly allocated buffer. A pointer to the new buffer will be passed back in <code>*msgout</code> and its length will be stored in <code>*outlen</code>. Optionally the mutator can choose to not mutate by simply creating a new buffer with a copy of the data in it. A return value of 1 indicates that the callback completed successfully. A return value of 0 indicates a fatal error.</p>
<p>Once libssl has finished using the mutated buffer it will call the <code>finish_mutate_handshake_cb</code> callback which can then release the buffer and perform any other cleanup as required.</p>
<h2><a class="anchor" id="autotoc_md385"></a>
QUIC Pre-Encryption Packets</h2>
<p>QUIC Packets are the primary mechanism for exchanging protocol data within QUIC. Multiple packets may be held within a single datagram, and each packet may itself contain multiple frames. A packet gets protected via an AEAD encryption algorithm prior to it being sent. Fault Injector based tests may need to inject faults into these packets prior to them being encrypted.</p>
<p>An example test might insert an unrecognised frame type into a QUIC packet to confirm that an OpenSSL QUIC client handles it appropriately (e.g. by raising a protocol error).</p>
<p>The above functionality will be supported by the following two new callbacks which will provide the ability to mutate packets before they are encrypted and sent. As for the TLS callbacks these will be internal only and not part of the public API.</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">typedef int (*ossl_mutate_packet_cb)(const QUIC_PKT_HDR *hdrin,</div>
<div class="line">                                     const OSSL_QTX_IOVEC *iovecin, size_t numin,</div>
<div class="line">                                     QUIC_PKT_HDR **hdrout,</div>
<div class="line">                                     const OSSL_QTX_IOVEC **iovecout,</div>
<div class="line">                                     size_t *numout,</div>
<div class="line">                                     void *arg);</div>
<div class="line"> </div>
<div class="line">typedef void (*ossl_finish_mutate_cb)(void *arg);</div>
<div class="line"> </div>
<div class="line">void ossl_qtx_set_mutator(OSSL_QTX *qtx, ossl_mutate_packet_cb mutatecb,</div>
<div class="line">                          ossl_finish_mutate_cb finishmutatecb, void *mutatearg);</div>
</div><!-- fragment --><p>A single new function call will set both callbacks. The <code>mutatecb</code> callback will be invoked after each packet has been constructed but before protection has been applied to it. The header for the packet will be pointed to by <code>hdrin</code> and the payload will be in an iovec array pointed to by <code>iovecin</code> and containing <code>numin</code> iovecs. The <code>mutatecb</code> callback is expected to allocate a new header structure and return it in <code>*hdrout</code> and a new set of iovecs to be stored in <code>*iovecout</code>. The number of iovecs need not be the same as the input. The number of iovecs in the output array is stored in <code>*numout</code>. Optionally the callback can choose to not mutate by simply creating new iovecs/headers with a copy of the data in it. A return value of 1 indicates that the callback completed successfully. A return value of 0 indicates a fatal error.</p>
<p>Once the OpenSSL QUIC implementation has finished using the mutated buffers the <code>finishmutatecb</code> callback is called. This is expected to free any resources and buffers that were allocated as part of the <code>mutatecb</code> call.</p>
<h2><a class="anchor" id="autotoc_md386"></a>
QUIC Datagrams</h2>
<p>Encrypted QUIC packets are sent in datagrams. There may be more than one QUIC packet in a single datagram. Fault Injector based tests may need to inject faults directly into these datagrams.</p>
<p>An example test might modify an encrypted packet to confirm that the AEAD decryption process rejects it.</p>
<p>In order to provide this functionality the QUIC Fault Injector will insert itself as a man-in-the-middle between the client and server. A BIO_s_dgram_pair() will be used with one of the pair being used on the client end and the other being associated with the Fault Injector. Similarly a second BIO_s_dgram_pair() will be created with one used on the server and other used with the Fault Injector.</p>
<p>With this setup the Fault Injector will act as a proxy and simply pass datagrams sent from the client on to the server, and vice versa. Where a test requires a modification to be made, that will occur prior to the datagram being sent on.</p>
<p>This will all be implemented using public BIO APIs without requiring any additional internal libssl callbacks.</p>
<h1><a class="anchor" id="autotoc_md387"></a>
Fault Injector API</h1>
<p>The Fault Injector will utilise the callbacks described above in order to supply a more test friendly API to test authors.</p>
<p>This API will primarily take the form of a set of event listener callbacks. A test will be able to "listen" for a specific event occurring and be informed about it when it does. Examples of events might include:</p>
<ul>
<li>An EncryptedExtensions handshake message being sent</li>
<li>An ACK frame being sent</li>
<li>A Datagram being sent</li>
</ul>
<p>Each listener will be provided with additional data about the specific event. For example a listener that is listening for an EncryptedExtensions message will be provided with the parsed contents of that message in an easy to use structure. Additional helper functions will be provided to make changes to the message (such as to resize it).</p>
<p>Initially listeners will only be able to listen for events on the server side. This is because, in MVP, it will be the client side that is under test - so the faults need to be injected into protocol elements sent from the server. Post MVP this will be extended in order to be able to test the server. It may be that we need to do this during MVP in order to be able to observe protocol elements sent from the client without modifying them (i.e. in order to confirm that the client is behaving as we expect). This will be added if required as we develop the tests.</p>
<p>It is expected that the Fault Injector API will expand over time as new listeners and helper functions are added to support specific test scenarios. The initial API will provide a basic set of listeners and helper functions in order to provide the basis for future work.</p>
<p>The following outlines an illustrative set of functions that will initially be provided. A number of <code>TODO(QUIC TESTING)</code> comments are inserted to explain how we might expand the API over time:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">/* Type to represent the Fault Injector */</div>
<div class="line">typedef struct ossl_quic_fault OSSL_QUIC_FAULT;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Structure representing a parsed EncryptedExtension message. Listeners can</div>
<div class="line"> * make changes to the contents of structure objects as required and the fault</div>
<div class="line"> * injector will reconstruct the message to be sent on</div>
<div class="line"> */</div>
<div class="line">typedef struct ossl_qf_encrypted_extensions {</div>
<div class="line">    /* EncryptedExtension messages just have an extensions block */</div>
<div class="line">    unsigned char *extensions;</div>
<div class="line">    size_t extensionslen;</div>
<div class="line">} OSSL_QF_ENCRYPTED_EXTENSIONS;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Given an SSL_CTX for the client and filenames for the server certificate and</div>
<div class="line"> * keyfile, create a server and client instances as well as a fault injector</div>
<div class="line"> * instance. |block| indicates whether we are using blocking mode or not.</div>
<div class="line"> */</div>
<div class="line">int qtest_create_quic_objects(OSSL_LIB_CTX *libctx, SSL_CTX *clientctx,</div>
<div class="line">                              SSL_CTX *serverctx, char *certfile, char *keyfile,</div>
<div class="line">                              int block, QUIC_TSERVER **qtserv, SSL **cssl,</div>
<div class="line">                              OSSL_QUIC_FAULT **fault, BIO **tracebio);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Free up a Fault Injector instance</div>
<div class="line"> */</div>
<div class="line">void ossl_quic_fault_free(OSSL_QUIC_FAULT *fault);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Run the TLS handshake to create a QUIC connection between the client and</div>
<div class="line"> * server.</div>
<div class="line"> */</div>
<div class="line">int qtest_create_quic_connection(QUIC_TSERVER *qtserv, SSL *clientssl);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Same as qtest_create_quic_connection but will stop (successfully) if the</div>
<div class="line"> * clientssl indicates SSL_ERROR_WANT_XXX as specified by |wanterr|</div>
<div class="line"> */</div>
<div class="line">int qtest_create_quic_connection_ex(QUIC_TSERVER *qtserv, SSL *clientssl,</div>
<div class="line">                                    int wanterr);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Confirm that the server has received the given transport error code.</div>
<div class="line"> */</div>
<div class="line">int qtest_check_server_transport_err(QUIC_TSERVER *qtserv, uint64_t code);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Confirm the server has received a protocol error. Equivalent to calling</div>
<div class="line"> * qtest_check_server_transport_err with a code of QUIC_ERR_PROTOCOL_VIOLATION</div>
<div class="line"> */</div>
<div class="line">int qtest_check_server_protocol_err(QUIC_TSERVER *qtserv);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Enable tests to listen for pre-encryption QUIC packets being sent</div>
<div class="line"> */</div>
<div class="line">typedef int (*ossl_quic_fault_on_packet_plain_cb)(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                                  QUIC_PKT_HDR *hdr,</div>
<div class="line">                                                  unsigned char *buf,</div>
<div class="line">                                                  size_t len,</div>
<div class="line">                                                  void *cbarg);</div>
<div class="line"> </div>
<div class="line">int ossl_quic_fault_set_packet_plain_listener(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                    ossl_quic_fault_on_packet_plain_cb pplaincb,</div>
<div class="line">                                    void *pplaincbarg);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Helper function to be called from a packet_plain_listener callback if it</div>
<div class="line"> * wants to resize the packet (either to add new data to it, or to truncate it).</div>
<div class="line"> * The buf provided to packet_plain_listener is over allocated, so this just</div>
<div class="line"> * changes the logical size and never changes the actual address of the buf.</div>
<div class="line"> * This will fail if a large resize is attempted that exceeds the over</div>
<div class="line"> * allocation.</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_resize_plain_packet(OSSL_QUIC_FAULT *fault, size_t newlen);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Prepend frame data into a packet. To be called from a packet_plain_listener</div>
<div class="line"> * callback</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_prepend_frame(OSSL_QUIC_FAULT *fault, unsigned char *frame,</div>
<div class="line">                                  size_t frame_len);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * The general handshake message listener is sent the entire handshake message</div>
<div class="line"> * data block, including the handshake header itself</div>
<div class="line"> */</div>
<div class="line">typedef int (*ossl_quic_fault_on_handshake_cb)(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                               unsigned char *msg,</div>
<div class="line">                                               size_t msglen,</div>
<div class="line">                                               void *handshakecbarg);</div>
<div class="line"> </div>
<div class="line">int ossl_quic_fault_set_handshake_listener(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                           ossl_quic_fault_on_handshake_cb handshakecb,</div>
<div class="line">                                           void *handshakecbarg);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Helper function to be called from a handshake_listener callback if it wants</div>
<div class="line"> * to resize the handshake message (either to add new data to it, or to truncate</div>
<div class="line"> * it). newlen must include the length of the handshake message header. The</div>
<div class="line"> * handshake message buffer is over allocated, so this just changes the logical</div>
<div class="line"> * size and never changes the actual address of the buf.</div>
<div class="line"> * This will fail if a large resize is attempted that exceeds the over</div>
<div class="line"> * allocation.</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_resize_handshake(OSSL_QUIC_FAULT *fault, size_t newlen);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * TODO(QUIC TESTING): Add listeners for specific types of frame here. E.g.</div>
<div class="line"> * we might expect to see an &quot;ACK&quot; frame listener which will be passed</div>
<div class="line"> * pre-parsed ack data that can be modified as required.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Handshake message specific listeners. Unlike the general handshake message</div>
<div class="line"> * listener these messages are pre-parsed and supplied with message specific</div>
<div class="line"> * data and exclude the handshake header.</div>
<div class="line"> */</div>
<div class="line">typedef int (*ossl_quic_fault_on_enc_ext_cb)(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                             OSSL_QF_ENCRYPTED_EXTENSIONS *ee,</div>
<div class="line">                                             size_t eelen,</div>
<div class="line">                                             void *encextcbarg);</div>
<div class="line"> </div>
<div class="line">int ossl_quic_fault_set_hand_enc_ext_listener(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                              ossl_quic_fault_on_enc_ext_cb encextcb,</div>
<div class="line">                                              void *encextcbarg);</div>
<div class="line"> </div>
<div class="line">/* TODO(QUIC TESTING): Add listeners for other types of handshake message here */</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Helper function to be called from message specific listener callbacks. newlen</div>
<div class="line"> * is the new length of the specific message excluding the handshake message</div>
<div class="line"> * header.  The buffers provided to the message specific listeners are over</div>
<div class="line"> * allocated, so this just changes the logical size and never changes the actual</div>
<div class="line"> * address of the buffer. This will fail if a large resize is attempted that</div>
<div class="line"> * exceeds the over allocation.</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_resize_message(OSSL_QUIC_FAULT *fault, size_t newlen);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Helper function to delete an extension from an extension block. |exttype| is</div>
<div class="line"> * the type of the extension to be deleted. |ext| points to the extension block.</div>
<div class="line"> * On entry |*extlen| contains the length of the extension block. It is updated</div>
<div class="line"> * with the new length on exit.</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_delete_extension(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                     unsigned int exttype, unsigned char *ext,</div>
<div class="line">                                     size_t *extlen);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * TODO(QUIC TESTING): Add additional helper functions for querying extensions</div>
<div class="line"> * here (e.g. finding or adding them). We could also provide a &quot;listener&quot; API</div>
<div class="line"> * for listening for specific extension types.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Enable tests to listen for post-encryption QUIC packets being sent</div>
<div class="line"> */</div>
<div class="line">typedef int (*ossl_quic_fault_on_packet_cipher_cb)(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                                   /* The parsed packet header */</div>
<div class="line">                                                   QUIC_PKT_HDR *hdr,</div>
<div class="line">                                                   /* The packet payload data */</div>
<div class="line">                                                   unsigned char *buf,</div>
<div class="line">                                                   /* Length of the payload */</div>
<div class="line">                                                   size_t len,</div>
<div class="line">                                                   void *cbarg);</div>
<div class="line"> </div>
<div class="line">int ossl_quic_fault_set_packet_cipher_listener(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                ossl_quic_fault_on_packet_cipher_cb pciphercb,</div>
<div class="line">                                void *picphercbarg);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Enable tests to listen for datagrams being sent</div>
<div class="line"> */</div>
<div class="line">typedef int (*ossl_quic_fault_on_datagram_cb)(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                              BIO_MSG *m,</div>
<div class="line">                                              size_t stride,</div>
<div class="line">                                              void *cbarg);</div>
<div class="line"> </div>
<div class="line">int ossl_quic_fault_set_datagram_listener(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                          ossl_quic_fault_on_datagram_cb datagramcb,</div>
<div class="line">                                          void *datagramcbarg);</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * To be called from a datagram_listener callback. The datagram buffer is over</div>
<div class="line"> * allocated, so this just changes the logical size and never changes the actual</div>
<div class="line"> * address of the buffer. This will fail if a large resize is attempted that</div>
<div class="line"> * exceeds the over allocation.</div>
<div class="line"> */</div>
<div class="line">int ossl_quic_fault_resize_datagram(OSSL_QUIC_FAULT *fault, size_t newlen);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md388"></a>
Example Tests</h1>
<p>This section provides some example tests to illustrate how the Fault Injector might be used to create tests.</p>
<h2><a class="anchor" id="autotoc_md389"></a>
Unknown Frame Test</h2>
<p>An example test showing a server sending a frame of an unknown type to the client:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">/*</div>
<div class="line"> * Test that adding an unknown frame type is handled correctly</div>
<div class="line"> */</div>
<div class="line">static int add_unknown_frame_cb(OSSL_QUIC_FAULT *fault, QUIC_PKT_HDR *hdr,</div>
<div class="line">                                unsigned char *buf, size_t len, void *cbarg)</div>
<div class="line">{</div>
<div class="line">    static size_t done = 0;</div>
<div class="line">    /*</div>
<div class="line">     * There are no &quot;reserved&quot; frame types which are definitately safe for us</div>
<div class="line">     * to use for testing purposes - but we just use the highest possible</div>
<div class="line">     * value (8 byte length integer) and with no payload bytes</div>
<div class="line">     */</div>
<div class="line">    unsigned char unknown_frame[] = {</div>
<div class="line">        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    /* We only ever add the unknown frame to one packet */</div>
<div class="line">    if (done++)</div>
<div class="line">        return 1;</div>
<div class="line"> </div>
<div class="line">    return ossl_quic_fault_prepend_frame(fault, unknown_frame,</div>
<div class="line">                                         sizeof(unknown_frame));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">static int test_unknown_frame(void)</div>
<div class="line">{</div>
<div class="line">    int testresult = 0, ret;</div>
<div class="line">    SSL_CTX *cctx = SSL_CTX_new(OSSL_QUIC_client_method());</div>
<div class="line">    QUIC_TSERVER *qtserv = NULL;</div>
<div class="line">    SSL *cssl = NULL;</div>
<div class="line">    char *msg = &quot;Hello World!&quot;;</div>
<div class="line">    size_t msglen = strlen(msg);</div>
<div class="line">    unsigned char buf[80];</div>
<div class="line">    size_t byteswritten;</div>
<div class="line">    OSSL_QUIC_FAULT *fault = NULL;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_ptr(cctx))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(qtest_create_quic_objects(NULL, cctx, NULL, cert, privkey, 0,</div>
<div class="line">                                             &amp;qtserv, &amp;cssl, &amp;fault, NULL)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(qtest_create_quic_connection(qtserv, cssl)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * Write a message from the server to the client and add an unknown frame</div>
<div class="line">     * type</div>
<div class="line">     */</div>
<div class="line">    if (!TEST_true(ossl_quic_fault_set_packet_plain_listener(fault,</div>
<div class="line">                                                             add_unknown_frame_cb,</div>
<div class="line">                                                             NULL)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(ossl_quic_tserver_write(qtserv, (unsigned char *)msg, msglen,</div>
<div class="line">                                           &amp;byteswritten)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_size_t_eq(msglen, byteswritten))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    ossl_quic_tserver_tick(qtserv);</div>
<div class="line">    if (!TEST_true(SSL_tick(cssl)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_int_le(ret = SSL_read(cssl, buf, sizeof(buf)), 0))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_int_eq(SSL_get_error(cssl, ret), SSL_ERROR_SSL))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_int_eq(ERR_GET_REASON(ERR_peek_error()),</div>
<div class="line">                     SSL_R_UNKNOWN_FRAME_TYPE_RECEIVED))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(qtest_check_server_protocol_err(qtserv)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    testresult = 1;</div>
<div class="line"> err:</div>
<div class="line">    ossl_quic_fault_free(fault);</div>
<div class="line">    SSL_free(cssl);</div>
<div class="line">    ossl_quic_tserver_free(qtserv);</div>
<div class="line">    SSL_CTX_free(cctx);</div>
<div class="line">    return testresult;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md390"></a>
No Transport Parameters test</h2>
<p>An example test showing the case where a server does not supply any transport parameters in the TLS handshake:</p>
<div class="fragment"><div class="line"> C</div>
<div class="line">/*</div>
<div class="line"> * Test that a server that fails to provide transport params cannot be</div>
<div class="line"> * connected to.</div>
<div class="line"> */</div>
<div class="line">static int drop_transport_params_cb(OSSL_QUIC_FAULT *fault,</div>
<div class="line">                                    OSSL_QF_ENCRYPTED_EXTENSIONS *ee,</div>
<div class="line">                                    size_t eelen, void *encextcbarg)</div>
<div class="line">{</div>
<div class="line">    if (!ossl_quic_fault_delete_extension(fault,</div>
<div class="line">                                          TLSEXT_TYPE_quic_transport_parameters,</div>
<div class="line">                                          ee-&gt;extensions, &amp;ee-&gt;extensionslen))</div>
<div class="line">        return 0;</div>
<div class="line"> </div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">static int test_no_transport_params(void)</div>
<div class="line">{</div>
<div class="line">    int testresult = 0;</div>
<div class="line">    SSL_CTX *cctx = SSL_CTX_new(OSSL_QUIC_client_method());</div>
<div class="line">    QUIC_TSERVER *qtserv = NULL;</div>
<div class="line">    SSL *cssl = NULL;</div>
<div class="line">    OSSL_QUIC_FAULT *fault = NULL;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_ptr(cctx))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(qtest_create_quic_objects(NULL, cctx, NULL, cert, privkey, 0,</div>
<div class="line">                                             &amp;qtserv, &amp;cssl, &amp;fault, NULL)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(ossl_quic_fault_set_hand_enc_ext_listener(fault,</div>
<div class="line">                                                             drop_transport_params_cb,</div>
<div class="line">                                                             NULL)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">     * We expect the connection to fail because the server failed to provide</div>
<div class="line">     * transport parameters</div>
<div class="line">     */</div>
<div class="line">    if (!TEST_false(qtest_create_quic_connection(qtserv, cssl)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    if (!TEST_true(qtest_check_server_protocol_err(qtserv)))</div>
<div class="line">        goto err;</div>
<div class="line"> </div>
<div class="line">    testresult = 1;</div>
<div class="line"> err:</div>
<div class="line">    ossl_quic_fault_free(fault);</div>
<div class="line">    SSL_free(cssl);</div>
<div class="line">    ossl_quic_tserver_free(qtserv);</div>
<div class="line">    SSL_CTX_free(cctx);</div>
<div class="line">    return testresult;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
