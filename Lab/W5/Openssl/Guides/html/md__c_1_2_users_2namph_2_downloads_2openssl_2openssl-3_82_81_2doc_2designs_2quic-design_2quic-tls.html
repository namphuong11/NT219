<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Openssl Guides: QUIC-TLS Handshake Integration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Openssl Guides
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">QUIC-TLS Handshake Integration</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>QUIC reuses the TLS handshake for the establishment of keys. It does not use the standard TLS record layer and instead assumes responsibility for the confidentiality and integrity of QUIC packets itself. Only the TLS handshake is used. Application data is entirely protected by QUIC.</p>
<h1><a class="anchor" id="autotoc_md447"></a>
QUIC_TLS Object</h1>
<p>A QUIC-TLS handshake is managed by a QUIC_TLS object. This object provides 3 core functions to the rest of the QUIC implementation:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structquic__tls__st.html">QUIC_TLS</a> *ossl_quic_tls_new(<span class="keyword">const</span> <a class="code hl_struct" href="structquic__tls__args__st.html">QUIC_TLS_ARGS</a> *args);</div>
<div class="ttc" id="astructquic__tls__args__st_html"><div class="ttname"><a href="structquic__tls__args__st.html">quic_tls_args_st</a></div><div class="ttdef"><b>Definition</b> quic_tls.h:19</div></div>
<div class="ttc" id="astructquic__tls__st_html"><div class="ttname"><a href="structquic__tls__st.html">quic_tls_st</a></div><div class="ttdef"><b>Definition</b> quic_tls.c:22</div></div>
</div><!-- fragment --><p>The <code>ossl_quic_tls_new</code> function instantiates a new <code>QUIC_TLS</code> object associated with the QUIC Connection and initialises it with a set of callbacks and other arguments provided in the <code>args</code> parameter. These callbacks are called at various key points during the handshake lifecycle such as when new keys are established, crypto frame data is ready to be sent or consumed, or when the handshake is complete.</p>
<p>A key field of the <code>args</code> structure is the <code>SSL</code> object (<code>s</code>). This "inner" <code>SSL</code> object is initialised with an <code>SSL_CONNECTION</code> to represent the TLS handshake state. This is a different <code>SSL</code> object to the "user" visible <code>SSL</code> object which contains a <code>QUIC_CONNECTION</code>, i.e. the user visible <code>SSL</code> object contains a <code>QUIC_CONNECTION</code> which contains the inner <code>SSL</code> object which contains an <code>SSL_CONNECTION</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ossl_quic_tls_free(<a class="code hl_struct" href="structquic__tls__st.html">QUIC_TLS</a> *qtls);</div>
</div><!-- fragment --><p>When the QUIC Connection no longer needs the handshake object it can be freed via the <code>ossl_quic_tls_free</code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ossl_quic_tls_tick(<a class="code hl_struct" href="structquic__tls__st.html">QUIC_TLS</a> *qtls);</div>
</div><!-- fragment --><p>Finally the <code>ossl_quic_tls_tick</code> function is responsible for advancing the state of the QUIC-TLS handshake. On each call to <code>ossl_quic_tls_tick</code> newly received crypto frame data may be consumed, or new crypto frame data may be queued for sending, or one or more of the various callbacks may be invoked.</p>
<h1><a class="anchor" id="autotoc_md448"></a>
QUIC_TLS_ARGS</h1>
<p>A <code>QUIC_TLS_ARGS</code> object is passed to the <code>ossl_quic_tls_new</code> function by the OpenSSL QUIC implementation to supply a set of callbacks and other essential parameters. The <code>QUIC_TLS_ARGS</code> structure is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquic__tls__args__st.html">quic_tls_args_st</a> {</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * The &quot;inner&quot; SSL object for the QUIC Connection. Contains an</span></div>
<div class="line"><span class="comment">     * SSL_CONNECTION</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    SSL *s;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Called to send data on the crypto stream. We use a callback rather than</span></div>
<div class="line"><span class="comment">     * passing the crypto stream QUIC_SSTREAM directly because this lets the CSM</span></div>
<div class="line"><span class="comment">     * dynamically select the correct outgoing crypto stream based on the</span></div>
<div class="line"><span class="comment">     * current EL.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    int (*crypto_send_cb)(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> buf_len,</div>
<div class="line">                          <span class="keywordtype">size_t</span> *consumed, <span class="keywordtype">void</span> *arg);</div>
<div class="line">    <span class="keywordtype">void</span> *crypto_send_cb_arg;</div>
<div class="line">    int (*crypto_recv_cb)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> buf_len,</div>
<div class="line">                          <span class="keywordtype">size_t</span> *bytes_read, <span class="keywordtype">void</span> *arg);</div>
<div class="line">    <span class="keywordtype">void</span> *crypto_recv_cb_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Called when a traffic secret is available for a given encryption level. */</span></div>
<div class="line">    int (*yield_secret_cb)(uint32_t enc_level, <span class="keywordtype">int</span> direction <span class="comment">/* 0=RX, 1=TX */</span>,</div>
<div class="line">                           uint32_t suite_id, EVP_MD *md,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *secret, <span class="keywordtype">size_t</span> secret_len,</div>
<div class="line">                           <span class="keywordtype">void</span> *arg);</div>
<div class="line">    <span class="keywordtype">void</span> *yield_secret_cb_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Called when we receive transport parameters from the peer.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     * Note: These parameters are not authenticated until the handshake is</span></div>
<div class="line"><span class="comment">     * marked as completed.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    int (*got_transport_params_cb)(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *params,</div>
<div class="line">                                   <span class="keywordtype">size_t</span> params_len,</div>
<div class="line">                                   <span class="keywordtype">void</span> *arg);</div>
<div class="line">    <span class="keywordtype">void</span> *got_transport_params_cb_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Called when the handshake has been completed as far as the handshake</span></div>
<div class="line"><span class="comment">     * protocol is concerned, meaning that the connection has been</span></div>
<div class="line"><span class="comment">     * authenticated.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    int (*handshake_complete_cb)(<span class="keywordtype">void</span> *arg);</div>
<div class="line">    <span class="keywordtype">void</span> *handshake_complete_cb_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Called when something has gone wrong with the connection as far as the</span></div>
<div class="line"><span class="comment">     * handshake layer is concerned, meaning that it should be immediately torn</span></div>
<div class="line"><span class="comment">     * down. Note that this may happen at any time, including after a connection</span></div>
<div class="line"><span class="comment">     * has been fully established.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    int (*alert_cb)(<span class="keywordtype">void</span> *arg, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> alert_code);</div>
<div class="line">    <span class="keywordtype">void</span> *alert_cb_arg;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Transport parameters which client should send. Buffer lifetime must</span></div>
<div class="line"><span class="comment">     * exceed the lifetime of the QUIC_TLS object.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *transport_params;</div>
<div class="line">    <span class="keywordtype">size_t</span> transport_params_len;</div>
<div class="line">} <a class="code hl_struct" href="structquic__tls__args__st.html">QUIC_TLS_ARGS</a>;</div>
</div><!-- fragment --><p>The <code>crypto_send_cb</code> and <code>crypto_recv_cb</code> callbacks will be called by the QUIC-TLS handshake when there is new CRYPTO frame data to be sent, or when it wants to consume queued CRYPTO frame data from the peer.</p>
<p>When the TLS handshake generates secrets they will be communicated to the OpenSSL QUIC implementation via the <code>yield_secret_cb</code>, and when the handshake has successfully completed this will be communicated via <code>handshake_complete_cb</code>.</p>
<p>In the event that an error occurs a normal TLS handshake would send a TLS alert record. QUIC handles this differently and so the QUIC_TLS object will intercept attempts to send an alert and will communicate this via the <code>alert_cb</code> callback.</p>
<p>QUIC requires the use of a TLS extension in order to send and receive "transport
parameters". These transport parameters are opaque to the <code>QUIC_TLS</code> object. It does not need to use them directly but instead simply includes them in an extension to be sent in the ClientHello and receives them back from the peer in the EncryptedExtensions message. The data to be sent is provided in the <code>transport_params</code> argument. When the peer's parameters are received the <code>got_transport_params_cb</code> callback is invoked.</p>
<h1><a class="anchor" id="autotoc_md449"></a>
QUIC_TLS Implementation</h1>
<p>The <code>QUIC_TLS</code> object utilises two main mechanisms for fulfilling its functions:</p>
<ul>
<li>It registers itself as a custom TLS record layer</li>
<li>It supplies callbacks to register a custom TLS extension</li>
</ul>
<h2><a class="anchor" id="autotoc_md450"></a>
Custom TLS Record Layer</h2>
<p>A TLS record layer is defined via an <code>OSSL_RECORD_METHOD</code> object. This object consists of a set of function pointers which need to be implemented by any record layer. Existing record layers include one for TLS, one for DTLS and one for KTLS.</p>
<p><code>QUIC_TLS</code> registers itself as a custom TLS record layer. A new internal function is used to provide the custom record method data and associate it with an <code>SSL_CONNECTION</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ossl_ssl_set_custom_record_layer(<a class="code hl_struct" href="structssl__connection__st.html">SSL_CONNECTION</a> *s,</div>
<div class="line">                                      <span class="keyword">const</span> <a class="code hl_struct" href="structossl__record__method__st.html">OSSL_RECORD_METHOD</a> *meth,</div>
<div class="line">                                      <span class="keywordtype">void</span> *rlarg);</div>
<div class="ttc" id="astructossl__record__method__st_html"><div class="ttname"><a href="structossl__record__method__st.html">ossl_record_method_st</a></div><div class="ttdef"><b>Definition</b> recordmethod.h:88</div></div>
<div class="ttc" id="astructssl__connection__st_html"><div class="ttname"><a href="structssl__connection__st.html">ssl_connection_st</a></div><div class="ttdef"><b>Definition</b> ssl_local.h:1211</div></div>
</div><!-- fragment --><p>The internal function <code>ssl_select_next_record_layer</code> which is used in the TLS implementation to work out which record method should be used next is modified to first check whether a custom record method has been specified and always use that one if so.</p>
<p>The TLS record layer code is further modified to provide the following capabilities which are needed in order to support QUIC.</p>
<p>The custom record layer will need a record layer specific argument (<code>rlarg</code> above). This is passed as part of a modified <code>new_record_layer</code> call.</p>
<p>Existing TLS record layers use TLS keys and IVs that are calculated using a KDF from a higher level secret. Instead of this QUIC needs direct access to the higher level secret as well as the digest to be used in the KDF - so these values are now also passed through as part of the <code>new_record_layer</code> call.</p>
<p>The most important function pointers in the <code>OSSL_RECORD_METHOD</code> for the <code>QUIC_TLS</code> object are:</p>
<ul>
<li><code>new_record_layer</code></li>
</ul>
<p>Invoked every time a new record layer object is created by the TLS implementation. This occurs every time new keys are provisioned (once for the "read" side and once for the "write" side). This function is responsible for invoking the <code>yield_secret_cb</code> callback.</p>
<ul>
<li><code>write_records</code></li>
</ul>
<p>Invoked every time the TLS implementation wants to send TLS handshake data. This is responsible for calling the <code>crypto_send_cb</code> callback. It also includes special processing in the event that the TLS implementation wants to send an alert. This manifests itself as a call to <code>write_records</code> indicating a type of <code>SSL3_RT_ALERT</code>. The <code>QUIC_TLS</code> implementation of <code>write_records</code> must parse the alert data supplied by the TLS implementation (always a 2 byte record payload) and pull out the alert description (a one byte integer) and invoke the <code>alert_cb</code> callback. Note that while the TLS RFC strictly allows the 2 byte alert record to be fragmented across two 1 byte records this is never done in practice by OpenSSL's TLS stack and the <code>write_records</code> implementation can make the optimising assumption that both bytes of an alert are always sent together.</p>
<ul>
<li><code>quic_read_record</code></li>
</ul>
<p>Invoked when the TLS implementation wants to read more handshake data. This results in a call to <code>crypto_recv_cb</code>.</p>
<p>This design does introduce an extra "copy" in the process when <code>crypto_recv_cb</code> is invoked. CRYPTO frame data will be queued within internal QUIC "Stream
Receive Buffers" when it is received by the peer. However the TLS implementation expects to request data from the record layer, get a handle on that data, and then inform the record layer when it has finished using that data. The current design of the Stream Receive Buffers does not allow for this model. Therefore when <code>crypto_recv_cb</code> is invoked the data is copied into a QUIC_TLS object managed buffer. This is inefficient, so it is expected that a later phase of development will resolve this problem.</p>
<h2><a class="anchor" id="autotoc_md451"></a>
Custom TLS extension</h2>
<p>Libssl already has the ability for an application to supply a custom extension via the <code>SSL_CTX_add_custom_ext()</code> API. There is no equivalent <code>SSL_add_custom_ext()</code> and therefore an internal API is used to do this. This mechanism is used for supporting QUIC transport parameters. An extension type <code>TLSEXT_TYPE_quic_transport_parameters</code> with value 57 is used for this purpose.</p>
<p>The custom extension API enables the caller to supply <code>add</code>, <code>free</code> and <code>parse</code> callbacks. The <code>add</code> callback simply adds the <code>transport_params</code> data from <code>QUIC_TLS_ARGS</code>. The <code>parse</code> callback invokes the <code>got_transport_params_cb</code> callback when the transport parameters have been received from the peer.</p>
<h2><a class="anchor" id="autotoc_md452"></a>
ALPN</h2>
<p>QUIC requires the use of ALPN (Application-Layer Protocol Negotiation). This is normally optional in OpenSSL but is mandatory for QUIC connections. Therefore a QUIC client must call one of <code>SSL_CTX_set_alpn_protos</code> or <code>SSL_set_alpn_protos</code> prior to initiating the handshake. If the ALPN data has not been set then the <code>QUIC_TLS</code> object immediately fails.</p>
<h2><a class="anchor" id="autotoc_md453"></a>
Other Implementation Details</h2>
<p>The <code>SSL_CONNECTION</code> used for the TLS handshake is held alongside the QUIC related data in the <code>SSL</code> object. Public API functions that are only relevant to TLS will modify this internal <code>SSL_CONNECTION</code> as appropriate. This enables the end application to configure the TLS connection parameters as it sees fit (e.g. setting ciphersuites, providing client certificates, etc). However there are certain settings that may be optional in a normal TLS connection but are mandatory for QUIC. Where possible these settings will be automatically configured just before the handshake starts.</p>
<p>One of these settings is the minimum TLS protocol version. QUIC requires that TLSv1.3 is used as a minimum. Therefore the <code>QUIC_TLS</code> object automatically calls <code>SSL_set_min_proto_version()</code> and specifies <code>TLS1_3_VERSION</code> as the minimum version.</p>
<p>Secondly, QUIC enforces that the TLS "middlebox" mode must not be used. For normal TLS this is "on" by default. Therefore the <code>QUIC_TLS</code> object will automatically clear the <code>SSL_OP_ENABLE_MIDDLEBOX_COMPAT</code> option if it is set. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
